################################################################################
#   Gene prediction pipeline 
#
#   $Id: Makefile.xrate_tms 2781 2009-09-10 11:33:14Z andreas $
#
#   Copyright (C) 2005 Andreas Heger
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License
#   as published by the Free Software Foundation; either version 2
#   of the License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#################################################################################
#################################################################################
#################################################################################
##
## Makefile for the xrate_tms projects
## 
## In this project I wanted to calculate rates and dn/ds for type I and other
## types of transmembrane proteins.
##
#################################################################################
SHELL=/bin/bash --login

LOG=log

################################################
## Section parameters: start
################################################
## project name
PARAM_PROJECT_NAME?=xrate_tms
################################################

################################################
## Clade to use
PARAM_CLADE_NAME?=

################################################
## species to use
PARAM_SRC_SCHEMAS?=

################################################
## tree with species
PARAM_SPECIES_TREE?=

################################################
## Filename with src information using ks
PARAM_DIR_SRC_MALIS?=../malis/

## Pattern to find multiple alignments
PARAM_PATTERN_MALIS?=$(PARAM_DIR_SRC_MALIS)summary.dir/malis_genes_na.fasta

################################################
## Codon frequencies to use for paml
PARAM_MODEL_CODON_FREQUENCIES?=2

## not an increased threshold. This parameter is very sensitive
## and probably should not be changed.
PARAM_OPTIMIZATION_THRESHOLD?=1e-6

################################################
## Number of genomes
PARAM_NUM_GENOMES?=`echo $(PARAM_SRC_SCHEMAS) | wc -w`

## pattern to extract component from component map
PARAM_PATTERN_COMPONENT?=^(\S+)

## pattern to extract species from identifier
PARAM_PATTERN_IDENTIFIER?=^([^|]+)[|]

PARAM_SEPARATOR?=|

################################################
## minimum alignment length (in nucleotides)
PARAM_MINIMUM_MALI_LENGTH?=300

################################################
## For computing statistics of branches, ignore the following:
## mininum number of observed non-synonymous substitutions: N * dN
PARAM_MIN_NDN?=1

## minimum number of synonymous substitutions: S * dS
PARAM_MIN_SDS?=5

################################################
## minimum number of nucleotides required in
## both the N-terminus and the C-terminus to
## accept the result of a computation
PARAM_FILTER_MIN_LENGTH?=0

################################################
## Options for Gblocks
## Here: allow up to half the sequence to have gaps
PARAM_GBLOCKS_OPTIONS?=-b5=h

## Accept Gblocks alignments, if at least 50% of positions are kept,
## otherwise keep the original
PARAM_GBLOCKS_MIN_KEPT?=50

################################################
################################################
################################################
## Parameters for analysing duplications

PARAM_DIR_DATA?=../../../data/

## Tree in njtree format with correct names
PARAM_FILENAME_SPECIES_TREE?=$(PARAM_DIR_DATA)species_tree_sp

## Tree with permutations
PARAM_ANALYSIS_DUPLICATIONS_TREE?=$(PARAM_DIR_DATA)species_tree_permutations

## Map of species names to colours
PARAM_ANALYSIS_DUPLICATIONS_COLOURS?=$(PARAM_DIR_DATA)schema2colour

## Map of species names to urls
PARAM_ANALYSIS_DUPLICATIONS_URLS?=$(PARAM_DIR_DATA)schema2url

## Map of species to names
PARAM_ANALYSIS_DUPLICATIONS_TRANSLATION?=$(PARAM_DIR_DATA)schema2name

################################################
## input table names

################################################
## database schema with tm protein information
PARAM_SCHEMA_TMS?=$(PARAM_PROJECT_NAME)

################################################
## summary information on orthologous groups
PARAM_TABLE_NAME_GROUPS?=$(PARAM_CLADE_NAME).groups
## members of orthologous groups
PARAM_TABLE_NAME_GROUPS_MEMBERS?=$(PARAM_CLADE_NAME).groups_members
## table of strict 1:1 ortholog set info
PARAM_TABLE_NAME_ORTHOLOG_SETS?=$(PARAM_CLADE_NAME).ortholog_sets
## members of strict 1:1 ortholog sets
PARAM_TABLE_NAME_ORTHOLOG_SETS_MEMBERS?=$(PARAM_CLADE_NAME).ortholog_sets_members

## table with ortholog groups to take
PARAM_TABLE_NAME_FILTER?=$(PARAM_PROJECT_NAME).groups

# pattern for ortholog sets to collect.
PARAM_SELECT_SETS?=111111

################################################
## extra options for xrate
PARAM_XRATE_OPTIONS?=

################################################
# Section parameters: end
################################################
REQUISITES=input.species input.tree input.map

GENOMES_COMMA=`grep -v "^\#" input.species | xargs | perl -p -e "s/ +/,/g"`

#######################################################################################
#######################################################################################
#######################################################################################
prepare: input.species input.tree input.map 

#######################################################################################
#######################################################################################
#######################################################################################
input.species: 
	$(PRELOG)
	@rm -f $@
	@for x in $(PARAM_SRC_SCHEMAS); do \
		printf "%s\n" $${x} >> $@; \
	done
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Create input tree - unroot if necessary
#######################################################################################
input.tree:
	$(PRELOG)
	@echo "$(PARAM_SPECIES_TREE)" |\
	python $(DIR_SCRIPTS_TOOLS)tree2tree.py \
		--no-branch-lengths \
		--method=unroot \
		--verbose=0 > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
input.map:
	$(PRELOG)
	@$(PSQL_CONNECTION) \
	"SELECT DISTINCT sm.schema || '|' || sm.gene_id, o.cluster_id, sm.set_id \
	  FROM  $(PARAM_TABLE_NAME_ORTHOLOG_SETS_MEMBERS) AS sm, \
		$(PARAM_TABLE_NAME_ORTHOLOG_SETS) AS ss, \
		$(PARAM_TABLE_NAME_GROUPS) AS o \
		WHERE o.group_id = ss.group_id AND \
		ss.set_id = sm.set_id AND \
		sm.set_id IN \
		(SELECT s.set_id \
		FROM 	$(PARAM_TABLE_NAME_ORTHOLOG_SETS) AS s, \
		     	$(PARAM_TABLE_NAME_ORTHOLOG_SETS_MEMBERS) AS m, \
			$(PARAM_TABLE_NAME_FILTER) AS f \
			WHERE s.pattern='$(PARAM_SELECT_SETS)' AND \
				s.set_id = m.set_id AND \
				f.schema = m.schema AND \
				f.gene_id = m.gene_id)" \
	$(PSQL_CONNECTION_OPTIONS) > $@
	@$(CMD_LOG) "$@: number of clusters:" `cut -f 2 $@ | sort | uniq | wc -l`
	@$(CMD_LOG) "$@: number of sets:" `cut -f 3 $@ | sort | uniq | wc -l`
	@$(CMD_LOG) "$@: number of entries :" `wc -l < $@`
	@printf "species\ttranscripts\tgenes\n" $(TOLOG)
	@for x in $(PARAM_SRC_SCHEMAS); do \
		printf "%s\t%i\t%i\n" $${x} \
			`cut -f 1 $@ | grep $${x} | cut -d "$(PARAM_SEPARATOR)" -f 2 | sort | uniq | wc -l` \
			`cut -f 1 $@ | grep $${x} | cut -d "$(PARAM_SEPARATOR)" -f 3 | sort | uniq | wc -l` \
		$(TOLOG); \
	done
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## List of orthologous sets
#######################################################################################
sample.ref:
	$(PRELOG)
	@$(PSQL_CONNECTION) \
	"SELECT DISTINCT m.set_id \
	  FROM  $(PARAM_TABLE_NAME_ORTHOLOG_SETS) AS s, \
		$(PARAM_TABLE_NAME_ORTHOLOG_SETS_MEMBERS) AS m, \
		$(PARAM_TABLE_NAME_GROUPS_MEMBERS) AS gm, \
		$(PARAM_TABLE_NAME_GROUPS) AS o, \
		$(PARAM_TABLE_NAME_FILTER) AS f \
		WHERE s.set_id = m.set_id AND POSITION('0' IN s.pattern) = 0 AND \
			gm.schema = m.schema AND \
			f.group_id = o.group_id AND \
			gm.gene_id = m.gene_id AND \
			o.group_id = gm.group_id" \
	$(PSQL_CONNECTION_OPTIONS) > $@
	@$(CMD_LOG) "$@: number of sets:" `cut -f 1 $@ | sort | uniq | wc -l`
	@$(CMD_LOG) "$@: number of entries :" `wc -l < $@`
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## preparation of using all sets (for PAML)
## - output is fasta
## - mask transmembrane segments (requires input.masked_regions)
## - extract regions of interest (requires input.extract_regions)
#######################################################################################
data.prepare:
	$(PRELOG)
	$(MAKE) data.dir
	$(CMD_LOG) "creating directories and writing malis."
	@python $(DIR_SCRIPTS_TOOLS)malis2malis.py \
		--filename-components=input.map \
		--pattern-mali=$(PARAM_PATTERN_MALIS) \
	       	--pattern-component="^(\S+)" \
		--pattern-output="data.dir/cluster_%s.dir/cluster_%s.fasta" \
		--pattern-filter="^([^|]+)[|]" \
		--filename-filter=input.species \
		--filename-mask-regions=input.masked_regions \
		--filename-extract-regions=input.extract_regions \
		--minimum-mali-length=$(PARAM_MINIMUM_MALI_LENGTH) \
		--remove-all-gaps=3 \
		--remove-any-gaps=3 \
		--output-format=fasta > $@
	$(CMD_LOG) "adding files to directories."
	@for d in data.dir/cluster_*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		ln -fs ../../Makefile $${d}/Makefile; \
		ln -fs ../../input.tree $${d}/tree; \
		python $(DIR_SCRIPTS_GENEPREDICTION)WrapperCodeML.py \
			--filename-output=../cluster_$${cluster_id}_variable_w.output \
			--filename-tree=../tree \
			--filename-sequences=../cluster_$${cluster_id}.phylip \
			--write-control-file \
			--set-optimization-threshold=$(PARAM_OPTIMIZATION_THRESHOLD) \
			--set-codon-frequencies=$(PARAM_MODEL_CODON_FREQUENCIES) \
			--analysis=branch-specific-kaks |\
		grep -v "#" > $${d}/cluster_$${cluster_id}_variable_w.ctl; \
		python $(DIR_SCRIPTS_GENEPREDICTION)WrapperCodeML.py \
			--filename-output=../cluster_$${cluster_id}_fixed_w.output \
			--filename-sequences=../cluster_$${cluster_id}.phylip \
			--filename-tree=../tree \
			--set-codon-frequencies=$(PARAM_MODEL_CODON_FREQUENCIES) \
			--write-control-file \
			--set-optimization-threshold=$(PARAM_OPTIMIZATION_THRESHOLD) \
			--analysis=branch-fixed-kaks |\
		grep -v "#" > $${d}/cluster_$${cluster_id}_fixed_w.ctl; \
	done
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## preparation for xrate runs
## - output is stockholm format
## - mask transmembrane segments (requires input.masked_regions)
## - alignments are annotated (requires input.annotate_regions)
#######################################################################################
xrate.prepare: input.annotate_regions 
	$(PRELOG)
	$(MAKE) data.dir
	$(CMD_LOG) "creating directories and writing malis."
	@python $(DIR_SCRIPTS_TOOLS)malis2malis.py \
		--filename-components=input.map \
		--pattern-mali=$(PARAM_PATTERN_MALIS) \
	       	--pattern-component="^(\S+)" \
		--pattern-output="data.dir/cluster_%s.dir/cluster_%s.fasta" \
		--pattern-filter="^([^|]+)[|]" \
		--filename-filter=input.species \
		--filename-annotate-regions=input.annotate_regions \
		--filename-mask-regions=input.masked_regions \
		--remove-all-gaps=3 \
		--remove-any-gaps=3 \
		--minimum-mali-length=$(PARAM_MINIMUM_MALI_LENGTH) \
		--output-format=stockholm > $@
	$(CMD_LOG) "adding files to directories."
	@for d in data.dir/cluster_*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		ln -fs ../../Makefile $${d}/Makefile; \
		ln -fs ../../input.tree $${d}/tree; \
	done
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Creating the file input.masked_regions. 
##
## Both the transmembrane regions and the signal peptides are masked.
#######################################################################################
input.masked_regions:
	@$(PSQL_CONNECTION) \
	"SELECT set_id, tm_start, tm_end \
	FROM $(PARAM_SCHEMA_TMS).features AS f, \
	mm_v2.ortholog_sets_members AS m, \
	mm_hsapiens1.genes AS g \
	WHERE m.gene_id = g.gene_id \
	AND g.prediction_id = f.prediction_id \
	AND tm_start IS NOT NULL \
	AND m.schema = 'mm_hsapiens1'" \
	$(PSQL_CONNECTION_OPTIONS) > $@
	@$(PSQL_CONNECTION) \
	"SELECT set_id, signal_start, signal_end \
	FROM $(PARAM_SCHEMA_TMS).features AS f, \
	mm_v2.ortholog_sets_members AS m, \
	mm_hsapiens1.genes AS g \
	WHERE m.gene_id = g.gene_id \
	AND g.prediction_id = f.prediction_id \
	AND signal_start IS NOT NULL \
	AND m.schema = 'mm_hsapiens1'" \
	$(PSQL_CONNECTION_OPTIONS) >> $@


#######################################################################################
#######################################################################################
#######################################################################################
## input file with annotated N and C terminal regions
#######################################################################################
input.annotate_regions:
	@$(PSQL_CONNECTION) \
	"SELECT set_id, 0, tm_start, 'N' \
	FROM $(PARAM_SCHEMA_TMS).features AS f, \
	mm_v2.ortholog_sets_members AS m, \
	mm_hsapiens1.genes AS g \
	WHERE m.gene_id = g.gene_id \
	AND g.prediction_id = f.prediction_id \
	AND tm_start IS NOT NULL \
	AND m.schema = 'mm_hsapiens1'" \
	$(PSQL_CONNECTION_OPTIONS) > $@
	@$(PSQL_CONNECTION) \
	"SELECT set_id, tm_end, 99999999, 'C' \
	FROM $(PARAM_SCHEMA_TMS).features AS f, \
	mm_v2.ortholog_sets_members AS m, \
	mm_hsapiens1.genes AS g \
	WHERE m.gene_id = g.gene_id \
	AND g.prediction_id = f.prediction_id \
	AND tm_start IS NOT NULL \
	AND m.schema = 'mm_hsapiens1'" \
	$(PSQL_CONNECTION_OPTIONS) >> $@
	@$(PSQL_CONNECTION) \
	"SELECT set_id, tm_start, tm_end, 'M' \
	FROM $(PARAM_SCHEMA_TMS).features AS f, \
	mm_v2.ortholog_sets_members AS m, \
	mm_hsapiens1.genes AS g \
	WHERE m.gene_id = g.gene_id \
	AND g.prediction_id = f.prediction_id \
	AND tm_start IS NOT NULL \
	AND m.schema = 'mm_hsapiens1'" \
	$(PSQL_CONNECTION_OPTIONS) >> $@

#######################################################################################
#######################################################################################
#######################################################################################
## preparation for xrate runs
## - output is stockholm format
## - mask transmembrane segments (requires input.masked_regions)
## - alignments are annotated (requires input.annotate_regions)
#######################################################################################
xrate_full.prepare:
	$(PRELOG)
	$(MAKE) data.dir
	$(CMD_LOG) "creating directories and writing malis."
	@python $(DIR_SCRIPTS_TOOLS)malis2malis.py \
		--filename-components=input.map \
		--pattern-mali=$(PARAM_PATTERN_MALIS) \
	       	--pattern-component="^(\S+)" \
		--pattern-output="data.dir/cluster_%s.dir/cluster_%s.fasta" \
		--pattern-filter="^([^|]+)[|]" \
		--filename-filter=input.species \
		--filename-mask-regions=input.masked_regions \
		--remove-all-gaps=3 \
		--remove-any-gaps=3 \
		--minimum-mali-length=$(PARAM_MINIMUM_MALI_LENGTH) \
		--output-format=stockholm > $@
	$(CMD_LOG) "adding files to directories."
	@for d in data.dir/cluster_*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		ln -fs ../../Makefile $${d}/Makefile; \
		ln -fs ../../input.tree $${d}/tree; \
	done
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## preparation for using a single mali
#######################################################################################
example.prepare:
	$(PRELOG)
	$(MAKE) data.dir
	$(CMD_LOG) "creating directories and writing malis."
	@-mkdir data.dir/cluster_1.dir
	@python $(DIR_SCRIPTS_TOOLS)malis2mali.py \
		--filename-components=input.map \
		--pattern-mali=$(PARAM_PATTERN_MALIS) \
	       	--pattern-component="^(\S+)" \
		--pattern-identifier="^([^|]+)[|]" \
		--filename-mask-regions=input.masked_regions \
		--filename-extract-regions=input.extract_regions \
		--clean-mali=3 \
		--log=$@ \
		--output-format=fasta > data.dir/cluster_1.dir/cluster_1.fasta
	$(CMD_LOG) "adding files to directories."
	@for d in data.dir/cluster_*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		ln -fs ../../Makefile $${d}/Makefile; \
		ln -fs ../../input.tree $${d}/tree; \
		python $(DIR_SCRIPTS_GENEPREDICTION)WrapperCodeML.py \
			--filename-output=../cluster_$${cluster_id}_variable_w.output \
			--filename-tree=../tree \
			--filename-sequences=../cluster_$${cluster_id}.phylip \
			--write-control-file \
			--set-optimization-threshold=$(PARAM_OPTIMIZATION_THRESHOLD) \
			--set-codon-frequencies=$(PARAM_MODEL_CODON_FREQUENCIES) \
			--analysis=branch-specific-kaks |\
		grep -v "#" > $${d}/cluster_$${cluster_id}_variable_w.ctl; \
		python $(DIR_SCRIPTS_GENEPREDICTION)WrapperCodeML.py \
			--filename-output=../cluster_$${cluster_id}_fixed_w.output \
			--filename-sequences=../cluster_$${cluster_id}.phylip \
			--filename-tree=../tree \
			--set-codon-frequencies=$(PARAM_MODEL_CODON_FREQUENCIES) \
			--write-control-file \
			--set-optimization-threshold=$(PARAM_OPTIMIZATION_THRESHOLD) \
			--analysis=branch-fixed-kaks |\
		grep -v "#" > $${d}/cluster_$${cluster_id}_fixed_w.ctl; \
	done
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## preparation using length_sampled sets:
#######################################################################################
mapped_data.prepare:
	$(PRELOG)
	$(MAKE) data.dir
	$(CMD_LOG) "creating directories and writing malis."
	@python $(DIR_SCRIPTS_TOOLS)malis2malis.py \
		--filename-components=input.map \
		--pattern-mali=$(PARAM_PATTERN_MALIS) \
	       	--pattern-component="^(\S+)" \
		--pattern-output="data.dir/cluster_%s.dir/cluster_%s.fasta" \
		--pattern-filter="^([^|]+)[|]" \
		--filename-filter=input.species \
		--filename-mask-regions=input.masked_regions \
		--filename-extract-regions=input.extract_regions \
		--minimum-mali-length=$(PARAM_MINIMUM_MALI_LENGTH) \
		--clean-mali=3 \
		--sample=1 \
		--sample-method=length-without-replacement \
		--filename-sample-reference=sample.ref \
		--output-format=fasta > $@
	$(CMD_LOG) "adding files to directories."
	@for d in data.dir/cluster_*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		ln -fs ../../Makefile $${d}/Makefile; \
		ln -fs ../../input.tree $${d}/tree; \
		python $(DIR_SCRIPTS_GENEPREDICTION)WrapperCodeML.py \
			--filename-output=../cluster_$${cluster_id}_variable_w.output \
			--filename-tree=../tree \
			--filename-sequences=../cluster_$${cluster_id}.phylip \
			--write-control-file \
			--set-optimization-threshold=$(PARAM_OPTIMIZATION_THRESHOLD) \
			--set-codon-frequencies=$(PARAM_MODEL_CODON_FREQUENCIES) \
			--analysis=branch-specific-kaks |\
		grep -v "#" > $${d}/cluster_$${cluster_id}_variable_w.ctl; \
		python $(DIR_SCRIPTS_GENEPREDICTION)WrapperCodeML.py \
			--filename-output=../cluster_$${cluster_id}_fixed_w.output \
			--filename-sequences=../cluster_$${cluster_id}.phylip \
			--filename-tree=../tree \
			--set-codon-frequencies=$(PARAM_MODEL_CODON_FREQUENCIES) \
			--write-control-file \
			--set-optimization-threshold=$(PARAM_OPTIMIZATION_THRESHOLD) \
			--analysis=branch-fixed-kaks |\
		grep -v "#" > $${d}/cluster_$${cluster_id}_fixed_w.ctl; \
	done
	$(EPILOG)


#######################################################################################
#######################################################################################
#######################################################################################
## preparation for using a single mali
#######################################################################################
mapped_example.prepare:
	$(PRELOG)
	$(MAKE) data.dir
	$(CMD_LOG) "creating directories and writing malis."
	@-mkdir data.dir/cluster_1.dir
	@python $(DIR_SCRIPTS_TOOLS)malis2mali.py \
		--filename-components=input.map \
		--pattern-mali=$(PARAM_PATTERN_MALIS) \
	       	--pattern-component="^(\S+)" \
		--pattern-identifier="^([^|]+)[|]" \
		--filename-mask-regions=input.masked_regions \
		--filename-extract-regions=input.extract_regions \
		--clean-mali=3 \
		--sample=1 \
		--sample-method=length-without-replacement \
		--filename-sample-reference=sample.ref \
		--log=$@ \
		--output-format=fasta > data.dir/cluster_1.dir/cluster_1.fasta
	$(CMD_LOG) "adding files to directories."
	@for d in data.dir/cluster_*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		ln -fs ../../Makefile $${d}/Makefile; \
		ln -fs ../../input.tree $${d}/tree; \
		python $(DIR_SCRIPTS_GENEPREDICTION)WrapperCodeML.py \
			--filename-output=../cluster_$${cluster_id}_variable_w.output \
			--filename-tree=../tree \
			--filename-sequences=../cluster_$${cluster_id}.phylip \
			--write-control-file \
			--set-optimization-threshold=$(PARAM_OPTIMIZATION_THRESHOLD) \
			--set-codon-frequencies=$(PARAM_MODEL_CODON_FREQUENCIES) \
			--analysis=branch-specific-kaks |\
		grep -v "#" > $${d}/cluster_$${cluster_id}_variable_w.ctl; \
		python $(DIR_SCRIPTS_GENEPREDICTION)WrapperCodeML.py \
			--filename-output=../cluster_$${cluster_id}_fixed_w.output \
			--filename-sequences=../cluster_$${cluster_id}.phylip \
			--filename-tree=../tree \
			--set-codon-frequencies=$(PARAM_MODEL_CODON_FREQUENCIES) \
			--write-control-file \
			--set-optimization-threshold=$(PARAM_OPTIMIZATION_THRESHOLD) \
			--analysis=branch-fixed-kaks |\
		grep -v "#" > $${d}/cluster_$${cluster_id}_fixed_w.ctl; \
	done
	$(EPILOG)


#######################################################################################
#######################################################################################
#######################################################################################
## Progress report for data
#######################################################################################
data.show-progress:
	@echo "# prediction status at `date`" >> data.progress
	@nfix=0;nvar=0;nhook=0;nfasta=0;nxrate=0; \
	for d in data.dir/cluster*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		if test -s $${d}/cluster_$${cluster_id}.fasta; then let "nfasta=nfasta+1"; fi; \
		if test -s $${d}/cluster_$${cluster_id}.xrate; then let "nxrate=nxrate+1"; fi; \
		if test -s $${d}/cluster_$${cluster_id}_variable_w.paml; then let "nvar=nvar+1"; fi; \
		if test -s $${d}/cluster_$${cluster_id}_fixed_w.paml; then let "nfix=nfix+1"; fi; \
		if test -e $${d}/data.run-subhook; then let "nhook=nhook+1"; fi; \
	done; \
	awk -v nfasta="$${nfasta}" -v nfix="$${nfix}" -v nvar="$${nvar}" -v nhook="$${nhook}" -v nxrate="$${nxrate}" \
	   'END {  printf("# N\tNFIX\tPLEFT\tRSUCC\tNVAR\tPLEFT\tRSUCC\tNVAR\tPLEFT\tRSUCC\tNHOOK\tPLEFT\tRSUCC\n"); \
		printf("%i\t%i\t%5.2f\t%5.2f\t%i\t%5.2f\t%5.2f\t%i\t%5.2f\t%5.2f\t%i\t%5.2f\t%5.2f\n", \
			nfasta,\
			nfix,((nfasta-nfix)*100)/nfasta,(nfasta > 0) ? 100*nfix/nfasta : 0, \
			nvar,((nfasta-nvar)*100)/nfasta,(nfasta > 0) ? 100*nvar/nfasta : 0 , \
			nxrate,((nfasta-nxrate)*100)/nfasta,(nfasta > 0) ? 100*nxrate/nfasta : 0 , \
			nhook,((nfasta-nhook)*100)/nfasta,(nfasta > 0) ? 100*nhook/nfasta : 0 ); }' \
	</dev/null >> data.progress
	@tail data.progress

#######################################################################################
#######################################################################################
#######################################################################################
## Show missing files
#######################################################################################
data.show-unfinished:
	@for d in data.dir/cluster_*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		file=$${d}/cluster_$${cluster_id}_fixed_w.paml; \
		if test -e $${file} && ! grep -q "Time used:" $${file}; then \
			$(CMD_MSG2)  "unfinished $${file};"; \
		fi; \
		file=$${d}/cluster_$${cluster_id}_fixed_w_ml.tree; \
		if test -e $${file} && ! grep -q ">" $${file}; then \
			$(CMD_MSG2) "unfinished $${file};"; \
		fi; \
		file=$${d}/cluster_$${cluster_id}_variable_w.paml; \
		if test -e $${file} && ! grep -q "Time used:" $${file}; then \
			$(CMD_MSG2)  "unfinished $${file};"; \
		fi; \
		file=$${d}/cluster_$${cluster_id}_variable_w_ml.tree; \
		if test -e $${file} && ! grep -q ">" $${file}; then \
			$(CMD_MSG2) "unfinished $${file};"; \
		fi; \
		file=$${d}/cluster_$${cluster_id}.xrate; \
		if test -e $${file} && ! grep -q "# job finished" $${file}; then \
			$(CMD_MSG2) "unfinished $${file};"; \
		fi; \
	done

#######################################################################################
#######################################################################################
#######################################################################################
## Remove debris from aborted runs
#######################################################################################
data.remove-unfinished:
	$(PRELOG)
	@nfixed=0;nvariable=0;nxrate=0;\
	for d in data.dir/cluster_*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		file=$${d}/cluster_$${cluster_id}_fixed_w.paml; \
		if test -e $${file} && ! grep -q "Time used:" $${file}; then \
			$(CMD_MSG2)  "removing $${file};" >> $@.log; \
			rm -f $${file}; \
			let "nfixed=nfixed+1"; \
		fi; \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		file=$${d}/cluster_$${cluster_id}_variable_w.paml; \
		if test -e $${file} && ! grep -q "Time used:" $${file}; then \
			$(CMD_MSG2)  "removing $${file};" >> $@.log; \
			rm -f $${file}; \
			let "nvariable=nvariable+1"; \
		fi; \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		file=$${d}/cluster_$${cluster_id}.xrate; \
		if test -e $${file} && ! grep -q "# job finished:" $${file}; then \
			$(CMD_MSG2)  "removing $${file};" >> $@.log; \
			rm -f $${file}; \
			let "nxrate=nxrate+1"; \
		fi; \
	done; \
	$(CMD_LOG2) "removed $${nfixed} files: nfixed.paml"; \
	$(CMD_LOG2) "removed $${nvariable} files: variable.paml"; \
	$(CMD_LOG2) "removed $${nxrate} files: .xrate"
	$(EPILOG)


#######################################################################################
#######################################################################################
#######################################################################################
## Build targets in subdirectories
#######################################################################################
DATA=$(wildcard cluster_[0-9]*.dir)

#######################################################################################
## actor to choose: possible values are data-hook and xrate-hook
ACTOR?=data-hook

## do not depend on data.prepare, because example.prepare
## is an alternative requisite.
%.run:
	$(PRELOG)
	@$(MAKE) -C data.dir -k -j $(PARAM_NUM_JOBS) $@-hook
	$(EPILOG)

$(DATA):
	@$(MAKE) -C $@ data.run-subhook 

data.run-hook: $(DATA)

data.run-subhook: 
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) $(MAKE) $(ACTOR) < /dev/null 
	@touch $@
	$(EPILOG)


.PHONY: $(DATA)

#################################################################################
#################################################################################
#################################################################################
DATA_QUERIES_SUBDIR=$(wildcard *.ctl)
DATA_MALIS_SUBDIR=$(wildcard *.fasta)
DATA_TARGETS_SUBDIR=$(DATA_QUERIES_SUBDIR:%.ctl=%.paml) \
			$(DATA_QUERIES_SUBDIR:%.ctl=%.tree ) \
			$(DATA_MALIS_SUBDIR:%.fasta=%.pids) 

DATA_OUTPUT_FILES=$(wildcard partly_fixed*.output)

data-hook: $(DATA_TARGETS_SUBDIR)

#################################################################################
#################################################################################
#################################################################################
## Mask sequences for composition and incomplete codons and remove fully gapped 
## columns
#################################################################################
%.masked_mali: %.fasta
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)fasta2fasta.py --method=translate -v 0 < $< |\
	python $(DIR_SCRIPTS_TOOLS)fasta2fasta.py --method=mask-seg -v 0	> $@_tmp
	@python $(DIR_SCRIPTS_TOOLS)fasta2fasta.py \
		--method=mask-codons \
		--parameters=$@_tmp \
		--method=mask-incomplete-codons \
		--verbose=0 \
	< $*.fasta |\
	python $(DIR_SCRIPTS_TOOLS)mali2mali.py \
		--method=propagate-masks,remove-all-gaps,remove-empty-sequences \
		--mask-char="n" \
		--verbose=0 \
	> $@
	@rm -f $@_tmp
	$(EPILOG)

#################################################################################
#################################################################################
#################################################################################
## Run Gblocks on mali.
## Note: Gblocks always ends on error code 1, thus ignore it.
## If more than 50% is removed, keep the original alignment
#################################################################################
%.mali: %.masked_mali
	$(PRELOG)
	@rm -f $@.log
	@grep -v "#" $< |\
	perl -p -e "s/ //g" > $@_tmp
	@-Gblocks $@_tmp -t=c $(PARAM_GBLOCKS_OPTIONS) > $@.log
	@nkept=`grep "Gblocks alignment" $@.log | tail -n 1 | perl -p -e "s/.*positions \(//; s/ %\).*//;"`; \
	if [[ $${nkept} -lt "$(PARAM_GBLOCKS_MIN_KEPT)" ]]; then \
		printf "using original alignment\n" >> $@.log; \
		$(CMD_LOG2) "using original alignment"; \
		mv $@_tmp $@; \
	else \
		mv $@_tmp-gb $@; \
	fi; \
	rm -f $@_tmp*
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
## compute pairwise distances between sequences
###########################################################################
%.pids: %.mali
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)mali2rates.py \
		--distance=PID \
	< $< > $@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
## Prepare data for input
## 1. Convert mali to phylip format and perform the following operations on it:
##    Remove unaligned sequences
##    Rename identifiers in mali and tree to short identifiers
##    Remove alternative transcripts
##    Unroot tree
##    Remove everything but schema from identifier
%.phylip: %.mali
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)mali2mali.py \
		--method=remove-unaligned-pairs,remove-all-gaps \
		--output-format=phylip \
		--log=$@.log \
	< $< |\
	perl -p -e "s/[$(PARAM_SEPARATOR)]\S+//" \
	> $@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
## Running paml on a control file
###########################################################################
%_fixed_w.paml: %_fixed_w.ctl %.phylip
	$(PRELOG)
	@mkdir -p $@.dir
	@cd $@.dir >& /dev/null; codeml ../$< < /dev/null > ../$@
	@rm -rf $@.dir
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
## Running paml on a control file
###########################################################################
%_variable_w.paml: %_variable_w.ctl %.phylip
	$(PRELOG)
	@mkdir -p $@.dir
	@cd $@.dir >& /dev/null; codeml ../$< < /dev/null > ../$@
	@rm -rf $@.dir
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
## Running paml on a control file
###########################################################################
%_partly_fixed.paml: %_partly_fixed.ctl %.phylip
	$(PRELOG)
	@mkdir -p $@.dir
	@cd $@.dir >& /dev/null; codeml ../$< < /dev/null > ../$@
	@rm -rf $@.dir
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
## Running paml on a control file
###########################################################################
%.tree: %.paml 
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)codeml2tsv.py \
		--prefix=$* \
		--method=write-ks-tree \
		$*.output |\
	python $(DIR_SCRIPTS_TOOLS)tree2tree.py \
		--method=midpoint-root \
		--invert \
		--verbose=0 > $@
	$(EPILOG)


#################################################################################
#################################################################################
#################################################################################
## Targets for xrate
#################################################################################
XRATE_DATA_QUERIES_SUBDIR=$(wildcard *.fasta)
XRATE_DATA_TARGETS_SUBDIR=$(XRATE_DATA_QUERIES_SUBDIR:%.fasta=%.xrate)

xrate-hook: $(XRATE_DATA_TARGETS_SUBDIR)

XRATE_REGIMES=none ds kappa omega kappa-ds omega-ds all

###########################################################################
###########################################################################
###########################################################################
## compute rates with xrate
###########################################################################
%.xrate: %.fasta
	$(PRELOG)
	@for regime in $(XRATE_REGIMES); do \
		if ! test -e $@.$${regime}; then \
		python $(DIR_SCRIPTS_GENEPREDICTION)xrate_tms.py \
			--input-format=stockholm \
			--input-filename-tree=tree \
			--xrate-fix-frequencies \
			--xrate-insert-frequencies \
			--xrate-shared-rates=$${regime} \
			$(PARAM_XRATE_OPTIONS) \
			< $< > $@.$${regime}; \
		fi; \
	done
	touch $@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
## Collect data
##
## Kaks trees are filtered for a minimum of observed substitutions (ndn and sds).
## All others are not filtered.
###########################################################################
TREES_SECTIONS=fixed_w variable_w
TREES_DISTANCES=ks ka kaks sds ndn
TREES_ANALYSIS=ks ka kaks
TREES_AGGREGATES=mean stddev counts median

analysis.dir/trees:
	$(PRELOG)
	@rm -f $@*
	@for section in $(TREES_SECTIONS); do \
		rm -f $@.tmp; \
		for dir in data.dir/cluster_*.dir; do \
			cluster_id=$${dir#data.dir/cluster_}; \
			cluster_id=$${cluster_id%.dir}; \
			fa=$${dir}/cluster_$${cluster_id}_$${section}.paml; \
			fn=$${dir}/cluster_$${cluster_id}_$${section}.output; \
			if test -e $${fn} && grep -q "^Time used" $${fa}; then \
				printf "%s\t%s\n" $${fn} $${cluster_id} >> $@.tmp; \
			else \
				printf "skipped incomplete file %s\n" $${fn} >> $@.err; \
			fi; \
		done; \
		for distance in $(TREES_DISTANCES); do \
			python $(DIR_SCRIPTS_GENEPREDICTION)WrapperCodeML.py \
				--verbose=0 \
				--analysis=branch-specific-kaks \
				--parse-batch=$@.tmp \
				--parse-output=$${distance}-tree \
			< /dev/null \
			>> $@_$${section}_$${distance}.trees; \
		done; \
	done
	@rm -f $@.tmp
	@grep -c ">" $@_* > $@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
## Collect multiple alignment statistics.
###########################################################################
analysis.dir/malis:
	$(PRELOG)
	@rm -f $@.tmp
	@for dir in data.dir/cluster_*.dir; do \
		cluster_id=$${dir#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		fa=$${dir}/cluster_$${cluster_id}_fixed_w.paml; \
		fn=$${dir}/cluster_$${cluster_id}_fixed_w.output; \
		if test -e $${fn} && grep -q "^Time used" $${fa}; then \
			printf "%s\t%s\n" $${fn} $${cluster_id} >> $@.tmp; \
		else \
			printf "skipped incomplete file %s\n" $${fn} >> $@.err; \
		fi; \
	done
	@python $(DIR_SCRIPTS_GENEPREDICTION)WrapperCodeML.py \
		--verbose=0 \
		--analysis=branch-specific-kaks \
		--parse-batch=$@.tmp \
		--parse-output=mali \
		--parse-tabular \
	< /dev/null \
	> $@ 
	@rm -f $@.tmp	
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
## Collect gene trees. These are the same as the species trees but
## have the gene names added.
###########################################################################
analysis.dir/gene_trees:
	$(PRELOG)
	@rm -f $@*
	@for section in $(TREES_SECTIONS); do \
		rm -f $@.tmp; \
		for dir in data.dir/cluster_*.dir; do \
			cluster_id=$${dir#data.dir/cluster_}; \
			cluster_id=$${cluster_id%.dir}; \
			fa=$${dir}/cluster_$${cluster_id}_$${section}.paml; \
			fn=$${dir}/cluster_$${cluster_id}_$${section}.output; \
			fm=$${dir}/cluster_$${cluster_id}.fasta; \
			if test -e $${fn} && grep -q "^Time used" $${fa}; then \
				printf "%s\t%s\t""\t""\t%s\n" $${fn} $${cluster_id} $${fm} >> $@.tmp; \
			else \
				printf "skipped incomplete file %s\n" $${fn} >> $@.err; \
			fi; \
		done; \
		for distance in $(TREES_DISTANCES); do \
			python $(DIR_SCRIPTS_GENEPREDICTION)WrapperCodeML.py \
				--verbose=0 \
				--analysis=branch-specific-kaks \
				--parse-batch=$@.tmp \
				--parse-output=$${distance}-tree \
			< /dev/null \
			>> $@_$${section}_$${distance}.trees; \
		done; \
	done
	@grep -c ">" $@_* > $@
	$(EPILOG)

analysis: analysis.dir analysis.dir/trees analysis.dir/malis
	$(MAKE) -C analysis.dir build-summary-trees-hook

###########################################################################
###########################################################################
###########################################################################
## Filter and aggregate species tree information.
###########################################################################
%_sds.filter: 
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)trees2trees.py \
		--filter-min-length=$(PARAM_MIN_SDS) \
		--method=filter \
		--log=$@.log \
	< $*_sds.trees >$@
	$(EPILOG)

%_ndn.filter: 
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)trees2trees.py \
		--filter-min-length=$(PARAM_MIN_NDN) \
		--method=filter \
		--log=$@.log \
	< $*_ndn.trees > $@
	$(EPILOG)

build-summary-trees-hook:
	$(PRELOG)
	@for section in $(TREES_SECTIONS); do \
		if [ ! -e filter_$${section}_ndn.trees ]; then \
		python $(DIR_SCRIPTS_TOOLS)trees2trees.py \
			--filter-min-length=$(PARAM_MIN_NDN) \
			--method=filter \
			--log=$@.log \
			< trees_$${section}_ndn.trees > filter_$${section}_ndn.trees; \
		fi; \
		if [ ! -e filter_$${section}_sds.trees ]; then \
			python $(DIR_SCRIPTS_TOOLS)trees2trees.py \
			--filter-min-length=$(PARAM_MIN_SDS) \
			--method=filter \
			--log=$@.log \
			< trees_$${section}_ndn.trees > filter_$${section}_sds.trees; \
		fi; \
		for analysis in $(TREES_ANALYSIS); do \
			$(CMD_MSG2) "working on $${section} $${analysis}"; \
			if [[ $${analysis} == "kaks" ]]; then \
				$(CMD_MSG2) "filtering data with sds (>=$(PARAM_MIN_SDS) and ndn (>=$(PARAM_MIN_NDN))"; \
				python $(DIR_SCRIPTS_TOOLS)trees2trees.py \
					--filter-by-trees=filter_$${section}_sds.trees \
					--filter-by-trees=filter_$${section}_ndn.trees \
					--method=filter \
					--log=$@.log \
				< trees_$${section}_$${analysis}.trees > trees_$${section}_$${analysis} > $@.trees; \
			else \
				cat < trees_$${section}_$${analysis}.trees > trees_$${section}_$${analysis} > $@.trees; \
			fi ; \
			for type in $(TREES_AGGREGATES); do \
				$(MAKE) $@_$${type}.tree; \
				mv $@_$${type}.tree trees_$${section}_$${analysis}_$${type}.tree; \
				if [ -e $@.values ]; then \
					mv $@.values trees_$${section}_$${analysis}_$${type}.values ; \
				fi; \
			done; \
		done; \
		rm -f $@.tree; \
	done
	$(EPILOG)

#######################################################################################
%_mean.tree: %.trees
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)trees2tree.py \
		--log=$@.log \
		--error-branchlength=0 \
		--method=mean < $< > $@
	$(EPILOG)

%_stddev.tree: %.trees
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)trees2tree.py \
		--log=$@.log \
		--error-branchlength=0 \
		--method=stddev < $< > $@
	$(EPILOG)

%_counts.tree: %.trees
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)trees2tree.py \
		--log=$@.log \
		--error-branchlength=0 \
		--method=counts < $< > $@
	$(EPILOG)

%_median.tree: %.trees
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)trees2tree.py \
		--log=$@.log \
		--error-branchlength=0 \
		--method=median \
		--write-values=$*.values \
	< $< > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## analyse data from xrate runs
#######################################################################################
xrate_analysis: xrate_analysis.dir xrate_analysis.dir/rates.table xrate_analysis.dir/lnl.table xrate_analysis.dir/tests.table

#######################################################################################
#######################################################################################
#######################################################################################
xrate_analysis.dir/table:
	$(PRELOG)
	@printf "id\tNdN\tNdS\tNdNdS\tNlen\tNkappa\tMdN\tMdS\tMdNdS\tMlen\tMkappa\tCdN\tCdS\tCdNdS\tClen\tCkappa\tlnL\n" > $@
	@for dir in data.dir/cluster_*.dir; do \
		cluster_id=$${dir#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		filename=$${dir}/cluster_$${cluster_id}.xrate; \
		if test -e $${filename} && grep -q "# job finished" $${filename}; then \
			printf "%s" $${cluster_id} >> $@ ; \
			python $(DIR_SCRIPTS_TOOLS)csv_cut.py seq1 dN dS dNdS len kappa lnL< $${filename} |\
			awk '/dN/ {next;} {printf("\t%s\t%s\t%s\t%s\t%s", $$2,$$3,$$4,$$5,$$6); lnl=$$7} END {printf("\t%s\n", lnl);};' >> $@; \
		else \
			printf "output file missing: %s\n" $${filename} >> $@.error; \
		fi; \
	done
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## create one very large table with all columns
#######################################################################################
xrate_analysis.dir/rates.table:
	$(PRELOG)
	@rm -f $@.error
	@printf "id" > $@
	@rates="dN dS dNdS kappa"; \
	for regime in $(XRATE_REGIMES); do \
		for prefix in N C; do \
			for rate in $${rates}; do \
				printf "\t%s:%s:%s" $${regime} $${prefix} $${rate} >> $@; \
			done; \
		done; \
	done; \
	printf "\n" >> $@; \
	for dir in data.dir/cluster_*.dir; do \
		cluster_id=$${dir#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		filename=$${dir}/cluster_$${cluster_id}.xrate; \
		printf "%s" $${cluster_id} >> $@ ; \
		for regime in $(XRATE_REGIMES); do \
			if test -e $${filename}.$${regime} && grep -q "# job finished" $${filename}.$${regime}; then \
				python $(DIR_SCRIPTS_TOOLS)csv_cut.py -v 0 seq1 $${rates} < $${filename}.$${regime} |\
				awk '/seq1/ {next;} {for (x=2;x<=NF;++x) { printf("\t%s", $$x);} }' >> $@; \
			else \
				for x in N C; do \
					for x in $${rates}; do \
						printf "\tna" >> $@; \
					done; \
				done; \
				printf "output file missing: %s\n" $${filename}.$${regime} >> $@.error; \
			fi; \
		done; \
		printf "\n" >> $@; \
	done
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## summary information mali length, lnL
#######################################################################################
xrate_analysis.dir/lnl.table:
	$(PRELOG)
	@rm -f $@.error
	@printf "id" > $@
	@rates="lnL"; \
	infos="len"; \
	for x in N C; do \
		printf "\t%s:len" $${x} >> $@; \
	done; \
	for regime in $(XRATE_REGIMES); do \
		for rate in $${rates}; do \
			printf "\t%s:%s" $${regime} $${rate} >> $@; \
		done; \
	done; \
	printf "\n" >> $@; \
	for dir in data.dir/cluster_*.dir; do \
		cluster_id=$${dir#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		filename=$${dir}/cluster_$${cluster_id}.xrate; \
		printf "%s" $${cluster_id} >> $@ ; \
		regime="none"; \
		if test -e $${filename}.$${regime} && grep -q "# job finished" $${filename}.$${regime}; then \
			python $(DIR_SCRIPTS_TOOLS)csv_cut.py -v 0 seq1 $${infos} < $${filename}.$${regime} |\
			awk '/seq1/ {next;} {for (x=2;x<=NF;++x) { printf("\t%s", $$x);} }' >> $@; \
		else \
			printf "output file missing: %s\n" $${filename}.$${regime} >> $@.error; \
		fi; \
		for regime in $(XRATE_REGIMES); do \
			if test -e $${filename}.$${regime} && grep -q "# job finished" $${filename}.$${regime}; then \
				python $(DIR_SCRIPTS_TOOLS)csv_cut.py -v 0 seq1 $${rates} < $${filename}.$${regime} |\
				awk '/seq1/ {next;} {for (x=2;x<=NF;++x) { printf("\t%s", $$x);} exit 0}' >> $@; \
			else \
				printf "output file missing: %s\n" $${filename}.$${regime} >> $@.error; \
			fi; \
		done; \
		printf "\n" >> $@; \
	done
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## perform log likelihood ratio tests and apply length filter
#######################################################################################
xrate_analysis.dir/tests.table: xrate_analysis.dir/lnl.table
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)xrate_tms_lrt.py \
		--filename-graph=$@.graph \
		--min-length=$(PARAM_FILTER_MIN_LENGTH) \
		< $< > $@
	$(EPILOG)

xrate_analysis.dir/%.import: xrate_analysis.dir/%.table

xrate_analysis.dir/n_dnds.hist:  xrate_analysis.dir/rates.table
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)csv_cut.py id kappa-ds:N:dNdS kappa-ds:C:dNdS < $< |\
	python $(DIR_SCRIPTS_TOOLS)filter_tokens.py --apply=passed --column=1 -v 0 |\
	cut -f 2 |\
	python $(DIR_SCRIPTS_TOOLS)data2histogram.py --dynamic-bins --cumulative -v 0 --normalize > $@
	$(EPILOG)

xrate_analysis.dir/c_dnds.hist:  xrate_analysis.dir/rates.table
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)csv_cut.py id kappa-ds:N:dNdS kappa-ds:C:dNdS < $< |\
	python $(DIR_SCRIPTS_TOOLS)filter_tokens.py --apply=passed --column=1 -v 0 |\
	cut -f 3 |\
	python $(DIR_SCRIPTS_TOOLS)data2histogram.py --dynamic-bins --cumulative -v 0 --normalize > $@
	$(EPILOG)

#######################################################################################

include $(DIR_SCRIPTS_GENEPREDICTION)/makefiles/Makefile.common

