################################################################################
#   Gene prediction pipeline 
#
#   $Id: Makefile.orthology_multiple 2781 2009-09-10 11:33:14Z andreas $
#
#   Copyright (C) 2005 Andreas Heger
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License
#   as published by the Free Software Foundation; either version 2
#   of the License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#################################################################################
SHELL=/bin/bash --login

LOG=log

################################################
## Section parameters: start
################################################
## project name
PARAM_PROJECT_NAME?=geneprediction
################################################
## directory to upload information to
PARAM_DIR_UPLOAD=?/home/andreas/uploads/

################################################
## directory on where to find pairwise orthology assignments
PARAM_DIR_ORTHOLOGS?=../orthology_pairwise/

################################################
## table with ortholog information
PARAM_TABLE_NAME_CLUSTERS_MEMBERS?=$(PARAM_PROJECT_NAME).clusters_members

################################################
## genome parameters

## pattern to identify master genome
PARAM_INPUT_GENOME_MASTER?=

## species tree
PARAM_SPECIES_TREE?=

################################################
## database schemas (corresponding to species)
PARAM_SRC_SCHEMAS?=

################################################
PARAM_SEPARATOR?=|

################################################
## quality codes of genes to take
PARAM_RESTRICT_QUALITY?=CG,SG,PG,RG,CP,SP,PP

################################################
## step1
PARAM_STEP1_MAX_DISTANCE?=0.7

## minimum consistency for consistency filtering: edge
PARAM_STEP1_ORTHOLOGS_MIN_CONSISTENCY_EDGE?=30

## minimum consistency for consistency filtering: vertex
PARAM_STEP1_ORTHOLOGS_MIN_CONSISTENCY_VERTEX?=50

## minimum overlap between two clusters for joining
## 0.5: at least 50% of one cluster need to overlap with
## other cluster.
PARAM_STEP1_ORTHOLOGS_MIN_PERCENT_OVERLAP?=0.5

## minimum number of best hits in each direction in order
## to join a cluster.
PARAM_STEP1_ORTHOLOGS_MIN_BESTHITS?=2

## minimum number of best hits in each direction in order
## to join a cluster with an orphan.
PARAM_STEP1_ORTHOLOGS_MIN_ORPHANS?=1

## minimum minimum and maximum coverage for adding orphans from
## besthits graph
PARAM_STEP1_ORTHOLOGS_MIN_MIN_COVERAGE?=0
PARAM_STEP1_ORTHOLOGS_MIN_MAX_COVERAGE?=0.75

## maximum mumber of iterations for adding besthit orphans
PARAM_STEP1_ORTHOLOGS_ORPHANS_MAX_ITERATIONS?=30

################################################
## Src directory required for building check
## of bitscores within/between clusters
PARAM_DIR_SRC?=../orthology_pairwise/

################################################
# Section parameters: end
################################################
INPUT_ORTHOLOGS=orthologs.links.gz
INPUT_BESTHITS=besthits.links.gz
FILES_REQUISITES=$(INPUT_ORTHOLOGS) $(INPUT_BESTHITS)

################################################
GENOMES_COMMA=`echo $(PARAM_SRC_SCHEMAS) | perl -p -e "s/ +/,/g"`

################################################
## Five stage orthology clustering
## 1. Pairwise orthology assignment
## 2. Consistency filtering
## 3. Combining clusters by overlap
## 4. Combining clusters by reciprocal blast best hits
## 5. Adding orphans by reciprocal blast best hits
STEP1_STAGES=   orthologs 
#		orthologs_consistent \
#		orthologs_consistent_bygenes \
#		orthologs_consistent_bygenes_orphans

#STEP1_FINAL_STAGE=orthologs_consistent_bygenes_orphans
STEP1_FINAL_STAGE=orthologs_consistent_bygenes_orphans
STEP1_STAGES_COMPONENTS=$(STEP1_STAGES:%=%.components) 
STEP1_STAGES_STATS=$(STEP1_STAGES:%=%.summary) $(STEP1_STAGES:%=%.stats) 

## targets to compute in each stage
STEP1_STAGES_RESULTS=$(STEP1_STAGES_COMPONENTS) \
			$(STEP1_STAGES_STATS) \
			$(STEP1_STAGES:%=%.orgs_per_cluster) \
			$(STEP1_STAGES:%=%.stats_missed_queries) \
			$(STEP1_FINAL_STAGE).pairs 

## include the following into the results pictures
ANALYSIS_RESULTS=orthologs orthologs_consistent orthologs_consistent_bygenes orthologs_consistent_bygenes_orphans

##################################################################################
##################################################################################
##################################################################################
prepare: create-log create-tables orthologs.links.gz besthits.links.gz
	$(PRELOG)
	$(EPILOG)

##################################################################################
##################################################################################
##################################################################################
create-tables: $(PARAM_TABLE_NAME_CLUSTERS_MEMBERS).create-table-orthogroups

##################################################################################
##################################################################################
##################################################################################
## Cluster orthologies
all: $(STEP1_STAGES_RESULTS) summary.components.map summary.components.load

##################################################################################
##################################################################################
##################################################################################
## Build file with ortholog links. 
## Adds links between genes and include orphans.
##################################################################################
orthologs.links.gz: $(PARAM_DIR_ORTHOLOGS)summary.dir/orthologs_first.links.gz $(PARAM_DIR_ORTHOLOGS)summary.dir/orphans_first.links.gz
	$(PRELOG)
	@rm -f $@
	@for file in $^; do \
		cat $${file} >> $@; \
	done;
	@gunzip < $@ |\
		perl $(DIR_SCRIPTS_TOOLS)graph_links2tokens.pl |\
		python $(DIR_SCRIPTS_GENEPREDICTION)gpipe/gene2gene.py \
			--log=$@.log |\
		gzip > $@.tmp
	@cat $@.tmp >> $@
	@rm -f $@.tmp
	@if test -e $(PARAM_DIR_ORTHOLOGS)summary.dir/besthits.links.gz; then \
		gunzip < $(PARAM_DIR_ORTHOLOGS)summary.dir/besthits.links.gz |\
		perl $(DIR_SCRIPTS_TOOLS)graph_links2tokens.pl |\
		python $(DIR_SCRIPTS_GENEPREDICTION)gpipe/gene2gene.py \
			--log=$@.log \
			--restrict-quality=$(PARAM_RESTRICT_QUALITY) |\
		gzip >> $@; \
	fi
	$(EPILOG)	

##################################################################################
##################################################################################
##################################################################################
## Import best hits.
##################################################################################
besthits.links.gz: $(PARAM_DIR_ORTHOLOGS)summary.dir/besthits.links.gz
	$(PRELOG)
	@ln -fs $< $@
	$(EPILOG)

#######################################################################
## building a consistency weighted graph
orthologs_consistent.links.gz: $(INPUT_ORTHOLOGS)
	$(PRELOG)
	@gunzip < $(INPUT_ORTHOLOGS) |\
	cut -f 1,2,3 | grep -v "#" > $@_tmp
	@ga_graph -e $(PARAM_STEP1_ORTHOLOGS_MIN_CONSISTENCY_EDGE) $@_tmp > $@_before_filtering
	@rm -f $@_tmp
	@cut -f 1,2,7 $@_before_filtering |\
	awk '!/^#/ {printf("%s\t%s\t%s\t\n%s\t%s\t%s\n", $$1, $$2, $$3, $$2, $$1, $$3); }' |\
	sort -k1,1 -k2,2 -k3,3n |\
	awk '{printf("%s\t%s\t%s\n", $$1, "dummy", $$3);}' |\
	python $(DIR_SCRIPTS_TOOLS)graph_combine_links_redundant.py |\
	awk '$$4 >= $(PARAM_STEP1_ORTHOLOGS_MIN_CONSISTENCY_VERTEX)' > $@_high_consistency_vertices
	@perl $(DIR_SCRIPTS_TOOLS)graph_filter_links_vertices.pl $@_high_consistency_vertices < $@_before_filtering |\
	gzip > $@
	$(CMD_LOG) "consistent edges after edge filtering."
	@perl $(DIR_SCRIPTS_TOOLS)graph_howmany.pl < $@_before_filtering $(TOLOG)
	$(CMD_LOG) "consistent edges after vertex filtering."
	@gunzip < $@ | perl $(DIR_SCRIPTS_TOOLS)graph_howmany.pl $(TOLOG)
	$(EPILOG)

#######################################################################
## building a consistency weighted graph
orthologs_vertex.links: $(INPUT_ORTHOLOGS)
	$(PRELOG)
	@gunzip < $(INPUT_ORTHOLOGS) |\
	cut -f 1,2,3 > $@_tmp
	@ga_graph -k $@_tmp > $@_before_filtering	
	@awk '!/^#/ && $$2 == 1.0' < $@_before_filtering > $@_vertices
	@perl $(DIR_SCRIPTS_TOOLS)graph_filter_links_vertices.pl $@_vertice < $@_tmp  > $@
	$(EPILOG)

#######################################################################
##
## rejoin clusters with overlapping predictions (transcript clusters)
##
## 1. Build bi-partite graph of clusters to genes
## 2. Write links for genes that maps to two clusters (or more).
##	add self links, so that ga_components prints singletons.
## 	These links will have at least a weight two after combination,
## 	because each cluster has at least two members.
## 3. Sort the results and combine links. Edge weight is number of shared genes. 
## 4. Weight links by total number of genes in cluster. Take maximum of
## 	adjacent vertices to set edge weight
## 5. Filter graph and keep links with at least $(PARAM_STEP1_ORTHOLOGS_MIN_PERCENT_OVERLAP) 
##	shared genes.
## 6. Cluster graph by components and map old clusters to new clusters.
%_bygenes.clusters2genes.links: %.components predictions2genes
	$(PRELOG)
	@grep -v "#" < $*.components.map |\
	python $(DIR_SCRIPTS_TOOLS)substitute_tokens.py --apply=predictions2genes --columns=1  |\
	sort | uniq > $@
	$(EPILOG)

%_bygenes.clusters2sizes: %_bygenes.clusters2genes.links
	$(PRELOG)
	@cut -f 2 $*_bygenes.clusters2genes.links | sort | uniq -c | awk '{printf("%s\t%s\n", $$2, $$1);}' > $@
	$(EPILOG)

%_bygenes.clusters2clusters.links: %_bygenes.clusters2genes.links %_bygenes.clusters2sizes
	$(PRELOG)
	@sort $*_bygenes.clusters2genes.links |\
	awk 'BEGIN {li=0;lc=0} { \
		if ($$1 != li) { \
			for (x in a) { printf("%s\t%s\t1\n",x,x); delete a[x]; for (y in a) { printf("%s\t%s\t1\n",x,y) } }; \
			li=$$1; lc=0; \
		} \
		if (lc!=$$2) { a[$$2] = 1; }; \
		lc = $$2; \
		} \
	     END { for (x in a) { printf("%s\t%s\t1\n",x,x); for (y in a) { if (x < y) { printf("%s\t%s\t1\n",x,y) } } }; } ' |\
	sort -k1 -k2 |\
	python $(DIR_SCRIPTS_TOOLS)graph_combine_links_redundant.py |\
	cut -f 1,2,5 |\
	python $(DIR_SCRIPTS_TOOLS)graph_reweight_links.py --self-scores=orthologs_consistent_bygenes.clusters2sizes --method=normalize-max > $@
	$(EPILOG)

%_bygenes.components: %_bygenes.clusters2clusters.links
	$(PRELOG)
	@awk '$$3 >= $(PARAM_STEP1_ORTHOLOGS_MIN_PERCENT_OVERLAP)' < $*_bygenes.clusters2clusters.links |\
		grep -v "#" | cut -f 1,2,5 | ga_components -i -M - > $@_map
	@python $(DIR_SCRIPTS_TOOLS)substitute_tokens.py --apply=$@_map --columns=2 < $*.components.map > $@.map
	@cut -f2 $@.map | python $(DIR_SCRIPTS_TOOLS)data2histogram.py | grep -v "#" > $@.sizes
	@touch $@
	$(EPILOG)

#######################################################################
## 
## rejoin clusters by reciprocal best hit
## (Predictions are first mapped to clusters. The reciprocity refers to clusters.)
##
## 1. Build bi-partite graph of clusters to clusters using besthits graph.
## 2. Sort the results and combine links. Count the number of links in each direction.
## 3. Filter graph and keep links with at least $(PARAM_STEP1_ORTHOLOGS_MIN_BESTHITS) 
##	in each direction
## 4. Cluster graph by components and map old clusters to new clusters.
%_besthits.clusters2clusters.links: %.components
	$(PRELOG)
	@gunzip < $(INPUT_BESTHITS) |\
	python $(DIR_SCRIPTS_TOOLS)substitute_tokens.py --apply=$*.components.map --columns=1,2 |\
	awk '{l=match($$1,"^[0-9]"); r=match($$2,"^[0-9]"); \
		if (!l || !r || ($$1 == $$2) ) { next; }; \
		if ($$1 < $$2) { printf("%s\t%s\t+\n", $$1, $$2); } else { printf("%s\t%s\t-\n", $$2, $$1);}}' |\
	sort -k1,1n -k2,2n -k3,3n -k4,4n |\
	awk 'BEGIN {la=0;lc=0;np=0;nn=0;} \
		{ if (la != $$1 || lc != $$2) { printf("%s\t%s\t%i\t%i\n",la,lc,np,nn); la=$$1;lc=$$2;np=0;nn=0; } \
		  if ($$3 == "+") { np++; } else { nn++;} } \
	     END { printf("%s\t%s\t%i\t%i\n",la,lc,np,nn); }' \
	> $@
	awk '!/^#/ { printf("%s\t%s\t%i\t%i\n", $$1, $$1, $(PARAM_STEP1_ORTHOLOGS_MIN_BESTHITS), $(PARAM_STEP1_ORTHOLOGS_MIN_BESTHITS)); }' \
	< $*.components.sizes >> $@
	$(EPILOG)

%_besthits.components: %_besthits.clusters2clusters.links
	$(PRELOG)
	awk '$$3 >= $(PARAM_STEP1_ORTHOLOGS_MIN_BESTHITS) && $$4 >= $(PARAM_STEP1_ORTHOLOGS_MIN_BESTHITS)' < $*_besthits.clusters2clusters.links | \
	grep -v "#" | cut -f 1,2,5 |\
	ga_components -i -M - > $@_map
	python $(DIR_SCRIPTS_TOOLS)substitute_tokens.py --apply=$@_map --columns=2 < $*.components.map > $@.map
	cut -f2 $@.map | python $(DIR_SCRIPTS_TOOLS)data2histogram.py | grep -v "#" > $@.sizes
	touch $@
	$(CMD_LOG) "finished building $@"
	$(EPILOG)

#######################################################################
## 
## Add orphans to graph by reciprocal besthit criteria. Orphans are added
## to existing clusters, if the members of the cluster are reciprocal best 
## hits to/from the orphan. This is implemented as a filtering step.
##
## 1. Map vertices in besthit graph to clusters. Discard links between two clusters.
##	This graph will contain only edges between orphans and clusters.
## 2. Mark direction of edges in graph
# %_orphans.orphans2clusters: %.components
# 	python $(DIR_SCRIPTS_TOOLS)substitute_tokens.py --apply=$*.components.map --columns=1,2 < ../$(STEP1_INPUT_BESTHITS) |\
# 	awk '{l=match($$1,"^[0-9]"); r=match($$2,"^[0-9]"); \
# 		if ( (l && r) || (!l && !r) ) { next; }; \
# 		if (l) { printf("%s\t%s\t+\n", $$2, $$1); } else { printf("%s\t%s\t-\n", $$1, $$2);}}' |\
# 	sort |\
# 	awk 'BEGIN {la=0;lc=0;np=0;nn=0;} \
# 		{ if (la != $$1 || lc != $$2) { printf("%s\t%s\t%i\t%i\n",la,lc,np,nn); la=$$1;lc=$$2;np=0;nn=0; } \
# 		  if ($$3 == "+") { np++; } else { nn++;} } \
# 	     END { printf("%s\t%s\t%i\t%i\n",la,lc,np,nn); }' \
# 	> $@

# ## take maximum match (only one direction) for deciding which match to take
# ## for dubious cases.
# %_orphans.components: %_orphans.orphans2clusters %.components
# 	cat $*.components.map > $@.map
# 	awk '$$3 >= $(PARAM_STEP1_ORTHOLOGS_MIN_ORPHANS) && $$4 >= $(PARAM_STEP1_ORTHOLOGS_MIN_ORPHANS)' < $*_orphans.orphans2clusters | \
# 	sort -k1,1 -k2,2 -k3,3nr |\
# 	awk 'BEGIN { l=0; } { if ($$1==l) { next; } printf("%s\t%s\n", $$1, $$2); l=$$1; }' >> $@.map
# 	cut -f2 $@.map | python $(DIR_SCRIPTS_TOOLS)data2histogram.py | grep -v "#" > $@.sizes
# 	touch $@
# 	$(CMD_LOG) "finished building $@"
define run_add_orphans
	$(PRELOG);\
	cp $*.components.map $@_0.map;\
	for (( x = 0, y = 1; x < $(PARAM_STEP1_ORTHOLOGS_ORPHANS_MAX_ITERATIONS); ++x, ++y )); do \
		lastcount=`cat $@_$$x.map | wc -l`; \
		$(CMD_LOG2) "# iteration $$x: $$lastcount entries"; \
		cp $@_$$x.map $@_$$y.map; \
		awk '!/^#/ { \
			if ( ($$4 >= $(PARAM_STEP1_ORTHOLOGS_MIN_MIN_COVERAGE)) && \
				($$5 >= $(PARAM_STEP1_ORTHOLOGS_MIN_MAX_COVERAGE)) ) \
			{ print; } }' < $${src_best_hits} |\
		python $(DIR_SCRIPTS_TOOLS)substitute_tokens.py --apply=$@_$$x.map --columns=1,2  |\
		awk '{l=match($$1,"^[0-9]"); r=match($$2,"^[0-9]"); \
			if ( (l && r) || (!l && !r) ) { next; }; \
			if (l) { printf("%s\t%s\t+\n", $$2, $$1); } else { printf("%s\t%s\t-\n", $$1, $$2);}}'|\
		sort |\
		awk 'BEGIN {la=0;lc=0;np=0;nn=0;} \
			{ if (la != $$1 || lc != $$2) { printf("%s\t%s\t%i\t%i\n",la,lc,np,nn); la=$$1;lc=$$2;np=0;nn=0; } \
		  	if ($$3 == "+") { np++; } else { nn++;} } \
	     	END { printf("%s\t%s\t%i\t%i\n",la,lc,np,nn); }' |\
		awk '$$3 >= $(PARAM_STEP1_ORTHOLOGS_MIN_ORPHANS) && $$4 >= $(PARAM_STEP1_ORTHOLOGS_MIN_ORPHANS)' |\
		sort -k1,1 -k3,3nr |\
		awk 'BEGIN { l=0; } { if ($$1==l) { next; } printf("%s\t%s\n", $$1, $$2); l=$$1; }' >> $@_$$y.map; \
		thiscount=`cat $@_$$y.map | wc -l`; \
		if [[ $$thiscount == $$lastcount ]]; then \
			$(CMD_LOG2) "# finishing at iteration $$y because no improvement: $$thiscount entries"; \
			break; \
		fi; \
	done; \
	mv $@_$${y}.map $@.map
	cut -f2 $@.map | python $(DIR_SCRIPTS_TOOLS)data2histogram.py | grep -v "#" > $@.sizes
	touch $@
	$(EPILOG)
endef

%_orphevalue.components: %.components
	src_best_hits=$(PARAM_BESTHITS_EVALUE); $(run_add_orphans)

%_orphpid.components: %.components
	src_best_hits=$(PARAM_BESTHITS_PID); $(run_add_orphans)

%_orphans.components: %.components
	$(PRELOG)
	@cp $*.components.map $@_0.map
	@for (( x = 0, y = 1; x < $(PARAM_STEP1_ORTHOLOGS_ORPHANS_MAX_ITERATIONS); ++x, ++y )); do \
		lastcount=`cat $@_$$x.map | wc -l`; \
		$(CMD_LOG2) "# iteration $$x: $$lastcount entries"; \
		cp $@_$$x.map $@_$$y.map; \
		gunzip < $(INPUT_BESTHITS) |\
		awk '!/^#/  { \
			if ( ($$4 >= $(PARAM_STEP1_ORTHOLOGS_MIN_MIN_COVERAGE)) && \
			  	($$5 >= $(PARAM_STEP1_ORTHOLOGS_MIN_MAX_COVERAGE)) ) \
			{ print; } }' |\
		python $(DIR_SCRIPTS_TOOLS)substitute_tokens.py --apply=$@_$$x.map --columns=1,2  |\
		awk '{l=match($$1,"^[0-9]"); r=match($$2,"^[0-9]"); \
			if ( (l && r) || (!l && !r) ) { next; }; \
			if (l) { printf("%s\t%s\t+\n", $$2, $$1); } else { printf("%s\t%s\t-\n", $$1, $$2);}}'|\
		sort |\
		awk 'BEGIN {la=0;lc=0;np=0;nn=0;} \
			{ if (la != $$1 || lc != $$2) { printf("%s\t%s\t%i\t%i\n",la,lc,np,nn); la=$$1;lc=$$2;np=0;nn=0; } \
		  	if ($$3 == "+") { np++; } else { nn++;} } \
	     	END { printf("%s\t%s\t%i\t%i\n",la,lc,np,nn); }' |\
		awk '$$3 >= $(PARAM_STEP1_ORTHOLOGS_MIN_ORPHANS) && $$4 >= $(PARAM_STEP1_ORTHOLOGS_MIN_ORPHANS)' |\
		sort -k1,1 -k3,3nr |\
		awk 'BEGIN { l=0; } { if ($$1==l) { next; } printf("%s\t%s\n", $$1, $$2); l=$$1; }' >> $@_$$y.map; \
		thiscount=`cat $@_$$y.map | wc -l`; \
		if [[ $$thiscount == $$lastcount ]]; then \
			$(CMD_LOG2) "# finishing at iteration $$y because no improvement: $$thiscount entries"; \
			break; \
		fi; \
	done; \
	mv $@_$$y.map $@.map
	@cut -f2 $@.map | python $(DIR_SCRIPTS_TOOLS)data2histogram.py | grep -v "#" > $@.sizes
	@touch $@
	$(EPILOG)

########################################################################
## a list of all vertices in the input graph and their map to genes
predictions2genes: $(INPUT_ORTHOLOGS)
	$(PRELOG)
	@gunzip < $(INPUT_ORTHOLOGS) |\
	perl $(DIR_SCRIPTS_TOOLS)graph_links2tokens.pl |\
	awk '!/^#/ { split($$1, a, "$(PARAM_SEPARATOR)"); printf("%s\t%s|%s\n", $$1, a[1], a[3]);}' > $@
	$(EPILOG)

##########################################################################
## map of predictions to queries, only best predictions
EXPORT_PREDICTION_ID='$$x' || '|' || prediction_id || '|' || gene_id || '|' || class
best_predictions2queries:
	$(PRELOG)
	@rm -f $@
	@for x in $(PARAM_SRC_SCHEMAS); do \
		psql -h $(PARAM_PSQL_HOST) $(PARAM_PSQL_DATABASE) \
			-c "SELECT $(EXPORT_PREDICTION_ID), query_token \
		FROM $$x.overview WHERE is_best_prediction = True" -t -A -F"	">> $@; \
	done
	$(EPILOG)

## map of predictions to queries, all predictions
all_predictions2queries:
	$(PRELOG)
	@rm -f $@
	@-for x in $(PARAM_SRC_SCHEMAS); do \
		psql -h $(PARAM_PSQL_HOST) $(PARAM_PSQL_DATABASE) \
		"SELECT $(EXPORT_PREDICTION_ID), 'dmel_vs_dmel' || '|' || query_token \
		FROM $$x.predictions" -t -A -F"	">> $@; \
	done
	$(EPILOG)

########################################################################
## building components from a graph. Creates a .map and .sizes file
%.components: %.links.gz
	$(PRELOG)	
	@ga_components -m $@.map -s $@.sizes <(gunzip < $*.links.gz) > $@
	@touch $@
	$(EPILOG)

##########################################################################
##########################################################################
## calculation of statistics
%.orgs_per_cluster: %.components
	$(PRELOG)
	@grep -v "#" $*.components.map |\
	sort -k 2,2n |\
	python $(DIR_SCRIPTS_GENEPREDICTION)optic/count_orgs.py \
	--filename-patterns=$*.patterns \
	--format=map \
	--reference-tree="$(PARAM_SPECIES_TREE)" \
	--organisms=$(GENOMES_COMMA) > $@
	$(EPILOG)

%.orgs_per_cluster.png: %.orgs_per_cluster
	python $(DIR_SCRIPTS_TOOLS)r_table2scatter.py \
	--columns=1,3 \
	--plot=bar \
	--colours=3 \
	--file=<(grep "^[01]" $*.patterns | sort -k3,3 -k2,2n | python ~/t/substitute_tokens.py --apply=map_colours --columns-token=3) \
	--hardcopy=$@

## check: predictions should be in the same cluster as their query.
## get cluster that best prediction of a gene belongs to.
%.stats_missed_queries: %.components best_predictions2queries
	$(PRELOG)
	@rm -f $@_tmp2
	@grep "dmel_vs_dmel" $*.components.map  |\
		perl -p -e "s/\|/\t/g" |\
		cut -f 2,5 > $@_map_querygene2cluster
	@python $(DIR_SCRIPTS_TOOLS)substitute_tokens.py \
		--columns=1 \
		--apply=$*.components.map \
		--echo \
	< best_predictions2queries |\
	python $(DIR_SCRIPTS_TOOLS)substitute_tokens.py \
		--columns=2 \
		--apply=$@_map_querygene2cluster \
		--echo |\
	awk '$$1 ~ /^[0-9]/ && $$2 ~ /^[0-9]/' > $@ 
	@rm -f $@_map_querygene2cluster
	$(EPILOG)

#############################################################################################################
## Create a summary report
CMD_LOGSUMMARY2=echo -e >> $@ "\# `date`:"
CMD_LOGSUMMARY=@$(CMD_LOGSUMMARY2)
TO_LOGSUMMARY=>> $@
LOGSUMMARY_HR1?=@echo "\#==============================================================================================" $(TO_LOGSUMMARY)
LOGSUMMARY_HR2?=@echo "\#----------------------------------------------------------------------------------------------" $(TO_LOGSUMMARY)
LOGSUMMARY_HR2v?=echo "\#----------------------------------------------------------------------------------------------" $(TO_LOGSUMMARY)

%.summary: %.orgs_per_cluster %_genes.components %.components %.stats_missed_queries predictions2genes
	$(PRELOG)
	@rm -f $@
	$(CMD_LOGSUMMARY) "Summary report for $*"
	$(LOGSUMMARY_HR1)
	$(LOGSUMMARY_HR2)
	@echo -e "# Ten largest clusters (counting by transcripts)\nsize\tclusters" $(TO_LOGSUMMARY)
	@cut -f 2 $*.components.sizes | python $(DIR_SCRIPTS_TOOLS)data2histogram.py | grep -v "#" | tail -n 10 $(TO_LOGSUMMARY)
	$(LOGSUMMARY_HR2)
	@echo -e "# Ten largest clusters (counting by genes)\nsize\tclusters" $(TO_LOGSUMMARY)
	@cut -f 2 $*_genes.components.sizes | python $(DIR_SCRIPTS_TOOLS)data2histogram.py | grep -v "#" | tail -n 10 $(TO_LOGSUMMARY)
	$(LOGSUMMARY_HR2)
	@echo -e "# Size distribution (number of sequenes) of clusters" $(TO_LOGSUMMARY)
	@cut -f 2 $*.components.sizes | python $(DIR_SCRIPTS_TOOLS)data2stats.py --flat | grep -v "#" $(TO_LOGSUMMARY)
	$(LOGSUMMARY_HR2)
	@echo -e "# Cluster assignment of templates." $(TO_LOGSUMMARY)
	@echo -e "# Checks, if the template used to predict a gene ends up in the same cluster." $(TO_LOGSUMMARY)
	@echo -e "class\ttotal\tsame\tdiff" $(TO_LOGSUMMARY)
	@echo -e "all\t`cat $*.stats_missed_queries | wc -l`\t`awk '$$1 == $$2' $*.stats_missed_queries | wc -l`\t`awk '$$1 != $$2' $*.stats_missed_queries | wc -l`" $(TO_LOGSUMMARY)
	@echo -e "CG\t`awk '$$3 ~ /CG/' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /CG/ && $$1 == $$2' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /CG/ && $$1 != $$2' $*.stats_missed_queries | wc -l`" $(TO_LOGSUMMARY)
	@echo -e "SG\t`awk '$$3 ~ /SG/' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /SG/ && $$1 == $$2' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /SG/ && $$1 != $$2' $*.stats_missed_queries | wc -l`" $(TO_LOGSUMMARY)
	@echo -e "PG\t`awk '$$3 ~ /PG/' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /PG/ && $$1 == $$2' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /PG/ && $$1 != $$2' $*.stats_missed_queries | wc -l`" $(TO_LOGSUMMARY)
	@echo -e "RG\t`awk '$$3 ~ /RG/' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /RG/ && $$1 == $$2' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /RG/ && $$1 != $$2' $*.stats_missed_queries | wc -l`" $(TO_LOGSUMMARY)
	@echo -e "UG\t`awk '$$3 ~ /UG/' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /UG/ && $$1 == $$2' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /UG/ && $$1 != $$2' $*.stats_missed_queries | wc -l`" $(TO_LOGSUMMARY)
	@echo -e "CP\t`awk '$$3 ~ /CP/' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /CP/ && $$1 == $$2' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /CP/ && $$1 != $$2' $*.stats_missed_queries | wc -l`" $(TO_LOGSUMMARY)
	@echo -e "SP\t`awk '$$3 ~ /SP/' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /SP/ && $$1 == $$2' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /SP/ && $$1 != $$2' $*.stats_missed_queries | wc -l`" $(TO_LOGSUMMARY)
	@echo -e "PP\t`awk '$$3 ~ /PP/' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /PP/ && $$1 == $$2' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /PP/ && $$1 != $$2' $*.stats_missed_queries | wc -l`" $(TO_LOGSUMMARY)
	@echo -e "RP\t`awk '$$3 ~ /RP/' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /RP/ && $$1 == $$2' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /RP/ && $$1 != $$2' $*.stats_missed_queries | wc -l`" $(TO_LOGSUMMARY)
	@echo -e "UP\t`awk '$$3 ~ /UP/' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /UP/ && $$1 == $$2' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /UP/ && $$1 != $$2' $*.stats_missed_queries | wc -l`" $(TO_LOGSUMMARY)
	@echo -e "SF\t`awk '$$3 ~ /SF/' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /SF/ && $$1 == $$2' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /SF/ && $$1 != $$2' $*.stats_missed_queries | wc -l`" $(TO_LOGSUMMARY)
	@echo -e "CF\t`awk '$$3 ~ /CF/' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /CF/ && $$1 == $$2' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /CF/ && $$1 != $$2' $*.stats_missed_queries | wc -l`" $(TO_LOGSUMMARY)
	@echo -e "PF\t`awk '$$3 ~ /PF/' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /PF/ && $$1 == $$2' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /PF/ && $$1 != $$2' $*.stats_missed_queries | wc -l`" $(TO_LOGSUMMARY)
	@echo -e "UF\t`awk '$$3 ~ /UF/' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /UF/ && $$1 == $$2' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /UF/ && $$1 != $$2' $*.stats_missed_queries | wc -l`" $(TO_LOGSUMMARY)
	@echo -e "BF\t`awk '$$3 ~ /BF/' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /BF/ && $$1 == $$2' $*.stats_missed_queries | wc -l`\t`awk '$$3 ~ /BF/ && $$1 != $$2' $*.stats_missed_queries | wc -l`" $(TO_LOGSUMMARY)
	$(LOGSUMMARY_HR2)
	@echo "# Organisms and classes present in clusters" $(TO_LOGSUMMARY)
	@grep -v "#" $*.components.map | cut -f 1 |\
	awk 'BEGIN {FS="$(PARAM_SEPARATOR)"; split("$(PARAM_SRC_SCHEMAS)",aa," "); for(x in aa){orgs[aa[x]]=1;} } \
		{ if ($$1 in orgs) { a[$$1]+=1; b[$$4]+=1;} } \
	     END { \
		printf("taxon"); for (x in a) { printf("\t%s",x) } printf("\ncounts"); for (x in a) { printf("\t%i",a[x]) } printf("\n"); \
		printf("class"); for (x in b) { printf("\t%s",x) } printf("\ncounts"); for (x in b) { printf("\t%i",b[x]) } printf("\n"); \
		}' $(TO_LOGSUMMARY)
	$(LOGSUMMARY_HR2)
	@echo -e "# number of taxa per cluster\ntaxa\tclusters\trfreq\tcafreq\tcfreq" $(TO_LOGSUMMARY)
	@perl $(DIR_SCRIPTS_TOOLS)reghead.pl "^species" 1 < $*.orgs_per_cluster |\
	python $(DIR_SCRIPTS_TOOLS)csv_cut.py -v 0 present |\
	python $(DIR_SCRIPTS_TOOLS)data2histogram.py |\
	python $(DIR_SCRIPTS_TOOLS)histogram2histogram.py |\
	awk '!/^#/ { printf("%i\t%i\t%5.2f\t%i\t%5.2f\n", $$1, $$2, $$3, $$6, $$7 ); }' $(TO_LOGSUMMARY)
	$(LOGSUMMARY_HR2)
	@echo -e "# number of clusters corresponding to phylogeny\nisok\tcounts\tpercent" $(TO_LOGSUMMARY)
	@awk '/^[01]/ { a[$$3] += $$2; t+=$$2; } \
	END { for (x in a) { printf("%s\t%i\t%5.2f\n", x, a[x], a[x]/t); } }' \
	< $*.patterns $(TO_LOGSUMMARY)
	$(LOGSUMMARY_HR2)
	@echo -e "# total number of predictions\n`grep -v "#" $*.components.map | wc -l`" $(TO_LOGSUMMARY)
	@if test -e $*.links.gz; then \
		$(LOGSUMMARY_HR2v); \
		echo -e "# summary of graph" $(TO_LOGSUMMARY); \
		gunzip < $*.links.gz | perl $(DIR_SCRIPTS_TOOLS)graph_howmany.pl | grep -v "#" $(TO_LOGSUMMARY) ; \
	fi
	@if test -e $*.links; then \
		$(LOGSUMMARY_HR2v); \
		echo -e "# summary of graph\nqueries\tsbjcts\tvertices\tlinks" $(TO_LOGSUMMARY); \
		perl $(DIR_SCRIPTS_TOOLS)graph_howmany.pl < $*.links | grep -v "#" $(TO_LOGSUMMARY) ; \
	fi
	$(LOGSUMMARY_HR2)
	@echo -e "# genes of master genome $(PARAM_INPUT_GENOME_MASTER) per cluster" $(TO_LOGSUMMARY)
	@echo -e "number of genes\tnumber of clusters\trfreq" $(TO_LOGSUMMARY)
	@grep "$(PARAM_INPUT_GENOME_MASTER)" $*.components.map |\
	python $(DIR_SCRIPTS_TOOLS)substitute_tokens.py --column=1 --apply=predictions2genes |\
	sort -k2,2n | uniq | uniq -f 1 -c | awk '{printf("%s\n", $$1);}' |\
	python $(DIR_SCRIPTS_TOOLS)data2histogram.py --append=normalize |\
	grep -v "#" $(TO_LOGSUMMARY);
	$(LOGSUMMARY_HR1)
	$(EPILOG)

%.stats: %.summary
	$(PRELOG)
	@cat $*.summary >> $(LOG)
	$(EPILOG)

##############################################################################
##############################################################################
##############################################################################
## Build summary for wiki page
##############################################################################
summary.wiki:
	$(PRELOG)
	@rm -f $@
	@python $(DIR_SCRIPTS_TOOLS)preppy.py \
	$(DIR_SCRIPTS_GENEPREDICTION)orthology_multiple_wiki.prep \
	genomes=$(GENOMES_COMMA) \
	locations=all,local \
	categories=all,functional,pseudo  \
	> $@
	@mv -f summary.wiki $(PARAM_DIR_UPLOAD)
	@rm -f $(PARAM_DIR_UPLOAD)$@.zip
	@if test -e analysis.dir; then \
		cd analysis.dir; zip $(PARAM_DIR_UPLOAD)$@.zip *.png 2>/dev/null; \
	fi
	$(EPILOG)

##############################################################################
##############################################################################
##############################################################################
## build summary over all clusters.
## At the same time, map genes to transcripts and expand to all transcripts.
##############################################################################
summary.components.map: $(ANALSYSIS_RESULTS:%=%.components)
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)combine_tables.py \
		--missing=0 \
		$(ANALYSIS_RESULTS:%=%.components.map) \
	> $@
	$(EPILOG)

summary.components.load: summary.components.map
	$(PRELOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_CLUSTERS_MEMBERS);" > /dev/null
	@grep -v "#" $< |\
	awk 'BEGIN {OFS="\t"; } {split($$1, a, "$(PARAM_SEPARATOR)"); $$1 = a[1] "\t" a[2] "\t" a[3]; print; }' |\
	cut -f 1-4 |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_CLUSTERS_MEMBERS) FROM STDIN WITH NULL AS 'na'" > $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_CLUSTERS_MEMBERS): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_CLUSTERS_MEMBERS);' -t `"  >> $(LOG)
	@touch $@
	$(EPILOG)

##############################################################################
##############################################################################
##############################################################################
## calculate cluster separation using scaled bitscores
##############################################################################
COLUMN_SCORE=3
ANALYSIS_SEPARATION_MAX_LINKS=1000000
analysis.dir/separation_all: ANALYSIS_SEPARATION_FILE=step2.scaled.links.gz
analysis.dir/separation_seed: ANALYSIS_SEPARATION_FILE=step2.seed.links
analysis.dir/separation_all: ANALYSIS_SEPARATION_CMD=gunzip
analysis.dir/separation_seed: ANALYSIS_SEPARATION_CMD=cat

analysis.dir/separation_%:
	$(PRELOG)
	@if [ ! -e $@.dir ]; then \
		mkdir $@.dir; \
		$(CMD_LOG2) "collecting data"; \
	fi
	@if [ ! -e $@.dir/within.log ]; then \
	    $(CMD_LOG2) "calculating histograms for all within clusters"; \
	    (for x in $(PARAM_DIR_SRC)pair*/$(ANALYSIS_SEPARATION_FILE); do \
		$(ANALYSIS_SEPARATION_CMD) < $${x} | head -n $(ANALYSIS_SEPARATION_MAX_LINKS); done) |\
	    python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_clustering.py \
		    --pattern=$@.dir/within_%s.%s \
		    --methods=hists,stats \
		    --map=orthologs.components.map \
		    --columns=$(COLUMN_SCORE) \
		    --add-total \
		    --minbin=0.0 --maxbin=1.0 --binsize=0.01 \
	    > $@.dir/within.log; \
	fi
	@if [ ! -e $@.dir/between.log ]; then \
	    $(CMD_LOG2) "calculating histograms for all between clusters"; \
	    (for x in $(PARAM_DIR_SRC)pair*/$(ANALYSIS_SEPARATION_FILE); do \
		$(ANALYSIS_SEPARATION_CMD) < $${x} | head -n $(ANALYSIS_SEPARATION_MAX_LINKS); done) |\
	    python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_clustering.py \
		    --pattern=$@.dir/between_%s.%s \
		    --methods=hists,stats \
		    --map=orthologs.components.map \
		    --columns=$(COLUMN_SCORE) \
		    --between-clusters \
		    --add-total \
		    --minbin=0.0 \
		    --maxbin=1.0 \
		    --binsize=0.01 \
	    > $@.dir/between.log; \
	fi
	@touch $@
	$(EPILOG)

ANALYSIS_SEPARATION_XRANGE=0,1
analysis.dir/images.separation_seed: ANALYSIS_SEPARATION_XRANGE=0,0.8

analysis.dir/images.separation_%: analysis.dir/separation_%
	python $(DIR_SCRIPTS_TOOLS)combine_histograms.py \
		analysis.dir/separation_$*.dir/within_total.hists \
		analysis.dir/separation_$*.dir/between_total.hists |\
	python $(DIR_SCRIPTS_TOOLS)plot_histogram.py \
		--legend=bin,within,between \
		--normalize \
		--xrange=$(ANALYSIS_SEPARATION_XRANGE) \
		--truncate \
		--hardcopy=analysis.dir/separation_$*.dir/totals.png	

#########################################################################
## follow a certain pattern through the different clustering stages
%.follow-query:
	@for x in orthologs orthologs_consistent orthologs_consistent_genes orthologs_consistent_genes_orphans; do \
		cluster=`grep "$*" < $$x.components.map | cut -f 2`; \
		if [ ! -z "$${cluster}" ]; then \
			echo "# $* in cluster $${cluster} in $$x"; \
			grep "\b$${cluster}$$" < $$x.components.map; \
		else \
			echo "# $* not in $$x"; \
		fi \
	done

#########################################################################
## get all clusters of size xxx in all stages
%.get-sizes:
	@for x in orthologs orthologs_consistent orthologs_consistent_genes orthologs_consistent_genes_orphans; do \
		nclusters=`grep -c "\b$*$$" < $$x.components.sizes | cut -f 1`; \
		echo "# $${nclusters} clusters of size $* in $$x"; \
		for cluster in `grep "\b$*$$" < $$x.components.sizes | cut -f 1;`; do \
			echo "# masters in cluster $${cluster}"; \
			grep "\b$$cluster$$" $$x.components.map |\
			grep $(PARAM_PATTERN_GENOME_MASTER); \
		done; \
	done

#########################################################################
## get largest clusters
%.get-largest-clusters:
	clusters=`sort -k2,2rn $*.components.sizes | head -n 10 | cut -f 1`;\
	for cluster in $${clusters}; do \
		printf "##############################################################################\n"; \
		printf "# cluster %s of size %i\n" $${cluster} `grep -c "\b$$cluster$$" $*.components.map`; \
		printf "# composition\n"; \
		grep "\b$$cluster$$" $*.components.map | cut -f 1 -d "$(PARAM_SEPARATOR)" | sort | uniq -c; \
		grep "\b$$cluster$$" $*.components.map | cut -f 4 -d "$(PARAM_SEPARATOR)" | sort | uniq -c; \
		printf "# masters\n"; \
		grep "\b$$cluster$$" $*.components.map | sort |\
		grep "$(PARAM_PATTERN_GENOME_MASTER)"; \
	done

#########################################################################
## matrix of number of pairwise 1_to_1 relationships
1_to_1.stats:
	find . -name "orthology_gene" -print -exec cat {} \; |\
	grep -e "orthology" -e "1 to 1" |\
	perl -p -e "if (/orthology/) { s/step1_//; s/\-/\t/; s/.\///; s/\/.*\n/\t/ }" |\
	cut -f 1,2,4 |\
	python $(DIR_SCRIPTS_TOOLS)sparse2full.py > $@

##############################################################################
## get statistics for the various steps into the same file
step1.stats.steps:
	$(PRELOG)
	@rm -f $@
	@for x in $(STEP1_STAGES_STATS); do \
		rm -f $$x; \
		$(MAKE) $$x CMD_LOG="@echo >> $@" TOLOG=">> $@"; \
	done
	$(EPILOG)

step1.xstats: step1.stats.steps
	@$(MAKE) stats.dir
	@echo "mean number of taxa per cluster"
	@grep "mean" $< | cut -f 2- | nl -nln
	@echo "number of CG predictions separated from query"
	@grep "^CG" $< | cut -f 2- | nl -nln

##############################################################################
##############################################################################
##############################################################################
##############################################################################
## Get component sizes and members on a gene basis
##############################################################################
%_genes.components: %.components
	$(PRELOG)
	@awk '!/^#/ { split($$1, a, "$(PARAM_SEPARATOR)"); \
	        printf("%s$(PARAM_SEPARATOR)%s\t%s\n", a[1],a[3], $$2); }' \
	< $*.components.map |\
	sort | uniq > $@.map
	@cut -f2 $@.map |\
	python $(DIR_SCRIPTS_TOOLS)data2histogram.py | grep -v "#" > $@.sizes
	@touch $@
	$(EPILOG)

##############################################################################
##############################################################################
##############################################################################
##############################################################################
## Master analysis target
##############################################################################
analysis-hook: analysis.dir \
	analysis.dir/barplot_phylogeny.hist \
	analysis.dir/sizes_transcripts.hist \
	analysis.dir/sizes_genes.hist \

##############################################################################
##############################################################################
##############################################################################
##############################################################################
## get number of clusters 
##    with good phylogeny and complete
##    with good phylogeny, but not complete, 
##    with bad phylogeny
##############################################################################
analysis.dir/barplot_phylogeny.hist:
	$(PRELOG)
	@for x in $(ANALYSIS_RESULTS); do \
		awk -v name=$$x \
		'BEGIN { printf("\t%s\n", name); } \
		/^1+\t/ { a["complete"] += $$2; t+=$$2; next;} \
		/^[01]/ { key = ($$3 == "1") ? "ok" : "failed"; a[key] += $$2; t+=$$2; } \
		END { for (x in a) { printf("%s\t%i\n", x, a[x]); } }' \
		< $$x.patterns > $@.tmp_$$x; \
	done
	@python $(DIR_SCRIPTS_TOOLS)combine_tables.py $@.tmp_* > $@
	@rm -f $@.tmp*
	$(EPILOG)

analysis.dir/barplot_phylogeny.png: analysis.dir/barplot_phylogeny.hist
	$(PRELOG)
	@printf "\tcolours\ncomplete\tgreen\nok\tblue\nfailed\tred\n" > $@.tmp_colours
	@python $(DIR_SCRIPTS_TOOLS)r_table2scatter.py \
		--plot=bar --file=$^ \
		--columns=3,4,5,6 --colours=2 --hardcopy=$@
	@rm -f $@.tmp*
	$(EPILOG)
##############################################################################
##############################################################################
##############################################################################
##############################################################################
## get distribution of cluster size in transcripts/genes
##############################################################################
analysis.dir/sizes_transcripts.hist: ANALYSIS_SIZES_SUFFIX=
analysis.dir/sizes_genes.hist: ANALYSIS_SIZES_SUFFIX=_genes
analysis.dir/sizes_%.hist:
	$(PRELOG)
	@for x in $(ANALYSIS_RESULTS); do \
		printf "bin\t$${x}\n" > $@.tmp_$${x}; \
		python $(DIR_SCRIPTS_TOOLS)data2histogram.py \
		--column=2 \
		< $${x}$(ANALYSIS_SIZES_SUFFIX).components.sizes | grep -v "#" >> $@.tmp_$${x}; \
	done
	@python $(DIR_SCRIPTS_TOOLS)combine_histograms.py \
		$@.tmp_* > $@
	@rm -f $@.tmp_*
	$(EPILOG)

analysis.dir/sizes_%.png: analysis.dir/sizes_%.hist
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)plot_histogram.py \
		--xrange=0,50 \
		--truncate \
		--hardcopy=$@ \
		< analysis.dir/sizes_genes.hist > /dev/null
	$(EPILOG)

##############################################################################
##############################################################################
##############################################################################
##
##############################################################################
analysis.dir/%_queries_per_cluster:
	$(PRELOG)
	@grep "$(PARAM_PATTERN_GENOME_MASTER)" $*.components.map |\
	python $(DIR_SCRIPTS_TOOLS)substitute_tokens.py --column=1 --apply=predictions2genes |\
	sort -k2,2n | uniq | uniq -f 1 -c | awk '{printf("%s\t%s\n", $$3, $$1);}' |\
	sort -k2,2n > $@
	$(EPILOG)

##############################################################################
##############################################################################
##############################################################################
## Cluster info
## cluster, size,  number of queries per cluster, interpro annotation
##############################################################################
analysis.dir/%_cluster_info:
	$(PRELOG)
	@grep "$(PARAM_PATTERN_GENOME_MASTER)" $*.components.map |\
	python $(DIR_SCRIPTS_TOOLS)substitute_tokens.py --column=1 --apply=predictions2genes |\
	sort -k2,2n | uniq | uniq -f 1 -c | awk '{printf("%s\t%s\n", $$3, $$1);}' |\
	sort -k2,2n > $@_tmp1
	@python $(DIR_SCRIPTS_TOOLS)combine_tables.py \
		$*.components.sizes $@_tmp1 |\
	sort -k2,2n > $@
	@rm -f $@_tmp*
	$(EPILOG)


##############################################################################
##############################################################################
##############################################################################
##############################################################################
step1.get_errors:
	rm -f $@
	$(CMD_MSG) "Get predictions which are in different cluster than their query"
	for x in $(STEP1_STAGES_STATS); do \
		echo "#############################################################################" >> $@; \
		echo "# separated CG entries in $${x}:" >> $@; \
		awk '$$3 ~ /CG/ && $$1 != $$2' $${x}_missed_queries |\
		sort -k1,1n -k2,2n |\
		awk 'BEGIN \
			{ printf("cluster1\tcluster2\tnmissed\tmemclus1\tmemclus2\n"); } \
		     { \
			if (a != $$1 || b != $$2) { \
				if(a) { x++;printf("%s\t%s\t%i\t%s\t%s\n",a,b,n,aa,bb); }; n = 0; aa=""; bb=""; \
			} \
		        l = $$0; n+=1; a=$$1; b=$$2; aa = aa $$3 ";"; bb = bb $$4 ";" \
		     }\
		     END \
			{ x++;printf("%s\t%s\t%i\t%s\t%s\n",a,b,n,aa,bb); \
			  printf("# mismatched clusters: %i\n", x);} ' >> $@; \
	done

##############################################################################
## build graphs from ortholgous links
##
## graph with links between orthologous components
orthologs.pairs: $(INPUT_ORTHOLOGS) orthologs.components
	$(PRELOG)
	@gunzip < $(INPUT_ORTHOLOGS) |\
	perl $(DIR_SCRIPTS_TOOLS)graph_split_links_components.pl -n orthologs.components.map |\
	cut -f 1-3 |\
	perl $(DIR_SCRIPTS_TOOLS)graph_sort_links_components.pl -f fasta -s size orthologs.components.map |\
	grep -v "^#" > $@
	$(EPILOG)

## graph with links between orthologous components but only orthologous links
strict_orthologs.pairs: orthologs.pairs
	$(PRELOG)
	@perl $(DIR_SCRIPTS_TOOLS)graph_filter_links_links.pl <(gunzip < $(INPUT_ORTHOLOGS)) < orthologs.pairs > $@
	$(EPILOG)

## graph with links between orthologous components 
orthologs_%.pairs: $(INPUT_ORTHOLOGS) orthologs_%.components
	$(PRELOG)
	@gunzip < $(INPUT_ORTHOLOGS) |\
	perl $(DIR_SCRIPTS_TOOLS)graph_split_links_components.pl -n orthologs_$*.components.map |\
	cut -f 1-3 |\
	perl $(DIR_SCRIPTS_TOOLS)graph_sort_links_components.pl -f fasta -s size orthologs_$*.components.map |\
	grep -v "^#" > $@
	$(EPILOG)

## graph with links between orthologous components but only orthologous links
strict_orthologs_%.pairs: orthologs_%.pairs
	$(PRELOG)
	@perl $(DIR_SCRIPTS_TOOLS)graph_filter_links_links.pl <(gunzip < $(INPUT_ORTHOLOGS)) < orthologs_$*.pairs > $@
	$(EPILOG)

#####################################################################################################
#####################################################################################################
#####################################################################################################
## Table with orthologous groups information
#####################################################################################################
%.create-table-orthogroups:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	schema TEXT, \
	prediction_id TEXT, \
	gene_id TEXT, \
	group_id1 INT);" \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (schema,prediction_id);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index2 ON $* (schema,gene_id);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index3 ON $* (group_id1);" $(TO_NULL) 

#####################################################################################################
clean:
	$(PRELOG)
	rm -f best_predictions2queries
	rm -f *.links.gz* orthologs_consistent_bygenes_orphans.pairs
	rm -f predictions2genes
	$(EPILOG)

distclean: clean
	$(PRELOG)
	rm -f best_predictions2queries
	rm -f orthologs.{orgs_per_cluster,patterns,stats_missed_queries,summary}
	rm -f *.components* *consistent*
	rm -f predictions2genes
	$(EPILOG)


#####################################################################################################
include $(DIR_SCRIPTS_GENEPREDICTION)/makefiles/Makefile.common
