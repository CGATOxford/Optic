################################################################################
#   Gene prediction pipeline 
#
#   $Id: Makefile.analyze_duplications 2781 2009-09-10 11:33:14Z andreas $
#
#   Copyright (C) 2005 Andreas Heger
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License
#   as published by the Free Software Foundation; either version 2
#   of the License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#################################################################################
#################################################################################
#################################################################################
##
## Analyzing multiple alignments for duplications
##
## The input is obtained from a directory of multiple alignments and a file
## of components/sequences to take.
##
##
## The pipeline performs the following steps:
## * calculate pairwise ka and ks
## * build phylogeny incrementally
##   1. bootstrap topolog
##   2. fit ks branch lengths globally on bootstrap topology
##   3. fit ks branch lenghts locally (ks < PARAM_REFINEMENT1_THRESHOLD) without topology changes
##   4. fit ks branch lenghts locally (ks < PARAM_REFINEMENT2_THRESHOLD) with topology changes
## * Analyze trees for duplications and split into subtrees based
##   on out-paralogs or out-groups (if given)
##
## * Build ML trees for each subtrees.
##   * build ML tree for whole subtree
##   * split subtrees into subclusters according to transcript information
##     * build ML tree for each subcluster
##
#################################################################################
##
## The analysis section contains many analysis targets.
##
#################################################################################

################################################
## Section parameters: start
################################################
## Project name
PARAM_PROJECT_NAME?=duplications

################################################
################################################
################################################
## Source information for collecting data for this analysis

## Filename with src information using ks
PARAM_DIR_SRC_MALIS?=../../orthology_malis/

## Pattern to find multiple alignments
PARAM_PATTERN_MALIS?=$(PARAM_DIR_SRC_MALIS)data.dir/cluster_%s.dir/cluster_%s_aligned_na.fasta

## Pattern to find multiple alignments
PARAM_PATTERN_EXONS?=$(PARAM_DIR_SRC_MALIS)data.dir/cluster_%s.dir/cluster_%s.exons

################################################
################################################
################################################
## directories and database schemas
PARAM_SRC_SCHEMAS?=

## Number of genomes
PARAM_NUM_GENOMES?=`echo $(PARAM_SRC_SCHEMAS) | wc -w`

## Pattern for translation
PARAM_PATTERN_TRANSLATION?=s/_vs_dmel\d+//g

PARAM_SRC_NAMES=`echo $(PARAM_SRC_SCHEMAS) | perl -p -e "$(PARAM_PATTERN_TRANSLATION)"`

################################################
PARAM_SEPARATOR?=|

################################################
################################################
################################################
## Parameters for analysing duplications

## Tree with permutations
PARAM_ANALYSIS_DUPLICATIONS_TREE?=/home/andreas/projects/flies/release1v5/documents/species_tree_permutations

## Map of species names to colours
PARAM_ANALYSIS_DUPLICATIONS_COLOURS?=/home/andreas/projects/flies/release1v5/documents/colours

## Map of species names to urls
PARAM_ANALYSIS_DUPLICATIONS_URLS?=/home/andreas/projects/flies/release1v5/documents/species2url

## distance between "syntenic" transcripts
PARAM_ANALYSIS_DUPLICATIONS_MAX_SEPARATION?=1000000

PARAM_ANALYSIS_DUPLICATIONS_OUTGROUPS?=dper_vs_dmel3 dpse_vs_dmel8

################################################
################################################
################################################
## Parameters for tree fitting
################################################

## Method to fit ks values onto bootstrap tree
PARAM_FITTING_TREE_METHOD?=fitch

## Maximum distance in tree. Distances larger than 
## this value are treated as missing.
PARAM_MAX_DISTANCE?=5

## Length threshold for alignments. 0 means no filtering.
PARAM_LENGTH_THRESHOLD?=0

## Distance from tip to node that will include a subtree
## into the refinement stage 1
PARAM_REFINEMENT1_THRESHOLD?=1.5

## Method to use for refinement at step 1
PARAM_REFINEMENT1_METHOD?=fitch

## Distance from tip to node that will include a subtree
## into the refinement stage 2
PARAM_REFINEMENT2_THRESHOLD?=0.1

## Method to use for refinement at step 2
PARAM_REFINEMENT2_METHOD?=fitch

################################################
## Options for Gblocks
## allow up to half the sequence to have gaps
PARAM_GBLOCKS_OPTIONS?=-b5=h

## Accept Gblocks alignments, if at least 50% of positions are kept,
## otherwise keep the original.
PARAM_GBLOCKS_MIN_KEPT?=50

################################################
## Analysis options

## Filtering of multiple alignments to exclude gappy 
## alignments from the analysis

## Minimum character occupancy of rows
PARAM_ANALYSIS_THRESHOLD_MIN_NROWS=100

## Minimum character occupancy of rows in percent
PARAM_ANALYSIS_THRESHOLD_MIN_PROWS=40

################################################
## table with orthologous group information
## summary information on orthologous groups
PARAM_TABLE_NAME_GROUPS?=$(PARAM_PROJECT_NAME).groups
## members of orthologous groups
PARAM_TABLE_NAME_GROUPS_MEMBERS?=$(PARAM_PROJECT_NAME).groups_members
## species order in ortholog groups
PARAM_TABLE_NAME_GROUPS_SPECIES?=$(PARAM_PROJECT_NAME).groups_species
## species order in ortholog groups
PARAM_TABLE_NAME_GROUPS_SUMMARY?=$(PARAM_PROJECT_NAME).groups_summary

################################################
## table with synonym information
PARAM_TABLE_NAME_SYNONYMS?=$(PARAM_PROJECT_NAME).synonyms

################################################
## table with paralog trees
PARAM_TABLE_NAME_PARALOG_TREES?=$(PARAM_PROJECT_NAME).paralog_trees

################################################
## table with strict 1:1 ortholog sets
## table of strict 1:1 ortholog set info
PARAM_TABLE_NAME_ORTHOLOG_SETS?=$(PARAM_PROJECT_NAME).ortholog_sets
## members of strict 1:1 ortholog sets
PARAM_TABLE_NAME_ORTHOLOG_SETS_MEMBERS?=$(PARAM_PROJECT_NAME).ortholog_sets_members
## species order in strict 1:1 ortholog sets
PARAM_TABLE_NAME_ORTHOLOG_SETS_SPECIES?=$(PARAM_PROJECT_NAME).ortholog_sets_species

################################################
# Section parameters: end
################################################

REQUISITES=input.species input.tree input.map

nop:

##################################################################################
prepare: create-log create-tables
	$(PRELOG)
	$(EPILOG)

create-tables: \
		$(PARAM_TABLE_NAME_GROUPS_SUMMARY).create-table-groups-summary \
		$(PARAM_TABLE_NAME_GROUPS_MEMBERS).create-table-groups-members \
		$(PARAM_TABLE_NAME_GROUPS_SPECIES).create-table-groups-species \
		$(PARAM_TABLE_NAME_SYNONYMS).create-table-synonyms \
		$(PARAM_TABLE_NAME_PARALOG_TREES).create-table-paralog-trees \
		$(PARAM_TABLE_NAME_ORTHOLOG_SETS).create-table-ortholog-sets \
		$(PARAM_TABLE_NAME_ORTHOLOG_SETS_MEMBERS).create-table-ortholog-sets-members \
		$(PARAM_TABLE_NAME_ORTHOLOG_SETS_SPECIES).create-table-ortholog-sets-species


summary: summary.dir/groups \
		summary.dir/ortholog_sets 

#######################################################################################
#######################################################################################
#######################################################################################
## Prepare data directory
#######################################################################################
data.prepare: 
	$(PRELOG)
	$(MAKE) data.dir
	$(CMD_LOG) "creating directories and writing malis."
	@python $(DIR_SCRIPTS_TOOLS)malis2malis.py \
		--filename-components=input.map \
		--pattern-mali=$(PARAM_PATTERN_MALIS) \
	       	--pattern-component="^(\S+)" \
		--pattern-output="data.dir/cluster_%s.dir/cluster_%s.fasta" \
		--pattern-filter="^([^|]+)[|]" \
		--filename-filter=input.species \
		--output-format=fasta > $@
	$(CMD_LOG) "adding Makefiles to directories."
	@for d in data.dir/cluster_*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		ln -s ../../Makefile $${d}/Makefile; \
		v="$(PARAM_PATTERN_EXONS)"; \
		ln -f -s ../../$${v//\%s/$${cluster_id}} $${d}/cluster_$${cluster_id}.exons; \
	done
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Progress report
#######################################################################################
data.show-progress:
	@echo "# prediction status at `date`" >> data.progress
	@nkaks=0;nfitted=0;nr1=0;nr2=0;ntree=0;ndupl=0;nhook=0;nfasta=0; \
	for d in data.dir/cluster*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		if test -s $${d}/cluster_$${cluster_id}.fasta; then        let "nfasta=nfasta+1"; fi; \
		if test -s $${d}/cluster_$${cluster_id}.kaks; then         let "nkaks=nkaks+1"; fi; \
		if test -s $${d}/cluster_$${cluster_id}_fitted.tree; then  let "nfitted=nfitted+1"; fi; \
		if test -s $${d}/cluster_$${cluster_id}_r1.tree; then      let "nr1=nr1+1"; fi; \
		if test -s $${d}/cluster_$${cluster_id}_r2.tree; then      let "nr2=nr2+1"; fi; \
		if test -s $${d}/cluster_$${cluster_id}.tree; then         let "ntree=ntree+1"; fi; \
		if test -s $${d}/cluster_$${cluster_id}.duplications; then let "ndupl=ndupl+1"; fi; \
		if test -e $${d}/data.run-subhook; then                    let "nhook=nhook+1"; fi; \
	done; \
	awk -v nfasta="$${nfasta}" -v nkaks=$${nkaks} -v nfitted=$${nfitted} \
	    -v nr1=$${nr1} -v nr2=$${nr2} -v ntree=$${ntree} -v ndupl=$${ndupl} -v nhook=$${nhook} \
	'END {  printf("# N\tNKAKS\tPLEFT\tRSUCC\tNFIT\tPLEFT\tRSUCC\tNTGR\tPLEFT\tRSUCC\tNTTIPS\tPLEFT\tRSUCC\tNTREE\tPLEFT\tRSUCC\tNDUPL\tPLEFT\tRSUCC\tNHOOK\tPLEFT\tRSUCC\n"); \
		printf("%i\t%i\t%5.2f\t%5.2f\t%i\t%5.2f\t%5.2f\t%i\t%5.2f\t%5.2f\t%i\t%5.2f\t%5.2f\t%i\t%5.2f\t%5.2f\t%i\t%5.2f\t%5.2f\t%i\t%5.2f\t%5.2f\n", \
			nfasta,\
			nkaks,((nfasta-nkaks)*100)/nfasta,100*nkaks/nfasta,\
			nfitted,((nfasta-nfitted)*100)/nfasta,100*nfitted/nkaks, \
			nr1,((nfasta-nr1)*100)/nfasta,100*nr1/nfitted, \
			nr2,((nfasta-nr2)*100)/nfasta,100*nr2/nr1, \
			ntree,((nfasta-ntree)*100)/nfasta,100*ntree/nr2, \
			ndupl,((nfasta-ndupl)*100)/nfasta,100*ndupl/ntree, \
			nhook,((nfasta-nhook)*100)/nfasta,100*nhook/ndupl ); }' \
	</dev/null >> data.progress
	@tail data.progress

#######################################################################################
#######################################################################################
#######################################################################################
## Show missing files
#######################################################################################
data.show-missing:
	@printf "cluster\tnseq\tkaks\tnkaks\tfitted\tr1\tr2\ttree\tndup\tnhook\n" > data.missing
	@for d in data.dir/cluster*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		nmissing=0; \
		nsequences=`grep -c ">" $${d}/cluster_$${cluster_id}.fasta`; \
		if test -s $${d}/cluster_$${cluster_id}.kaks; then exists_kaks=1; nkaks=`awk '$$4 <= $(PARAM_MAX_DISTANCE)' < $${d}/cluster_$${cluster_id}.kaks | wc -l`; else exists_kaks=0; nkaks=0; fi; \
		if test -s $${d}/cluster_$${cluster_id}_fitted.tree; then exists_fitted=1; else exists_fitted=0; fi; \
		if test -s $${d}/cluster_$${cluster_id}_r1.tree; then exists_r1=1; else exists_r1=0; fi; \
		if test -s $${d}/cluster_$${cluster_id}_r2.tree; then exists_r2=1; else exists_r2=0; fi; \
		if test -s $${d}/cluster_$${cluster_id}.tree; then exists_tree=1; else exists_tree=0; fi; \
		if test -s $${d}/cluster_$${cluster_id}.duplications; then exists_dupl=1; else exists_dupl=0; fi; \
		if test -e $${d}/data.run-subhook; then exists_hook=1; else exists_hook=0; fi; \
		printf "%s\t%i\t%i\t%i\t%i\t%i\t%i\t%i\t%i\t%i\n" \
			$${cluster_id} $${nsequences} $${exists_kaks} $${nkaks} \
			$${exists_fitted} $${exists_r1} $${exists_r2} $${exists_tree} \
			$${exists_dupl} $${exists_hook}>> data.missing; \
	done

#######################################################################################
#######################################################################################
#######################################################################################
## Remove debris from aborted runs
#######################################################################################
data.remove-unfinished:
	$(PRELOG)
	@nkaks=0;ndup=0;nr1=0;nr2=0;nt=0;nsubtree=0;\
	for d in data.dir/cluster_*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		file=$${d}/cluster_$${cluster_id}.kaks; \
		if test -e $${file} && ! grep -q "# job finished in" $${file}; then \
			$(CMD_MSG2)  "removing $${file};" >> $@.log; \
			rm -f $${file}; \
			rm -f $${d}/cluster_$${cluster_id}.mali; \
			let "nkaks=nkaks+1"; \
		fi; \
		file=$${d}/cluster_$${cluster_id}.duplications; \
		if test -e $${file} && ! grep -q "# job finished in" $${file}; then \
			$(CMD_MSG2)  "removing $${file};" >> $@.log; \
			rm -f $${file}; \
			let "ndup=ndup+1"; \
		fi; \
		file=$${d}/cluster_$${cluster_id}.tree; \
		if [[ -e $${file} && ! -s $${file} ]]; then \
			$(CMD_MSG2) "removing $${file};" >> $@.log; \
			rm -f $${file}; \
			let "nt=nt+1"; \
		fi; \
		file=$${d}/cluster_$${cluster_id}_r1.tree; \
		if [[ -e $${file} && `grep -c -v ">" $${file}` -lt "1" ]]; then \
			$(CMD_MSG2) "removing $${file};" >> $@.log; \
			rm -rf $${file}.dir; \
			rm -f $${file}; \
			let "nr1=nr1+1"; \
		fi; \
		file=$${d}/cluster_$${cluster_id}_r2.tree; \
		if [[ -e $${file} && `grep -c -v ">" $${file}` -lt "1" ]]; then \
			$(CMD_MSG2)  "removing $${file};" >> $@.log; \
			rm -rf $${file}.dir; \
			rm -f $${file}; \
			let "nr2=nr2+1"; \
		fi; \
		dir=$${d}/cluster_$${cluster_id}.subtrees.dir; \
		for s in $${dir}/subtree*.dir/; do \
			subtree_id=$${s#data.dir/cluster_*subtree_}; \
			subtree_id=$${subtree_id%.dir/}; \
			file=$${dir}/subtree_$${subtree_id}.dir/subtree_$${subtree_id}.clusters; \
			if test -e $${file} && ! grep -q "# job finished in" $${file}; then \
				$(CMD_MSG2) "removing $${file};" >> $@.log; \
				rm -f $${file}*; \
				let "nsubtree=nsubtree+1"; \
			fi; \
		done; \
	done; \
	$(CMD_LOG2) "removed $${nkaks} files: *.kaks"; \
	$(CMD_LOG2) "removed $${ndup} files: *.duplications"; \
	$(CMD_LOG2) "removed $${nt} files: *.tree"; \
	$(CMD_LOG2) "removed $${nr1} files: *_r1.tree"; \
	$(CMD_LOG2) "removed $${nr2} files: *_r2.tree"; \
	$(CMD_LOG2) "removed $${nsubtree} files in subtrees"
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Build targets in subdirectories
#######################################################################################
DATA=$(wildcard cluster_[0-9]*.dir)

data.run: data.prepare
	$(PRELOG)
	@$(MAKE) -C data.dir -k -j $(PARAM_NUM_JOBS) $@-hook
	$(EPILOG)

$(DATA):
	@$(MAKE) -C $@ data.run-subhook 

data.run-hook: $(DATA)

data.run-subhook: 
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) $(MAKE) duplications-hook < /dev/null
	@touch $@
	$(EPILOG)

.PHONY: $(DATA)

#######################################################################################
#######################################################################################
#######################################################################################
#######################################################################################
## Targets to execute in subdirectory
##
## If there are only two sequences, skip the tree building step.
##
#######################################################################################

QUERY_SUBDIR=$(wildcard cluster_*.fasta)
ifneq ($(QUERY_SUBDIR),)
NUMSEQ=$(shell grep -c "^>" < $(QUERY_SUBDIR))
else
NUMSEQ=""
endif

ifeq ($(NUMSEQ),2)
TARGET_SUBDIR=$(QUERY_SUBDIR:%.fasta=%.tree) \
		$(QUERY_SUBDIR:%.fasta=%.kaks) \
		$(QUERY_SUBDIR:%.fasta=%.duplications) \
		$(QUERY_SUBDIR:%.fasta=%.subtrees)
else 
TARGET_SUBDIR=$(QUERY_SUBDIR:%.fasta=%_fitted.tree) \
		$(QUERY_SUBDIR:%.fasta=%_r1.tree) \
		$(QUERY_SUBDIR:%.fasta=%_r2.tree) \
		$(QUERY_SUBDIR:%.fasta=%.tree) \
		$(QUERY_SUBDIR:%.fasta=%.duplications) \
		$(QUERY_SUBDIR:%.fasta=%.subtrees)
endif

duplications-hook: $(TARGET_SUBDIR) 

#################################################################################
#################################################################################
#################################################################################
## Mask sequences for composition and incomplete codons and remove fully gapped 
## columns
#################################################################################
%.masked_mali: %.fasta
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)fasta2fasta.py --method=translate -v 0 < $< |\
	python $(DIR_SCRIPTS_TOOLS)fasta2fasta.py --method=mask-seg -v 0	> $@_tmp
	@python $(DIR_SCRIPTS_TOOLS)fasta2fasta.py \
		--method=mask-codons \
		--parameters=$@_tmp \
		--method=mask-incomplete-codons \
		--verbose=0 \
	< $*.fasta |\
	python $(DIR_SCRIPTS_TOOLS)mali2mali.py \
		--method=propagate-masks,remove-all-gaps,remove-empty-sequences \
		--mask-char="n" \
		--verbose=0 \
	> $@
	@rm -f $@_tmp
	$(EPILOG)

#################################################################################
#################################################################################
#################################################################################
## Run Gblocks on mali.
## Note: Gblocks always ends on error code 1, thus ignore it.
## If more than 50% is removed, keep the original alignment
#################################################################################
%.mali: %.masked_mali
	$(PRELOG)
	@rm -f $@.log
	@grep -v "#" $< |\
	perl -p -e "s/ //g" > $@_tmp
	@-Gblocks $@_tmp -t=c $(PARAM_GBLOCKS_OPTIONS) > $@.log
	@nkept=`grep "Gblocks alignment" $@.log | tail -n 1 | perl -p -e "s/.*positions \(//; s/ %\).*//;"`; \
	if [[ $${nkept} -lt "$(PARAM_GBLOCKS_MIN_KEPT)" ]]; then \
		printf "using original alignment\n" >> $@.log; \
		$(CMD_LOG2) "using original alignment"; \
		mv $@_tmp $@; \
	else \
		mv $@_tmp-gb $@; \
	fi; \
	rm -f $@_tmp*
	$(EPILOG)

#################################################################################
#################################################################################
#################################################################################
## Build bootstrap tree
##
## If there are only two sequences, the bootstrap tree is the default tree
##
#################################################################################
%.bootstrap: %.mali
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)gpipe/setup.py -f -m analyze_bootstrap -d $@.dir -p $@ > $@.log
	if test -e $@.dir; then \
		ln -f -s ../$< $@.dir/input.fasta; \
		$(MAKE) -C $@.dir bootstrap; \
	fi
	@touch $@
	$(EPILOG)

#################################################################################
#################################################################################
#################################################################################
## Calculate ka/ks
##
## Do it in pairwise fashion, because due to exon structures not all transcripts
## might overlap, which causes all sites to be removed.
## Note: setting cleandata made no difference?
#################################################################################
%.kaks: %.mali
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)mali2kaks.py \
	--pairwise < $< > $@
	$(EPILOG)

.PRECIOUS: %.kaks %.mali %.masked_mali %.tree %.bootstrap

#################################################################################
#################################################################################
#################################################################################
%.trace: data.run-subhook
	$(PRELOG)
	@awk 'BEGIN {printf("transcript\tinput\n"); } /^>/ { printf("%s\t1\n", substr($$1,2));}' < $*.fasta >  $@.input
	@for x in fitted.tree r1.tree r2.tree; do \
		python $(DIR_SCRIPTS_TOOLS)tree2taxa.py < $*_$${x} |\
		awk -v name=$${x} '/^taxon/ { printf( "taxon\t%s\n", name ); next; } !/^#/ {printf("%s\t1\n", $$1);}' > $@.tmp.$${x}; \
	done
	@find $*.subtrees.dir -name "*_fixed_w_ml.tree" -exec cat {} \; | python $(DIR_SCRIPTS_TOOLS)tree2taxa.py --skip-trees > $@.tmp.subtrees
	@python $(DIR_SCRIPTS_TOOLS)combine_tables.py $@.input $@.tmp.fitted.tree $@.tmp.r1.tree $@.tmp.r2.tree $@.tmp.subtrees
	@rm -f $@.*
	$(EPILOG)
#################################################################################
#################################################################################
#################################################################################
##
## Select a tree for duplication analysis@
##
## * use second stage refined tree for more than two sequences
## * build default tree for two sequences. Set branch lengths to 1 (they will
##   be rescaled in the maximum likelihood calculation in subtrees)
#################################################################################
ifeq ($(NUMSEQ),2)
%.tree: %.mali
	$(PRELOG)
	@printf "(%s:1.0,%s:1.0);\n" `grep ">" $< | sed "s/>//"` > $@
	$(EPILOG)
else
%.tree: %_fitted.tree %_r1.tree %_r2.tree
	$(PRELOG)
	@grep -v ">" $*_r2.tree > $@
	$(EPILOG)
endif

######################################################################
##
## Fit ks values onto boostrap tree
##
## Use subreplicates to deal with missing values
%_fitted.tree: %.kaks %.bootstrap
	$(PRELOG)
	@cut -f 1,2,4 $< |\
		awk '!/^#/ && $$3 <= $(PARAM_MAX_DISTANCE)' |\
	python $(DIR_SCRIPTS_TOOLS)sparse2full.py \
		--output-format=phylip-replicates \
		--default=0\
		--default-diagonal=0 \
		--verbose=0 |\
	python $(DIR_SCRIPTS_TOOLS)matrix2tree.py \
		--method=$(PARAM_FITTING_TREE_METHOD) \
		--replicates \
		--root \
		--verbose=0 \
		--prune-tree \
		--filename-tree=$*.bootstrap.dir/input.bs_partitions.dnd > $@
	@before=`python $(DIR_SCRIPTS_TOOLS)tree2taxa.py < $*.bootstrap.dir/input.bs_partitions.dnd | grep -c -v "^#"`; \
	after=`python $(DIR_SCRIPTS_TOOLS)tree2taxa.py < $@ | grep -c -v "^#"`; \
	$(CMD_LOG2) "after fitting of matrix to tree: $${before} $${after}"; \
	if [ $$before != $$after ]; then \
		$(CMD_LOG2) "fitted tree has lost some species. De-novo calculation from fitch"; \
	    cut -f 1,2,4 $< |\
		    awk '!/^#/ && $$3 <= $(PARAM_MAX_DISTANCE)' |\
	    python $(DIR_SCRIPTS_TOOLS)sparse2full.py \
		    --output-format=phylip-replicates \
		    --default=0\
		    --default-diagonal=0 \
		    --verbose=0 |\
	    python $(DIR_SCRIPTS_TOOLS)matrix2tree.py \
		    --method=$(PARAM_FITTING_TREE_METHOD) \
		    --replicates \
		    --root \
		    --verbose=0 \
		    --prune-tree > $@; \
	    before=`python $(DIR_SCRIPTS_TOOLS)tree2taxa.py < $*.bootstrap.dir/input.bs_partitions.dnd | grep -c -v "^#"`; \
	    after=`python $(DIR_SCRIPTS_TOOLS)tree2taxa.py < $@ | grep -c -v "^#"`; \
	    $(CMD_LOG2) "after de-novo calculation of tree with $(PARAM_FITTING_TREE_METHOD): $${before} $${after}";  \
	fi
	$(EPILOG)

.PRECIOUS: %_fitted.tree

#########################################################################
##
## First refinement step:
##
## Refine tree under constant topology.
##
%_r1.tree: %.kaks %_fitted.tree
	$(PRELOG)
	@rm -rf $@.dir
	@$(MAKE) $@.dir; \
	cat <(echo ">test") \
	$*_fitted.tree \
	<(cut -f 1,2,4 $< | awk '!/^#/ && $$3 <= $(PARAM_MAX_DISTANCE)') |\
	tree_extract_sub_trees_with_matrix \
		--unchanged_tree_file   $@.dir/$*.nh.unchanged \
		--err_log               $@.dir/r1_subtrees.errors \
		--tree_files_path       $@.dir/$*.orig_sub_tree \
		--sub_matrix_files_path $@.dir/$*.r1_sub_matrix \
		--description "$*.r1_subtrees" \
		--branch_length_limit $(PARAM_REFINEMENT1_THRESHOLD) \
		--input_format p \
		--output_format p \
	> $@.dir/$*.r1_subtrees; \
	if test -e $@.dir; then \
		if test -s $@.dir/$*.r1_subtrees; then \
			$(MAKE) -C $@.dir $@-hook; \
			cd $@.dir; \
			find . -name "*.r1_subtree" -exec cat {} \; |\
			tree_rejoin_subbranches \
				--output_path "../$@_tmp" \
				--err_log rejoin.errors \
				> rejoined.log; \
			cd ..; \
			if test -s $@_tmp; then \
				echo ">cluster# $* size= 0" > $@; \
	 	   		grep -v -e ">" -e "SUB" $@_tmp >> $@; \
			fi; \
			rm -f $@_tmp; \
	     	else \
			echo ">cluster# $* size= 0" > $@; \
			grep -v ">" $@.dir/$*.nh.unchanged >> $@; \
	     	fi; \
	fi

	$(EPILOG)

SUBTREE_QUERIES_R1=$(wildcard *.r1_sub_matrix)
SUBTREE_TARGETS_R1=$(SUBTREE_QUERIES_R1:%.r1_sub_matrix=%.r1_subtree)

%.r1_subtree: %.r1_sub_matrix
	$(CMD_LOG) "refining subtree $* started."
	@numseq=`perl $(DIR_SCRIPTS_TOOLS)graph_howmany.pl < $< | python $(DIR_SCRIPTS_TOOLS)csv_cut.py -v 0 vertices | grep -v "vertices"`; \
	num_edges=`perl $(DIR_SCRIPTS_TOOLS)graph_howmany.pl < $< | python $(DIR_SCRIPTS_TOOLS)csv_cut.py -v 0 edges | grep -v "edges"`; \
	if [ "$${num_edges}" -le "1" ]; then \
		$(CMD_LOG2) "subtree $*: no data to compute tree. Original subtree is taken."; \
		cp $*.orig_sub_tree $@; \
	else \
	    if [ "$${numseq}" -le "3" ]; then \
		    tree_kitsch \
		    --input_format p \
		    --iterations 30 \
		    --header \
		    --err_log $@.errors \
		    < $< |\
		    python $(DIR_SCRIPTS_TOOLS)tree2tree.py \
			    --method=midpoint-root \
			    --verbose=0 > $@; \
	    else \
		    cat $< |\
		    python $(DIR_SCRIPTS_TOOLS)sparse2full.py \
			    --output-format=phylip-replicates \
			    --default=0\
			    --default-diagonal=0 \
			    --verbose=0 |\
		    python $(DIR_SCRIPTS_TOOLS)matrix2tree.py \
			    --verbose=0 \
			    --method=$(PARAM_REFINEMENT1_METHOD) \
			    --replicates \
			    --prune-tree \
			    --add-random \
			    --root \
			    --filename-tree=$*.orig_sub_tree \
		    > $@; \
	    fi; \
	fi
	$(CMD_LOG) "refining subtree $* finished."

%_r1.tree-hook: $(SUBTREE_TARGETS_R1)
	$(EPILOG)


.PRECIOUS: %.r1_subtree %_r1.tree

#########################################################################
##
## Second refinement step:
##
## Refine tree under variable topology
##
%_r2.tree: %.kaks %_r1.tree
	$(PRELOG)
	@rm -rf $@.dir
	@$(MAKE) $@.dir; \
	cat <(echo ">test") \
	$*_r1.tree \
	<(cut -f 1,2,4 $< | awk '!/^#/ && $$3 <= $(PARAM_MAX_DISTANCE)') |\
	tree_extract_sub_trees_with_matrix \
		--unchanged_tree_file   $@.dir/$*.nh.unchanged \
		--err_log               $@.dir/r2_subtrees.errors \
		--tree_files_path       $@.dir/$*.orig_sub_tree \
		--sub_matrix_files_path $@.dir/$*.r2_sub_matrix \
		--description "$*.r2_subtrees" \
		--branch_length_limit $(PARAM_REFINEMENT2_THRESHOLD) \
		--input_format p \
		--output_format p \
	> $@.dir/$*.r2_subtrees; \
	if test -e $@.dir; then \
		if test -s $@.dir/$*.r2_subtrees; then \
			$(MAKE) -C $@.dir $@-hook; \
			cd $@.dir; \
			find . -name "*.r2_subtree" -exec cat {} \; |\
			tree_rejoin_subbranches \
				--output_path "../$@_tmp" \
				--err_log rejoin.errors \
				> rejoined.log; \
			cd ..; \
			if test -s $@_tmp; then \
				echo ">cluster# $* size= 0" > $@; \
	 	   		grep -v ">" $@_tmp >> $@; \
			fi; \
			rm -f $@_tmp; \
	     	else \
			echo ">cluster# $* size= 0" > $@; \
			grep -v ">" $@.dir/$*.nh.unchanged >> $@; \
	     	fi; \
	fi
	$(EPILOG)

SUBTREE_QUERIES_R2=$(wildcard *.r2_sub_matrix)
SUBTREE_TARGETS_R2=$(SUBTREE_QUERIES_R2:%.r2_sub_matrix=%.r2_subtree)

%.r2_subtree: %.r2_sub_matrix
	$(CMD_LOG) "refining subtree $* started."
	@num_vertices=`perl $(DIR_SCRIPTS_TOOLS)graph_howmany.pl < $< | python $(DIR_SCRIPTS_TOOLS)csv_cut.py -v 0 vertices | grep -v "vertices"`; \
	num_edges=`awk '$$3 > 0' < $< | perl $(DIR_SCRIPTS_TOOLS)graph_howmany.pl | python $(DIR_SCRIPTS_TOOLS)csv_cut.py -v 0 edges | grep -v "edges"`; \
	if [ "$${num_edges}" -le "1" ]; then \
		$(CMD_LOG2) "subtree $*: no data to compute tree. Original subtree is taken."; \
		cp $*.orig_sub_tree $@; \
	else if [ "$${num_vertices}" -le "3" ]; then \
		tree_kitsch \
		--input_format p \
		--iterations 30 \
		--header \
		--err_log $@.errors \
		< $< |\
		python $(DIR_SCRIPTS_TOOLS)tree2tree.py \
			--method=midpoint-root \
			--verbose=0 > $@; \
	else \
		cat $< |\
		python $(DIR_SCRIPTS_TOOLS)sparse2full.py \
			--output-format=phylip-replicates \
			--default=0\
			--default-diagonal=0 \
			--verbose=0 |\
		python $(DIR_SCRIPTS_TOOLS)matrix2tree.py \
			--verbose=0 \
			--method=$(PARAM_REFINEMENT2_METHOD) \
			--replicates \
			--add-random \
			--root \
		> $@; \
	fi; fi
	$(CMD_LOG) "refining subtree $* finished."

%_r2.tree-hook: $(SUBTREE_TARGETS_R2)
	$(EPILOG)


.PRECIOUS: %.r2_subtree %_r2.tree

#######################################################################################
#######################################################################################
#######################################################################################
## Analyze duplications
#######################################################################################

###########################################################################
###########################################################################
###########################################################################
## Analysis of duplications
%.map_id2pos: %.exons
	$(PRELOG)
	@cat $^ |\
	awk '{ chr=$$2; id=$$1; printf("%s\t%s\t%s\t%i\t%i\n", id, chr, $$3, $$8, $$9); }'  |\
	sort -k1,1 -k2,2 -k3,3n -k4,4n -k5,5|awk '{ if ($$1 != id) \
	     { if (id) { printf("%s\t%s\t%s\t%i\t%i\n", id, chr, strand, min, max)}; id = $$1; chr=$$2; strand=$$3; min=$$4;} max=$$5 } \
	     END { printf("%s\t%s\t%s\t%i\t%i\n", id, chr, strand, min, max); }' > $@
	$(EPILOG)

clean-duplications:
	$(PRELOG)
	@rm -f cluster*.duplications*
	$(EPILOG)

###########################################################################
## SVG image of duplications
## Optionally use different kinds of tree
ifneq ($(PARAM_ANALYSIS_DUPLICATIONS_OUTGROUPS), "")
DUPLICATIONS_EXTRA_OPTIONS=--outgroup-species=`echo "$(PARAM_ANALYSIS_DUPLICATIONS_OUTGROUPS)" | perl -p -e "s/ +/,/g"`
endif

%.duplications: %.tree %.map_id2pos
	$(PRELOG)
	@grep -v -e "^#" -e "^>" $< |\
	python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_orthology_multiple.py \
		--filename-species-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		--filename-species2colour=$(PARAM_ANALYSIS_DUPLICATIONS_COLOURS) \
		--filename-species2url=$(PARAM_ANALYSIS_DUPLICATIONS_URLS) \
		--filename-locations=$*.map_id2pos \
		--max-separation=$(PARAM_ANALYSIS_DUPLICATIONS_MAX_SEPARATION) \
		$(DUPLICATIONS_EXTRA_OPTIONS) \
		--output-pattern=$@_%s \
		--output-pattern-svg=$@.svg \
		--prefix=$* \
		--subtrees-trees \
		--subtrees-identifiers \
		--print-svg --print-subtotals --print-best \
	> $@
	$(EPILOG)

.PRECIOUS: %.duplications

###########################################################################
###########################################################################
###########################################################################
## Analyze subtrees
SUBTREES=$(wildcard subtree_cluster_[0-9]*.dir)

%.subtrees: %.subtrees.prepare
	$(PRELOG)
	@if test -e $@.dir; then \
		$(MAKE) -k -C $@.dir subtrees.run-hook; \
	fi
	$(EPILOG)

$(SUBTREES):
	$(PRELOG)
	@$(MAKE) -k -C $@ subtree
	$(EPILOG)

subtrees.run-hook: $(SUBTREES)

.PHONY: $(SUBTREES)

###########################################################################
###########################################################################
###########################################################################
## Split subtrees into individual directories
##	Information I need is malis and trees.
##      Set optimization threshold according to the number of sequences in the
##	file.
##      
###########################################################################
clean-subtrees:
	$(PRELOG)
	@rm -rf cluster*.subtrees*
	$(EPILOG)

###########################################################################
## If there are more than 30 sequences, speed up calculation:
##    * terminate optimization quicker at threshold
##    * choose other optimization method
##    * do not compute variable_w
PARAM_SUBTREES_THRESHOLD_OPTIMIZATION_NSEQUENCES?=30
PARAM_SUBTREES_THRESHOLD_OPTIMIZATION?=.5e-4
%.subtrees.prepare: %.duplications %.fasta 
	$(PRELOG)
	@rm -rf $*.subtrees.dir
	@python $(DIR_SCRIPTS_GENEPREDICTION)split_fasta.py \
	--map=$<_subids \
	--output-pattern="$*.subtrees.dir/subtree_%s.dir/subtree_%s.fasta" \
	< $*.fasta >> $@
	@python $(DIR_SCRIPTS_GENEPREDICTION)split_fasta.py \
	--skip-identifiers \
	--output-pattern="$*.subtrees.dir/subtree_%s.dir/subtree_%s.tree" \
	< $<_subtrees >> $@
	@ln -f -s ../Makefile $*.subtrees.dir
	@for dir in $*.subtrees.dir/*.dir; do \
		ln -f -s ../Makefile $${dir}/Makefile; \
	done
	$(EPILOG)

%.subtrees.finish: %.map_id2pos
	$(PRELOG)
	@find $*.subtrees.dir -name "subtree_$*_*_fixed_w_ml.tree" -exec cat {} \; |\
	python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_orthology_multiple.py \
		--filename-species-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		--filename-species2colour=$(PARAM_ANALYSIS_DUPLICATIONS_COLOURS) \
		--filename-species2url=$(PARAM_ANALYSIS_DUPLICATIONS_URLS) \
		--filename-locations=$*.map_id2pos \
		--max-separation=$(PARAM_ANALYSIS_DUPLICATIONS_MAX_SEPARATION) \
		$(DUPLICATIONS_EXTRA_OPTIONS) \
		--output-pattern=$*.subtrees.dir/%s.result \
		--output-pattern-svg=$*.subtrees.dir/%s.svg \
		--prefix=$* \
		--print-svg \
		--print-totals \
		--svg-print-location \
	> $@
	$(EPILOG)

.PRECIOUS: %.subtrees.prepare %.subtrees.finish

###########################################################################
###########################################################################
###########################################################################
## Estimate ks tree for each multiple alignment using PAML and the
## topology estimated previously.
## Here is the logic for running jobs in parallel
###########################################################################
subtree: subtree.prepare subtree.run subtree.finish

## Split according to transcripts
SUBTREE_PREPARE_QUERIES=$(wildcard subtree*.fasta)
SUBTREE_PREPARE_TARGETS=$(SUBTREE_PREPARE_QUERIES:%.fasta=%.clusters) \
			$(SUBTREE_PREPARE_QUERIES:%.fasta=%.split) \
			$(SUBTREE_PREPARE_QUERIES:%.fasta=%.split_clean)

subtree.prepare: $(SUBTREE_PREPARE_TARGETS)
	$(PREPARE)
	@touch $@
	$(EPILOG)

SUBTREE_RUN_QUERIES=$(wildcard *.fasta)
SUBTREE_RUN_TARGETS?= \
		$(SUBTREE_RUN_QUERIES:%.fasta=%.masked_mali) \
		$(SUBTREE_RUN_QUERIES:%.fasta=%.mali) \
		$(SUBTREE_RUN_QUERIES:%.fasta=%.phylip) \
		$(SUBTREE_RUN_QUERIES:%.fasta=%_fixed_w.paml) \
		$(SUBTREE_RUN_QUERIES:%.fasta=%_fixed_w_ml.tree) 

# Disabled variable rate test
# ifneq ($(wildcard subtree_*_variable_w.ctl),)
# SUBTREE_RUN_TARGETS+= $(SUBTREE_RUN_QUERIES:%.fasta=%_variable_w.paml) \
# 		$(SUBTREE_RUN_QUERIES:%.fasta=%_variable_w_ml.tree) \
# 		$(SUBTREE_RUN_QUERIES:%.fasta=%.lrt) 
# endif

subtree.run: subtree.prepare
	$(PRELOG)
	@$(MAKE) subtree.run-hook
	@touch $@
	$(EPILOG)

subtree.run-hook: $(SUBTREE_RUN_TARGETS)

subtree.finish: subtree.run 
	$(PREPARE)
	@touch $@
	$(EPILOG)

.PHONY: subtree.run-hook

###########################################################################
###########################################################################
###########################################################################
## Process the multiple alignments
## * remove alternative transcripts
###########################################################################
%.overlap: %.fasta
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)mali_rates.py \
		--distance=POVL \
	< $< > $@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
## Build clusters according to transcript components.
###########################################################################
%.clusters: %.overlap
	$(PRELOG)
	@awk '!/^#/ && !/^id1/ { printf("%s\t%s\t%f\n", $$1, $$2, 100.0 - $$3); }' < $< |\
	python $(DIR_SCRIPTS_TOOLS)graph_cluster_by_species.py \
		--max-weight=99.999 \
		--mode=genes \
		--filename-synonyms=$@.synonyms \
		--filename-summary=$@.summary > $@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
## Split input multiple alignment, but only if it contains multiple
## transcript components. 
###########################################################################
%.split: %.fasta %.clusters
	$(PRELOG)
	@rm -f subcluster_$*_*
	@ncomponents=`grep "^# ncomponents=" $*.clusters | perl -p -e "s/# ncomponents=//; s/,.*//"`; \
	if [ "$${ncomponents}" -gt "1" ]; then \
		python $(DIR_SCRIPTS_GENEPREDICTION)split_fasta.py \
		--map=<(grep -v "^id" < $*.clusters) \
		--min-size=2 \
		--output-pattern=subcluster_$*_%s.fasta \
		< $< > $@; \
		for x in subcluster_$*_*.fasta; do \
			python $(DIR_SCRIPTS_TOOLS)mali2mali.py \
				--method=remove-all-gaps \
				--verbose=0 \
			< $${x} > $@_tmp; \
			mv $@_tmp $${x}; \
		done; \
		$(CMD_LOG2) "splitting $*.fasta into $${ncomponents} components."; \
	else \
		$(CMD_LOG2) "not splitting $*.fasta, because only one component."; \
	fi
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
## check fasta files and delete those which are non-mappable
###########################################################################
%.split_clean: %.split
	$(PRELOG)
	@for file in *.fasta; do \
		python $(DIR_SCRIPTS_TOOLS)mali2mali.py \
			--method=remove-unaligned-pairs,remove-all-gaps \
			--verbose=0 < $${file} > $@.tmp; \
		if [ `grep -c ">" $@.tmp` -lt "2" ]; then \
			$(CMD_LOG2) "after cleaning less than 2 sequences remain in $${file} - removed"; \
			rm -f $${file}; \
		fi; \
	done
	@rm -f $@.tmp
	@touch $@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
## Prepare data for input
## 1. Convert mali to phylip format and perform the following operations on it:
##    Remove unaligned sequences
##    Rename identifiers in mali and tree to short identifiers
##    Remove alternative transcripts
##    Unroot tree
%.phylip: %.mali
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)mali2mali.py \
		--method=remove-unaligned-pairs,remove-all-gaps \
		--verbose=0 \
	< $< |\
	python $(DIR_SCRIPTS_TOOLS)fasta2fasta.py \
		    --method=build-map \
		    --parameters=$*.map_old2new |\
	python $(DIR_SCRIPTS_TOOLS)mali2mali.py \
		--input-format=fasta \
		--output-format=phylip \
		--verbose=0 > $@; \
	python $(DIR_SCRIPTS_TOOLS)tree2tree.py \
		--method=rename,unroot \
		--parameters=$*.map_old2new \
		--verbose=0 \
	< subtree_cluster_[0-9]*_tree[0-9]_[0-9].tree > $*_mapped.tree
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
%_fixed_w.ctl: %.fasta
	$(PRELOG)
	@nsequences=`grep -c ">" < $*.fasta`; \
	if [ "$${nsequences}" -gt "$(PARAM_SUBTREES_THRESHOLD_OPTIMIZATION_NSEQUENCES)" ]; then \
		$(CMD_LOG2) "reduced sensitivity for alignment $${cluster_id} with $${nsequences} members."; \
		extra_options="--set-optimization-threshold=$(PARAM_SUBTREES_THRESHOLD_OPTIMIZATION) --set-method=1"; \
	fi; \
	python $(DIR_SCRIPTS_GENEPREDICTION)WrapperCodeML.py \
		--filename-output=../$*_fixed_w.output \
		--filename-sequences=../$*.phylip \
		--filename-tree=../$*_mapped.tree \
		--write-control-file \
		$${extra_options} \
		--analysis=branch-fixed-kaks |\
	grep -v "#" > $@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
%_fixed_w.paml: %_fixed_w.ctl %.phylip
	$(PRELOG)
	@mkdir -p $@.dir
	@cd $@.dir >& /dev/null; codeml ../$< < /dev/null > ../$@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
%_variable_w.paml: %_variable_w.ctl %.phylip
	$(PRELOG)
	@mkdir -p $@.dir
	@cd $@.dir >& /dev/null; codeml ../$< < /dev/null > ../$@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
%_fixed_w_ml.tree: %_fixed_w.paml 
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)codeml2tsv.py \
		--prefix=$*_fixed_w \
		--method=write-ks-tree \
		$*_fixed_w.output |\
	python $(DIR_SCRIPTS_TOOLS)tree2tree.py \
		--method=rename,midpoint-root \
		--parameters=$*.map_old2new \
		--invert \
		--verbose=0 > $@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
subtree_%.lrt: subtree_%_fixed_w.paml subtree_%_variable_w.paml
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)codeml2tsv.py \
		--prefix=subtree_$* \
		--method=lrt \
		subtree_$*_fixed_w.output subtree_$*_variable_w.output > $@
	$(EPILOG)

.PRECIOUS: subtree_%.paml subtree_%.phylip subtree_%_ml.tree subtree_%.lrt %_fixed_w.ctl %.clusters %.overlap

#######################################################################################
#######################################################################################
#######################################################################################
#######################################################################################
## Primary targets for complete statistics
#######################################################################################
TARGET_STATS=$(QUERY_SUBDIR:%.fasta=%.stats)
OUTPUT_FILES=$(PARAM_OMEGA_VALUES:%=$*_%.output)

stats: $(TARGET_STATS)

%.stats: %.counts
	$(EPILOG)

%.counts:
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)codemls2tsv.py \
		--filter-probability=$(PARAM_FILTER_SITES_PROBABILITY) \
		--filter-omega=$(PARAM_FILTER_SITES_OMEGA) \
		--models=`echo $(PARAM_FILTER_MODELS) | perl -p -e "chop; s/\s+/,/g"` \
		--analysis=`echo $(PARAM_FILTER_METHOD) | perl -p -e "chop; s/\s+/,/g"` \
		--method=summary-numbers \
		--significance-threshold=$(PARAM_SIGNIFICANCE_THRESHOLD) \
		--prefix=$* \
		$(OUTPUT_FILES) > $@
	$(EPILOG)

.PRECIOUS: %.counts

#######################################################################################
#######################################################################################
#######################################################################################
## collect exon information
#######################################################################################
all.exons:
	@for dir in data.dir/cluster*.dir; do \
		cluster_id=$${dir#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		cat $${dir}/cluster_$${cluster_id}.exons >> $@; \
	done

#######################################################################################
#######################################################################################
#######################################################################################
## build a list of filtered malis
#######################################################################################
malis.filtered: malis.summary
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)csv_cut.py prefix nrow_mean prow_mean < $< |\
	awk '!/^#/ && \
	     $$2 >= $(PARAM_ANALYSIS_THRESHOLD_MIN_NROWS) && \
	     $$3 >= $(PARAM_ANALYSIS_THRESHOLD_MIN_PROWS) { \
	     printf("cluster_%s\n", $$0); }' > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## tree information
#######################################################################################
CMD_ANALYSIS_SUBTREES=if test ! -e $@.dir/filtered; then \
		python $(DIR_SCRIPTS_TOOLS)tree2tree.py \
			--filter=max-branch-length \
			--parameters=$(PARAM_MAX_DISTANCE) \
		< $@.dir/data > $@.dir/filtered; \
	fi; \
	$(MAKE) -j $(PARAM_NUM_JOBS) -C $@.dir -k subtrees-summary-hook

analysis.dir/subtrees_fitch.summary:
	$(PRELOG)
	@$(MAKE) $@.dir
	@if test ! -e $@.dir/data; then \
		for dir in data.dir/cluster*.dir; do \
			cluster_id=$${dir#data.dir/cluster_}; \
			cluster_id=$${cluster_id%.dir}; \
			if test -e $${dir}/cluster_$${cluster_id}.tree; then \
				echo ">cluster_$${cluster_id}" >> $@.dir/data; \
				cat $${dir}/cluster_$${cluster_id}.tree >> $@.dir/data; \
			fi; \
		done; \
	fi
	@$(CMD_ANALYSIS_SUBTREES)
	$(EPILOG)

analysis.dir/subtrees_ml.summary:
	$(PRELOG)
	@$(MAKE) $@.dir
	@if test ! -e $@.dir/data; then \
		find data.dir -name "subtree_*_fixed_w_ml.tree" -exec cat {} \; > $@.dir/data; \
	fi
	@$(CMD_ANALYSIS_SUBTREES)
	$(EPILOG)

analysis.dir/subtrees_subclusters.summary:
	$(PRELOG)
	@$(MAKE) $@.dir
	@if test ! -e $@.dir/data_all; then \
		for dir in data.dir/cluster*.dir; do \
			cluster_id=$${dir#data.dir/cluster_}; \
			cluster_id=$${cluster_id%.dir}; \
			if test -e $${dir}/cluster_$${cluster_id}.subtrees.dir; then \
			    for s in $${dir}/cluster_$${cluster_id}.subtrees.dir/subtree*.dir; do \
				    subtree_id=$${s#data.dir/cluster_*subtree_}; \
				    subtree_id=$${subtree_id%.dir}; \
				    subdir=$${dir}/cluster_$${cluster_id}.subtrees.dir/subtree_$${subtree_id}.dir; \
				    file=$${subdir}/subtree_$${subtree_id}.split; \
				    if test -e $${file}; then \
					    cat $${subdir}/subcluster_subtree_$${subtree_id}_*_fixed_w_ml.tree >> $@.dir/data_all; \
				    else \
					    cat $${subdir}/subtree_$${subtree_id}_fixed_w_ml.tree >> $@.dir/data_all ; \
				    fi; \
			    done; \
			fi; \
		done; \
	fi
	@if test ! -e $@.dir/data; then \
		python $(DIR_SCRIPTS_TOOLS)trees2tree.py \
			--method=select-largest --regex-id="(cluster_\d+_tree0_\d+)" \
		< $@.dir/data_all > $@.dir/data; \
	fi
	$(EPILOG)

analysis.dir/subtrees_input.summary:
	$(PRELOG)
	@$(MAKE) $@.dir
	@if test ! -e $@.dir/data; then \
		find data.dir -name "subtree_*[0-9].tree" -print -exec cat {} \; |\
		awk 'NR % 2 { sub(/.*\/subtree_/, "", $$0); gsub(/\.tree/, "", $$0); printf(">%s\n", $$0); next} \
		{ print; }' > $@.dir/data; \
	fi
	@$(CMD_ANALYSIS_SUBTREES)
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Targets for subtree analysis
#######################################################################################
ANALYSIS_SUBSECTIONS_SUBTREES=all filtered_all filtered_genes filtered_pseudos

subtrees-summary-hook: trees.stats trees.recall \
		count_orgs orthologs.gz pairwise_inparalogs.gz full_inparalogs.gz \
			$(ANALYSIS_SUBSECTIONS_SUBTREES:%=trees_%.summary) \
			$(ANALYSIS_SUBSECTIONS_SUBTREES:%=duplications_%.summary)

#######################################################################################
#######################################################################################
#######################################################################################
## Get counts of trees for tree statistics
#######################################################################################
subtrees-counts-trees:
	@grep "noutput=" analysis.dir/subtrees*.summary.dir/tree*.summary |\
	perl -p -e "s/analysis.dir\/subtrees_*//; s/\.summary.dir\//\t/; s/.summary/\t/; s/:#//; s/,/\t/g; " |\
	awk 'NR == 1 \
		{ t[1]="section1"; t[2]="section2";  \
		for (x = 3; x <= NF; ++x) { split($$x, a, "="); t[x] = a[1]; } \
		printf("%s", t[1]); for (x = 2; x <= NF; ++x) { printf ("\t%s", t[x]); } printf("\n"); } \
	     	{ v[1] = $$1; v[2] = $$2; \
		for (x = 3; x <= NF; ++x) { split($$x, a, "="); v[x] = a[2] } \
		printf("%s", v[1]); for (x = 2; x <= NF; ++x) { printf ("\t%s", v[x]); } printf("\n"); }' 

#######################################################################################
#######################################################################################
#######################################################################################
## Get counts of trees analized for duplications
#######################################################################################
subtrees-counts-duplications:
	@grep "noutput=" analysis.dir/subtrees*.summary.dir/duplications*.summary |\
	perl -p -e "s/analysis.dir\/subtrees_*//; s/\.summary.dir\//\t/; s/.summary/\t/; s/:#//; s/,/\t/g; " |\
	awk 'NR == 1 \
		{ t[1]="section1"; t[2]="section2";  \
		for (x = 3; x <= NF; ++x) { split($$x, a, "="); t[x] = a[1]; } \
		printf("%s", t[1]); for (x = 2; x <= NF; ++x) { printf ("\t%s", t[x]); } printf("\n"); } \
	     	{ v[1] = $$1; v[2] = $$2; \
		for (x = 3; x <= NF; ++x) { split($$x, a, "="); v[x] = a[2] } \
		printf("%s", v[1]); for (x = 2; x <= NF; ++x) { printf ("\t%s", v[x]); } printf("\n"); }' 

#######################################################################################
#######################################################################################
#######################################################################################
## Examine date of duplications
#######################################################################################

# filter for a subset of malis, if malis.filtered is given.
ifeq ($(wildcard ../../malis.filtered),)
DUPLICATIONS_FILTER_MALIS=
else
DUPLICATIONS_FILTER_MALIS=--filename-filter-positives=../../malis.filtered
endif

CMD_ANALYSIS_DUPLICATIONS=cat filtered |\
	$(CMD_REMOTE_SUBMIT) \
	python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_orthology_multiple.py \
		--filename-species-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		$(DUPLICATIONS_EXTRA_OPTIONS) \
		--output-pattern=$@.dir/%s.data \
		--filename-locations=../../all.map_id2pos \
		$(DUPLICATIONS_FILTER_MALIS) \
		--filename-species-list=../../input.species \
		--print-totals \
		--print-species-svg \
		--print-summaries \
		--output-pattern-svg="$@.dir/%s.svg" \
		--svg-branch-lengths="uniform" \
		--svg-otus=`xargs < ../../input.species | perl -p -e "s/\s+/,/g"` 

duplications_all.summary:
	$(PRELOG)
	@$(MAKE) $@.dir
	@$(CMD_ANALYSIS_DUPLICATIONS) > $@
	$(EPILOG)

duplications_filtered_all.summary:
	$(PRELOG)
	@$(MAKE) $@.dir
	@$(CMD_ANALYSIS_DUPLICATIONS) \
		--remove-unplaced --filter-quality="all" > $@
	$(EPILOG)

duplications_filtered_genes.summary:
	$(PRELOG)
	@$(MAKE) $@.dir
	@$(CMD_ANALYSIS_DUPLICATIONS) \
		--remove-unplaced --filter-quality="genes" > $@
	$(EPILOG)

duplications_filtered_pseudos.summary:
	$(PRELOG)
	@$(MAKE) $@.dir
	@$(CMD_ANALYSIS_DUPLICATIONS) \
		--remove-unplaced --filter-quality="pseudogenes" > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Statistics for trees
#######################################################################################
trees.stats: data
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)tree2stats.py --method=branchlengths \
	< $< > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Compare input to output and find out how many genes/transcripts have been dropped
## due to aborted computations
#######################################################################################
trees.recall: data
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)tree2taxa.py --skip-trees < $< > $@.taxa
	@python $(DIR_SCRIPTS_GENEPREDICTION)diff_transcript_sets.py \
		--add-percent \
		--dump-sets=rest_genes2 \
		--output-pattern="trees.recall.%s" \
		$@.taxa ../../input.map > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
count_orgs: data
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) \
	python $(DIR_SCRIPTS_GENEPREDICTION)optic/count_orgs.py \
		--reference-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		--format=trees \
		--filename-patterns=$@.patterns \
		--filename-summary=$@.summary \
	< $< > $@
	$(EPILOG)

orthologs.gz: data
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) \
	python $(DIR_SCRIPTS_TOOLS)trees2sets.py \
		--reference-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		--filename-summary=$@.summary \
		--enumeration=exhaustive \
		--method=strict \
		< $< | gzip > $@
	$(EPILOG)

pairwise_inparalogs.gz: data
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) \
	python $(DIR_SCRIPTS_TOOLS)trees2sets.py \
		--reference-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		--filename-summary=$@.summary \
		--enumeration=pairwise \
		--method=degenerate \
		< $< | gzip > $@
	$(EPILOG)

full_inparalogs.gz: data
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) \
	python $(DIR_SCRIPTS_TOOLS)trees2sets.py \
		--reference-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		--filename-summary=$@.summary \
		--enumeration=full \
		--method=outgroup \
		--outgroups=$(PARAM_ANALYSIS_DUPLICATIONS_OUTGROUPS) \
		< $< | gzip > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Examine branch length of trees
#######################################################################################
CMD_ANALYSIS_TREES=cat filtered |\
	$(CMD_REMOTE_SUBMIT) \
	python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_genetrees.py \
		--filename-species-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		$(DUPLICATIONS_EXTRA_OPTIONS) \
		--output-pattern=$@.dir/%s.data \
		--filename-locations=../../all.map_id2pos \
		$(DUPLICATIONS_FILTER_MALIS) \
		--print-totals \
		--print-subtotals \
		--skip-without-outgroups 

trees_all.summary:
	$(PRELOG)
	@$(MAKE) $@.dir
	@$(CMD_ANALYSIS_TREES) > $@
	$(EPILOG)

trees_filtered.summary:
	$(PRELOG)
	@$(MAKE) $@.dir
	@$(CMD_ANALYSIS_TREES) \
		--remove-unplaced > $@
	$(EPILOG)

trees_filtered_all.summary:
	$(PRELOG)
	@$(MAKE) $@.dir
	@$(CMD_ANALYSIS_TREES) \
		--remove-unplaced --filter-quality="all" > $@
	$(EPILOG)

trees_filtered_genes.summary:
	$(PRELOG)
	@$(MAKE) $@.dir
	@$(CMD_ANALYSIS_TREES) \
		--remove-unplaced --filter-quality="genes" > $@
	$(EPILOG)

trees_filtered_pseudos.summary:
	$(PRELOG)
	@$(MAKE) $@.dir
	@$(CMD_ANALYSIS_TREES) \
		--remove-unplaced --filter-quality="pseudogenes" > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Collect results from analysis for plots
#######################################################################################
ANALYSIS_SUBGROUPS1?=subtrees_fitch subtrees_ml subtrees_input
ANALYSIS_SUBGROUPS2?=all filtered_all filtered_genes filtered_pseudos

#######################################################################################
#######################################################################################
#######################################################################################
## collect mean and stddev of distance of species to root averaged over all trees
## use heights/relheights as target modifiers
#######################################################################################
analysis.dir/species_%.stats:
	$(PRELOG)
	@for s1 in $(ANALYSIS_SUBGROUPS1); do \
		for s2 in $(ANALYSIS_SUBGROUPS2); do \
			printf "species\t%s\t%s\n" $${s1}_$${s2} stderr > $@_tmp_$${s1}_$${s2}; \
			grep -e "total" -e "prefix" \
				analysis.dir/$${s1}.summary.dir/trees_$${s2}.summary.dir/species_$*.data |\
			$(YT)csv_cut.py species mean stddev -v 0 |\
			grep -v "species" >> $@_tmp_$${s1}_$${s2}; \
		done; \
	done
	@$(YT)combine_tables.py -v 0 $@_tmp_* |\
	$(CMD_TRANSLATE) > $@
	@rm -f $@_tmp_*;
	$(EPILOG)

analysis.dir/species_%_relheights.hist:
	$(PRELOG)
	@grep -e "total" -e "prefix" \
		analysis.dir/subtrees_ml.summary.dir/trees_$*.summary.dir/species_relheights.data |\
		$(YT)csv_cut.py prefix species heights -v 0 > $@_tmp_total;
	@for genome in $(PARAM_SRC_SCHEMAS); do \
		printf "bin\t%s\n" $${genome} > $@_tmp_$${genome}; \
		grep -e "$${genome}" -e "prefix" < $@_tmp_total |\
		$(YT)csv_cut.py heights |\
		perl -p -e "s/,/\n/g" |\
		$(YT)data2histogram.py \
			--min-value=0.0 \
			--bin-size=0.01 \
			--normalize \
			--cumulative \
			--verbose=0 |\
		grep -v "bin" >> $@_tmp_$${genome}; \
	done
	@rm -f $@_tmp_total
	@$(YT)combine_histograms.py \
		--missing="-" \
	$@_tmp_* |\
	$(CMD_TRANSLATE) > $@
	@rm -f $@_tmp_*;
	$(EPILOG)


analysis.dir/species_%_heights.hist:
	$(PRELOG)
	@grep -e "total" -e "prefix" \
		analysis.dir/subtrees_ml.summary.dir/trees_$*.summary.dir/species_heights.data |\
		$(YT)csv_cut.py prefix species heights -v 0 > $@_tmp_total;
	@for genome in $(PARAM_SRC_SCHEMAS); do \
		printf "bin\t%s\n" $${genome} > $@_tmp_$${genome}; \
		grep -e "$${genome}" -e "prefix" < $@_tmp_total |\
		$(YT)csv_cut.py heights |\
		perl -p -e "s/,/\n/g" |\
		$(YT)data2histogram.py \
			--min-value=0.0 \
			--bin-size=0.01 \
			--normalize \
			--cumulative \
			--verbose=0 |\
		grep -v "bin" >> $@_tmp_$${genome}; \
	done
	@rm -f $@_tmp_total
	@$(YT)combine_histograms.py \
		--missing="-" \
	$@_tmp_* |\
	$(CMD_TRANSLATE) > $@
	@rm -f $@_tmp_*;
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## compute histograms of heights of trees (longest distance of leaf to root)
## use heights/relheights as target modifiers
#######################################################################################
analysis.dir/tree_heights.hists: ANALYSIS_TREE_HISTS_BIN_SIZE=0.1
analysis.dir/tree_relheights.hists: ANALYSIS_TREE_HISTS_BIN_SIZE=0.02
analysis.dir/tree_%.hists:
	$(PRELOG)
	@for category in min max mean stddev; do \
	    for s1 in $(ANALYSIS_SUBGROUPS1); do \
		    for s2 in $(ANALYSIS_SUBGROUPS2); do \
			    printf "bin\t%s\n" $${s1}_$${s2} > $@_tmp_$${category}_$${s1}_$${s2}; \
			    grep -v "total" analysis.dir/$${s1}.summary.dir/trees_$${s2}.summary.dir/tree_$*.data |\
			    $(YT)csv_cut.py $${category} -v 0 |\
			    $(YT)data2histogram.py \
				--min-value=0.0 \
				--bin-size=$(ANALYSIS_TREE_HISTS_BIN_SIZE) \
				--no-empty-bins |\
			    grep -v "bin" >> $@_tmp_$${category}_$${s1}_$${s2}; \
		    done; \
	    done; \
	    $(YT)combine_histograms.py -v 0 $@_tmp_* |\
	    $(CMD_TRANSLATE) > $@_$${category}; \
	    rm -f $@_tmp_*; \
	done
	$(EPILOG)


analysis.dir/tree_%.stats:
	$(PRELOG)
	@printf "section\tcategory\t" > $@
	@$(YT)data2stats.py --write-header -v 0  >> $@
	@for category in min max mean stddev; do \
		for s1 in $(ANALYSIS_SUBGROUPS1); do \
		    for s2 in $(ANALYSIS_SUBGROUPS2); do \
			    printf "%s_%s\t" $${s1} $${s2} >> $@; \
			    grep -v "total" analysis.dir/$${s1}.summary.dir/trees_$${s2}.summary.dir/tree_$*.data |\
			    $(YT)csv_cut.py $${category} -v 0 |\
			    $(YT)data2stats.py --skip-header -v 0 --flat --format="%6.4f" --flat >> $@; \
		    done; \
	    done; \
	done
	$(EPILOG)

###################################################################
subtrees.plot:
	$(PRELOG)
	@find data.dir -name "subtree_*_fixed_w_ml.tree" -exec cat {} \; |\
	python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_orthology_multiple.py \
		--filename-species-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		$(DUPLICATIONS_EXTRA_OPTIONS) \
		--output-pattern=$@_%s \
		--print-totals \
		--print-species-svg \
		--output-pattern-svg="test_%s.svg" \
		--svg-branch-lengths="uniform" \
		--filename-node-types=subtrees.summary_nodes \
	> $@
	$(EPILOG)

malis.summary:
	$(PRELOG)
	@cut -f 2 input.map | sort | uniq | grep "^[0-9]" |\
	python $(DIR_SCRIPTS_TOOLS)mali2summary.py \
		--pattern-mali=data.dir/cluster_%s.dir/cluster_%s.masked_mali > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Summary targets
#######################################################################################

#######################################################################################
#######################################################################################
#######################################################################################
##
## Assignments of genes and transcripts to orthologous groups
## There are three levels of groups. From general to more specific:
## 1. cluster grouped by pairwise orthology -> cluster_id
## 2. cluster based on splitting trees      -> subcluster_id
## 3. transcript sets                       -> transcluster_id
##
## cluster_ids and subcluster_ids are summarized into a new list of consecutive ids called "group_id"
## The first step (tree2taxa) assigns these number to the tree.
## 
## Also computes summary information.
#######################################################################################
summary.dir/groups:
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)tree2taxa.py < analysis.dir/subtrees_ml.summary.dir/data |\
	awk 'BEGIN { printf("group_id\tschema\tprediction\tgene\tclass\tcluster_id\tsubcluster_id\ttranscluster_id\n"); } \
		/^taxon/ {next;} \
		!/^#/ { split($$3, a, "_"); cluster_id = a[3]; subcluster_id = a[5]; \
		  split($$1, a, "$(PARAM_SEPARATOR)");  schema=a[1]; prediction_id=a[2]; gene_id=a[3]; class=a[4]; \
		  printf("%i\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", $$2, schema, prediction_id, gene_id, class, cluster_id, subcluster_id, "1"); }' \
	> $@.members 
	@python $(DIR_SCRIPTS_TOOLS)csv_cut.py --verbose=0 cluster_id subcluster_id group_id < $@.members |\
	awk '{printf("%s-%s\t%s\n", $$1, $$2, $$3);}' |\
	$(DIR_SCRIPTS_TOOLS)hsort | uniq > $@.map 
	@cat analysis.dir/subtrees_ml.summary.dir/count_orgs |\
		awk 'BEGIN { OFS="\t"; } \
			/^mali/ { $$1="cluster_id-subcluster_id"; \
			nspecies=(NF-5)/2; \
			for (x = 5; x < 5 + nspecies; ++x) { $$x = "ngenes_" $$x; }; \
			for (x = 6+nspecies; x <= NF; ++x) { $$x = "ntranscripts_" $$x; }; \
			print; \
			next; } \
			!/^#/ { split($$1, a, "_"); group_id = a[3]; subgroup_id = a[5]; \
				$$1=group_id "-" subgroup_id; print; next; }' |\
	python $(DIR_SCRIPTS_TOOLS)substitute_tokens.py --echo --apply=$@.map --column=1 --verbose=0 |\
	perl -p -e "s/-/\t/" > $@
	@cp analysis.dir/subtrees_ml.summary.dir/count_orgs.summary $@.counts
	@grep -v "#" analysis.dir/subtrees_ml.summary.dir/count_orgs.patterns > $@.summary
	@awk 'BEGIN {printf("species_id\tschema\n"); } \
		/#/ {printf("%i\t%s\n", $$2+1, $$4)}' < analysis.dir/subtrees_ml.summary.dir/count_orgs.patterns > $@.species
	$(EPILOG)

## obsolete: there are some discrepancies between entries in the .clusters file and
## those ending up in the trees. The code above is quicker and consistent with the
## summary stats, but does not include the transcript set info.
summary.dir/full_groups:
	@printf "schema\tprediction\tgene\tclass\tgroup_id\tsubgroup_id\ttransgroup_id\n" > $@.members
	@for dir in data.dir/cluster*.dir; do\
		cluster_id=$${dir#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		if test -e $${dir}/cluster_$${cluster_id}.subtrees.dir; then \
		    for subdir in $${dir}/cluster_$${cluster_id}.subtrees.dir/subtree*.dir; do \
			    subcluster_id=`echo $${subdir} | sed "s/.*_tree0_//; s/.dir//"`; \
			    awk -v cluster=$${cluster_id} \
				-v subcluster=$${subcluster_id}\
				    '!/^#/ && !/^id/ {split($$1,a,"$(PARAM_SEPARATOR)"); \
				    printf("%s\t%s\t%s\t%s\t%i\t%i\t%i\n",\
					    a[1],a[2],a[3],a[4], \
					    cluster,subcluster,$$2)}' \
			    < $${subdir}/subtree_cluster_$${cluster_id}_tree0_$${subcluster_id}.clusters >> $@.members; \
		    done; \
		else \
			printf "error: $${dir}/cluster_$${cluster_id}.subtrees.dir does not exist\n" >> $@.err; \
		fi; \
	done 	
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Load groups into table
#######################################################################################
summary.dir/groups.load: summary.dir/groups
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)csv2psql.py --lowercase --table=$(PARAM_TABLE_NAME_GROUPS) --map="pattern:string" \
		< $< > $@
	@echo "loaded into $(PARAM_TABLE_NAME_GROUPS): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_GROUPS);' -t `" >> $(LOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_GROUPS_MEMBERS);" > /dev/null
	@grep -v -e "^#" -e "^group_id" $<.members |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_GROUPS_MEMBERS) FROM STDIN WITH NULL AS 'na'" >> $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_GROUPS_MEMBERS): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_GROUPS_MEMBERS);' -t `" >> $(LOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_GROUPS_SPECIES);" > /dev/null
	@grep -v -e "^#" -e "^species_id" $<.species |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_GROUPS_SPECIES) FROM STDIN WITH NULL AS 'na'" >> $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_GROUPS_SPECIES): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_GROUPS_SPECIES);' -t `"  >> $(LOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_GROUPS_SUMMARY);" > /dev/null
	@grep -v -e "^#" -e "^pattern" $<.summary |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_GROUPS_SUMMARY) FROM STDIN WITH NULL AS 'na'" >> $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_GROUPS_SUMMARY): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_GROUPS_SUMMARY);' -t `"  >> $(LOG)
	$(EPILOG)

#####################################################################################################
#####################################################################################################
#####################################################################################################
## Tables with orthologous groups information
#####################################################################################################
## Note: the table groups is reated once summary.dir/groups is computed.

%.create-table-groups-summary:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	pattern TEXT, \
	ngroups INT, \
	isok BOOL );" \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index3 ON $* (pattern);" $(TO_NULL) 

%.create-table-groups-members:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	group_id INT, \
	schema TEXT, \
	prediction_id TEXT, \
	gene_id TEXT, \
	class TEXT, \
	cluster_id INT, \
	subcluster_id INT, \
	transcluster_id INT); " \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (schema,prediction_id);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index2 ON $* (schema,gene_id);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index3 ON $* (group_id);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index4 ON $* (cluster_id,subcluster_id);" $(TO_NULL) 

%.create-table-groups-species:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	species_id INT, \
	schema TEXT ); " \
	$(TO_NULL)

#######################################################################################
#######################################################################################
#######################################################################################
## Synonym information
#######################################################################################
summary.dir/synonyms:
	$(PRELOG)
	@printf "schema\trep_prediction_id\trep_gene_id\trep_class\tmem_prediction_id\tmem_gene_id\tmem_class\n" > $@
	@for dir in data.dir/cluster*.dir; do\
		cluster_id=$${dir#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		if test -e $${dir}/cluster_$${cluster_id}.subtrees.dir; then \
		    for subdir in $${dir}/cluster_$${cluster_id}.subtrees.dir/subtree*.dir; do \
			    subcluster_id=`echo $${subdir} | sed "s/.*_tree0_//; s/.dir//"`; \
			    f=$${subdir}/subtree_cluster_$${cluster_id}_tree0_$${subcluster_id}.clusters.synonyms; \
		            if test -e $${f}; then \
				awk '!/^rep/ {split($$1,rep,"$(PARAM_SEPARATOR)"); split($$1,mem,"$(PARAM_SEPARATOR)"); \
				printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\n", rep[1],rep[2],rep[3],rep[4],mem[2],mem[3],mem[4]);}' \
			    	< $${f} >> $@; \
			    fi; \
		    done; \
		else \
			printf "error: $${dir}/cluster_$${cluster_id}.subtrees.dir does not exist\n" >> $@.err; \
		fi; \
	done 	

#######################################################################################
#######################################################################################
#######################################################################################
## Load synonyms into table
#######################################################################################
summary.dir/synonyms.load: summary.dir/synonyms
	$(PRELOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_SYNONYMS);" > /dev/null
	@grep -v -e "^#" -e "^schema" $< |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_SYNONYMS) FROM STDIN WITH NULL AS 'na'" > $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_SYNONYMS): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_SYNONYMS);' -t `"  >> $(LOG)
	@touch $@
	$(EPILOG)


%.create-table-synonyms:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	schema TEXT, \
	rep_prediction_id TEXT, \
	rep_gene_id TEXT, \
	rep_class TEXT, \
	mem_prediction_id TEXT, \
	mem_gene_id TEXT, \
	mem_class TEXT);" \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (schema,rep_prediction_id);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index2 ON $* (schema,mem_prediction_id);" $(TO_NULL) 

#######################################################################################
#######################################################################################
#######################################################################################
## Create table for paralog trees
#######################################################################################
%.create-table-paralog-trees:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	group_id INT, \
	nh TEXT, \
	svg TEXT );" \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (group_id);" $(TO_NULL) 

#######################################################################################
#######################################################################################
#######################################################################################
## Build paralog trees
#######################################################################################
summary.dir/paralog_trees:
	$(PRELOG)
	@for d in data.dir/cluster_*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		file=$${d}/cluster_$${cluster_id}.tree; \
		file_exons=$${d}/cluster_$${cluster_id}.exons; \
		if test -s $${file}; then \
			cat $${file_exons} |\
			awk '{ chr=$$2; id=$$1; printf("%s\t%s\t%s\t%i\t%i\n", id, chr, $$3, $$8, $$9); }'  |\
			sort -k1,1 -k2,2 -k3,3n -k4,4n -k5,5|awk '{ if ($$1 != id) \
				{ if (id) { printf("%s\t%s\t%s\t%i\t%i\n", id, chr, strand, min, max)}; id = $$1; chr=$$2; strand=$$3; min=$$4;} max=$$5 } \
				END { printf("%s\t%s\t%s\t%i\t%i\n", id, chr, strand, min, max); }' > $@.tmp_loc; \
			printf "%s\t" $${cluster_id} >> $@; \
			perl -p -e "s/[\t\n]/ /g" < $${file} >> $@; \
			printf "\t" >> $@; \
			python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_orthology_multiple.py \
				--filename-species-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
				--filename-species2colour=$(PARAM_ANALYSIS_DUPLICATIONS_COLOURS) \
				--filename-species2url=$(PARAM_ANALYSIS_DUPLICATIONS_URLS) \
				--filename-species2name=$(PARAM_ANALYSIS_DUPLICATIONS_TRANSLATION) \
				--filename-locations=$@.tmp_loc \
				--max-separation=$(PARAM_ANALYSIS_DUPLICATIONS_MAX_SEPARATION) \
				$(DUPLICATIONS_EXTRA_OPTIONS) \
				--svg-no-legend \
				--verbose=0 \
				--print-svg < $${file} |\
			perl -p -e "s/[\t\n]/ /g" >> $@; \
			printf "\n" >> $@; \
			rm -f $@.tmp_loc; \
		else \
			printf "# file %s missing\n" $${file} >> $@.err; \
		fi; \
	done
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Load paralog trees into table.
#######################################################################################
summary.dir/paralog_trees.load: summary.dir/paralog_trees
	$(PRELOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_PARALOG_TREES);" > /dev/null
	@$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_PARALOG_TREES) FROM STDIN WITH NULL AS 'na'" < $< > $@ 
	@$(PSQL_CONNECTION) "ANALYSE $(PARAM_TABLE_NAME_PARALOG_TREES)" >> $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_PARALOG_TREES): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_PARALOG_TREES);' -t `"  >> $(LOG)
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Table definition of strict 1:1 orthologous groups
#######################################################################################
%.create-table-ortholog-sets:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	set_id INT, \
	cluster_id INT, \
	subcluster_id INT, \
	nspecies INT, \
	pattern TEXT \
	); " \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (cluster_id);" $(TO_NULL) 

%.create-table-ortholog-sets-members:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	set_id INT, \
	schema TEXT, \
	prediction_id TEXT, \
	gene_id TEXT, \
	class TEXT ); " \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (set_id);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index2 ON $* (schema,gene_id);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index3 ON $* (schema,prediction_id);" $(TO_NULL) 

%.create-table-ortholog-sets-species:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	species_id INT, \
	schema TEXT ); " \
	$(TO_NULL)

#######################################################################################
#######################################################################################
#######################################################################################
## Collect data for strict 1:1 orthologous groups
#######################################################################################
summary.dir/ortholog_sets: analysis.dir/subtrees_ml.summary.dir/orthologs.gz
	$(PRELOG)
	@gunzip < $< |\
	python $(DIR_SCRIPTS_TOOLS)csv_cut.py cluster name nspecies pattern members |\
	awk '/^#/ { next; } \
	     /^cluster/ { printf("%s\t%s\t%s\t%s\t%s\n", "set_id", "cluster_id", "subcluster_id", $$3, $$4); \
		printf("set_id\tschema\tprediction_id\tgene_id\tclass\n") > "$@.members"; next; } \
		{ split($$2,c,"_"); cluster_id=c[3]; subcluster_id = c[5]; \
		  printf("%i\t%i\t%i\t%i\t%s\n", $$1, cluster_id, subcluster_id, $$3, $$4); \
		  split($$5, a, ";"); \
		  for (x in a) { split(a[x], b, "$(PARAM_SEPARATOR)"); printf("%s\t%s\t%s\t%s\t%s\n", $$1, b[1], b[2], b[3], b[4] ) >> "$@.members" ; }\
		}' \
	> $@
	@gunzip < $< |\
	awk 'BEGIN { printf("species_id\tschema\n"); } \
		/^nspecies/ { i=0; for (x=6;x<6+NF-7;++x) {printf("%i\t%s\n",++i,$$x)};exit}'  \
	> $@.species
	@gzip $@.members
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Load data for strict 1:1 orthologous groups
#######################################################################################
summary.dir/ortholog_sets.load: summary.dir/ortholog_sets
	$(PRELOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_ORTHOLOG_SETS);" > /dev/null
	@grep -v -e "^#" -e "^set_id" $< |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_ORTHOLOG_SETS) FROM STDIN WITH NULL AS 'na'" > $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_ORTHOLOG_SETS): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_ORTHOLOG_SETS);' -t `"  >> $(LOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_ORTHOLOG_SETS_MEMBERS);" > /dev/null
	@gunzip < $<.members.gz |\
	grep -v -e "^#" -e "^set_id" |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_ORTHOLOG_SETS_MEMBERS) FROM STDIN WITH NULL AS 'na'" > $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_ORTHOLOG_SETS_MEMBERS): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_ORTHOLOG_SETS_MEMBERS);' -t `"  >> $(LOG)
	@touch $@
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_ORTHOLOG_SETS_SPECIES);" > /dev/null
	@grep -v -e "^#" -e "^species_id" $<.species |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_ORTHOLOG_SETS_SPECIES) FROM STDIN WITH NULL AS 'na'" > $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_ORTHOLOG_SETS_SPECIES): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_ORTHOLOG_SETS_SPECIES);' -t `"  >> $(LOG)
	@touch $@
	$(EPILOG)

clean:
	rm -rf *.output *.ctl *.dir *.log *.map *.phylip *.tree

#######################################################################################
include $(DIR_SCRIPTS_GENEPREDICTION)/makefiles/Makefile.common

