################################################################################
#   Gene prediction pipeline 
#
#   $Id: Makefile.orthology_pairwise_analysis 2781 2009-09-10 11:33:14Z andreas $
#
#   Copyright (C) 2004 Andreas Heger
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License
#   as published by the Free Software Foundation; either version 2
#   of the License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#################################################################################
## Multiple pairwise orthology prediction

################################################
## Section parameters: start
################################################
## project name
PARAM_PROJECT_NAME?=geneprediction
################################################
## directories
PARAM_DIR_UPLOAD?=/home/andreas/uploads/

#########################################################################
## pattern for genome and peptide files. If there is a single file, set to filename
PARAM_PATTERN_GENOME_FILES?=genome_%s.fasta
PARAM_INPUT_PEPTIDES?=peptides.fasta
PARAM_INPUT_GENOMES?=$(wildcard genome*.fasta)
PARAM_INPUT_EXONS?=reference.exons

################################################
## Database connection parameters
PARAM_PSQL_SCHEMA?=$(PARAM_PROJECT_NAME)

## table with pairwise ortholog assignments
PARAM_TABLE_NAME_ORTHOLOGLINKS?=$(PARAM_PSQL_SCHEMA).orthologlinks
## table with distances: transcripts
PARAM_TABLE_NAME_DISTANCES?=$(PARAM_PSQL_SCHEMA).distances
## table with distances: genes
PARAM_TABLE_NAME_DISTANCES_GENES?=$(PARAM_PSQL_SCHEMA).distances_genes
## table with pairwise ka/ks assignments
PARAM_TABLE_NAME_KAKS?=$(PARAM_PSQL_SCHEMA).kaks

################################################
## schemas in input
PARAM_SRC_SCHEMAS?=

## id of master genome
PARAM_GENOME_MASTER?=

## species tree
PARAM_SPECIES_TREE?=

################################################
## number of genomes to use
PARAM_NUM_GENOMES?=`echo $(PARAM_SRC_SCHEMAS) | wc -w`

## pattern to identify master genome
PARAM_PATTERN_GENOME_MASTER?=^$(PARAM_GENOME_MASTER)

PARAM_PATTERN_GENOME?=^([^$(PARAM_SEPARATOR)]+)[^$(PARAM_SEPARATOR)]

################################################
## directories and database schemas

## These should be sorted in the same way.
PARAM_SRC_DIRS?=$(PARAM_SRC_SCHEMAS)

PARAM_DATA_DIR?=/net/cpp-group/andreas/projects/flies/data/
PARAM_SRC_INTERPRO?=$(PARAM_DATA_DIR)interpro.list

PARAM_SEPARATOR?=|

## names of genomes sorted for output
PARAM_SORTED_SCHEMAS?=$(PARAM_SRC_SCHEMAS)

## names of genomes (for export)
PARAM_SRC_NAMES?=$(PARAM_SORTED_SCHEMAS)

## source directory with pairwise orthology information
PARAM_DIR_SRC=../../orthology_pairwise/

PARAM_DIR_PREDICTIONS=../../../predictions/

################################################
## Maximum ks for calculating ortholog distances
PARAM_MAX_KS?=5.0

################################################
## number of samples for GO zscore calculation.
PARAM_ANALYSIS_GO_SAMPLES?=1000
PARAM_ANALYSIS_GO_SLIMS?=/net/cpp-data/backup/andreas/projects/flies/data_1v3/goslim_generic.obo
PARAM_ANALYSIS_GO_THRESHOLD=0.05
PARAM_ANALYSIS_GO_CATEGORIES=biol_process cell_location mol_function

## database on where to get GO assignments from.
PARAM_ANALYSIS_GO_ENSEMBL=ensembl_mart_37

################################################
## Quality categories use for the input set.
## This should correspond to the categories used
## in Makefile.orthology_pairwise, variable 
## PARAM_STEP2_QUALITY_SEED
PARAM_QUALITY_INPUT_QUOTED_COMMA?='CG','SG','PG','RG','CP','SP','PP'

################################################
# Section parameters: end
################################################

GENOMES_COMMA=`echo $(PARAM_SORTED_SCHEMAS) | perl -p -e "s/ +/,/g"`
NAMES_COMMA=`echo $(PARAM_SRC_NAMES) | perl -p -e "s/ +/,/g"`

################################################
## some commands for dealing with psql

## extracting prefix for table name
CMD_TABLE_PREFIX=`echo $* | perl -p -e "s/\./_/g"`

## tab separated dump

PSQL_CONNECTION_OPTIONS=-t -A -F"	" 

################################################################################################
################################################################################################
################################################################################################
## Master targets
prepare: translation

################################################################################################
################################################################################################
################################################################################################
################################################################################################
## Targets to build in analysis
################################################################################################
all: \
	expansion-hook \
	orthologs-lists-hook \
	orphans-counts-hook \
	orphans-common-hook \
	orthologs-counts-hook \
	orthologs-ks-hook \
	orthologs-ka-hook \
	orthologs-t92-hook 

################################################################################################
%.csv: % translation
	rm -f $@
	$(YT)substitute_tokens.py \
	--apply=translation --multiple --columns=all \
	< $* |\
	grep -v "#" |\
	perl -p -e "s/\t/,/g" > $@

################################################################################################
## How to make a picture out of a matrix
%.png: %.matrix
	@$(YT)plot_matrix.py \
	$(PNG_OPTIONS) \
	--headers --labels="Genomes","Genomes" \
	--hardcopy=$@ \
	< $*.matrix > /dev/null

################################################################################################
## one pdf file with all postscript files
################################################################################################
all.pdf: 
	gs -dEPSCrop -dNOPAUSE -sDEVICE=pdfwrite -sOUTPUTFILE=$@ -dBATCH */*.eps

################################################################################################
## Command to substitute schema names with export names
CMD_SUBSTITUTE=$(YT)substitute_tokens.py --apply=translation --multiple --columns=all
CMD_TRANSLATE=$(YT)substitute_tokens.py --apply=translation


################################################################################################
################################################################################################
################################################################################################
################################################################################################
## Create wiki summary page for pairwise orthologies
################################################################################################
SUMMARY_WIKI_LOCATION=all local
SUMMARY_WIKI_TYPE=all functional pseudo
summary.wiki:
	$(PRELOG)
	@rm -f $@
	$(YT)preppy.py \
	$(DIR_SCRIPTS_GENEPREDICTION)orthology_pairwise_multiple.prep \
	genomes=$(GENOMES_COMMA) \
	locations=all,nojunk,local \
	categories=all,functional,pseudo  \
	> $@
	@mv -f summary.wiki $(PARAM_DIR_UPLOAD)
	@rm -f $(PARAM_DIR_UPLOAD)$@.zip
	@cd analysis.dir; zip $(PARAM_DIR_UPLOAD)$@.zip *.png *.eps_* 2>/dev/null
	$(EPILOG)

################################################################################################
################################################################################################
################################################################################################
################################################################################################
## Analysis of duplications
################################################################################################
ANALYSIS_TARGETS_DUPLICATIONS_CATEGORIES=step1 step2

## locations to examine
ANALYSIS_DUPLICATIONS_LOCATIONS=all,nojunk,local,cis

## gene categories to consider
ANALYSIS_DUPLICATIONS_FUNCTIONS=functional,pseudo,all

ANALYSIS_TARGETS_DUPLICATIONS=\
	$(ANALYSIS_TARGETS_DUPLICATIONS_CATEGORIES:%=duplications_%.dir) \
	$(ANALYSIS_TARGETS_DUPLICATIONS_CATEGORIES:%=duplications_%.dir/data) \
	$(ANALYSIS_TARGETS_DUPLICATIONS_CATEGORIES:%=duplications_%.dir/counts) \
	$(ANALYSIS_TARGETS_DUPLICATIONS_CATEGORIES:%=duplications_%.dir/lists) \
	$(ANALYSIS_TARGETS_DUPLICATIONS_CATEGORIES:%=duplications_%.dir/ulists) \
	$(ANALYSIS_TARGETS_DUPLICATIONS_CATEGORIES:%=duplications_%.dir/links) \
	$(ANALYSIS_TARGETS_DUPLICATIONS_CATEGORIES:%=duplications_%.dir/medians) \
	$(ANALYSIS_TARGETS_DUPLICATIONS_CATEGORIES:%=duplications_%.dir/hists)

duplications-hook: $(ANALYSIS_TARGETS_DUPLICATIONS)

ANALYSIS_FILE_STEP1_DUPLICATIONS=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step5.dir/step5_duplications.stats
ANALYSIS_FILE_STEP2_DUPLICATIONS=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step10.dir/step10_duplications.stats

################################################################################################
## Get duplication counts
duplications_step1.dir/data: ANALYSIS_FILE_DUPLICATIONS=$(ANALYSIS_FILE_STEP1_DUPLICATIONS)
duplications_step2.dir/data: ANALYSIS_FILE_DUPLICATIONS=$(ANALYSIS_FILE_STEP2_DUPLICATIONS)

duplications_%.dir/data: 
	$(PRELOG)
	@printf "species1\tspecies2\tcluster_id\tlocation\tfunction\theight\tlocations\ttree\n" > $@
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES) - 1; ++x )); do \
		for (( y = $$x + 1; y < $(PARAM_NUM_GENOMES); ++y )); do \
			genome1=$${genomes[$$x]}; \
			genome2=$${genomes[$$y]}; \
			awk -v g1="$${genome1}" -v g2="$${genome2}" '\
				$$1 == "branchpoint" && $$3 == g1  \
					{ printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", g1, g2, $$2, $$4, $$5, $$6, $$7, $$10, $$11); } \
				$$1 == "branchpoint" && $$3 == g2  \
					{ printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", g2, g1, $$2, $$4, $$5, $$6, $$7, $$10, $$11); } ' \
			< $(ANALYSIS_FILE_DUPLICATIONS) >> $@; \
		done; \
	done
	@touch $@
	$(EPILOG)

################################################################################################
## count the number of observations in each category 
duplications_%.dir/counts: duplications_%.dir/data
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_duplications.py \
	--species=$(GENOMES_COMMA) \
	--method=counts \
	--functions=$(ANALYSIS_DUPLICATIONS_FUNCTIONS) \
	--locations=$(ANALYSIS_DUPLICATIONS_LOCATIONS) \
	--filename-output="duplications_$*.dir/counts-%(l)s-%(f)s.matrix" \
	< duplications_$*.dir/data > $@
	@for x in duplications_$*.dir/counts-*.matrix; do \
		$(CMD_SUBSTITUTE) < $${x} > $${x}.tmp; mv $${x}.tmp $${x}; \
	done
	$(EPILOG)

################################################################################################
## get the median ks in each category (do not count 0 ks duplications)
duplications_%.dir/medians: duplications_%.dir/data
	$(PRELOG)
	@awk '$$6 > 0' < duplications_$*.dir/data |\
	python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_duplications.py \
	--species=$(GENOMES_COMMA) \
	--method=medians \
	--functions=$(ANALYSIS_DUPLICATIONS_FUNCTIONS) \
	--locations=$(ANALYSIS_DUPLICATIONS_LOCATIONS) \
	--filename-output="duplications_$*.dir/median-%(l)s-%(f)s.matrix" \
	> $@
	@for x in duplications_$*.dir/*.matrix; do \
		$(CMD_SUBSTITUTE) < $${x} > $${x}.tmp; mv $${x}.tmp $${x}; \
	done
	$(EPILOG)

################################################################################################
## write duplicated genes for each pairwise comparison
duplications_%.dir/lists: duplications_%.dir/data
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_duplications.py \
	--species=$(GENOMES_COMMA) \
	--method=lists \
	--functions=$(ANALYSIS_DUPLICATIONS_FUNCTIONS) \
	--locations=$(ANALYSIS_DUPLICATIONS_LOCATIONS) \
	--filename-output="duplications_step2.dir/%(l)s-%(f)s-%(s)s-%(o)s.list" \
	< duplications_$*.dir/data > $@
	$(EPILOG)

################################################################################################
## write duplicated genes for each species
duplications_%.dir/ulists: duplications_%.dir/data
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_duplications.py \
	--species=$(GENOMES_COMMA) \
	--method=lists-union \
	--functions=$(ANALYSIS_DUPLICATIONS_FUNCTIONS) \
	--locations=$(ANALYSIS_DUPLICATIONS_LOCATIONS) \
	--filename-output="duplications_step2.dir/%(l)s-%(f)s-%(s)s.ulist" \
	< duplications_$*.dir/data > $@
	$(EPILOG)

################################################################################################
## write links between duplicated genes
duplications_%.dir/links: duplications_%.dir/data
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_duplications.py \
	--species=$(GENOMES_COMMA) \
	--method=links \
	--functions=$(ANALYSIS_DUPLICATIONS_FUNCTIONS) \
	--locations=$(ANALYSIS_DUPLICATIONS_LOCATIONS) \
	--filename-output="duplications_$*.dir/%(l)s-%(f)s-%(s)s-%(o)s.links" \
	< duplications_$*.dir/data > $@
	@for x in duplications_$*.dir/*.matrix; do \
		$(CMD_SUBSTITUTE) < $${x} > $${x}.tmp; mv $${x}.tmp $${x}; \
	done
	$(EPILOG)

################################################################################################
## write pairs between duplicated genes
duplications_%.dir/pairs: duplications_%.dir/data
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_duplications.py \
	--species=$(GENOMES_COMMA) \
	--method=pairs \
	--functions=$(ANALYSIS_DUPLICATIONS_FUNCTIONS) \
	--locations=$(ANALYSIS_DUPLICATIONS_LOCATIONS) \
	--filename-output="duplications_step2.dir/%(l)s-%(f)s-%(s)s-%(o)s.pairs" \
	< duplications_$*.dir/data > $@
	@for x in duplications_$*.dir/*.matrix; do \
		$(CMD_SUBSTITUTE) < $${x} > $${x}.tmp; mv $${x}.tmp $${x}; \
	done
	@touch $@
	$(EPILOG)

################################################################################################
## Histogram of duplications
## Each histogram contains the histogram of duplication event times
##	in each pairwise comparison. Histograms are created for both absolute and relative
##	divergence times.
## i.e. $@_..._dmel_vs_dmel_....hist are the duplication time points in 
## the melanogaster lineage when compared to each species.
duplications_%.dir/hists: duplications_%.dir/data
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_duplications.py \
	--species=$(GENOMES_COMMA) \
	--method=hists \
	--functions=$(ANALYSIS_DUPLICATIONS_FUNCTIONS) \
	--locations=$(ANALYSIS_DUPLICATIONS_LOCATIONS) \
	--bin-size=0.01 \
	--min-value=0.0 \
	--filename-output="duplications_$*.dir/absolute-%(s)s-%(l)s-%(f)s.hist" \
	< duplications_$*.dir/data > $@
	@python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_duplications.py \
	--species=$(GENOMES_COMMA) \
	--method=hists \
	--functions=$(ANALYSIS_DUPLICATIONS_FUNCTIONS) \
	--locations=$(ANALYSIS_DUPLICATIONS_LOCATIONS) \
	--bin-size=0.01 \
	--min-value=0.0 \
	--use-relative-height \
	--filename-output="duplications_$*.dir/relative-%(s)s-%(l)s-%(f)s.hist" \
	< duplications_$*.dir/data >> $@
	@python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_duplications.py \
	--species=$(GENOMES_COMMA) \
	--method=hists \
	--functions=$(ANALYSIS_DUPLICATIONS_FUNCTIONS) \
	--locations=$(ANALYSIS_DUPLICATIONS_LOCATIONS) \
	--bin-size=0.01 \
	--min-value=0.0 \
	--reverse \
	--filename-output="duplications_$*.dir/absolute-reverse-%(s)s-%(l)s-%(f)s.hist" \
	< duplications_$*.dir/data >> $@
	@for x in duplications_$*.dir/*.hist; do \
		$(CMD_SUBSTITUTE) < $${x} > $${x}.tmp; mv $${x}.tmp $${x}; \
	done
	$(EPILOG)

################################################################################################
## create images for the duplication analysis
duplications.images:
	$(PRELOG)
	@for x in duplications_*/*.links; do \
		if [ ! -e $${x}.svg ]; then \
		    $(CMD_MSG2) "processing $${x}"; \
		    genome=`echo $${x} | perl -p -e "s/[^\-]+\-[^\-]+\-//; s/\-.+//"`; \
		    $(YT)optic/plot_duplications.py \
			    --increment=100 \
			    --url="http://wwwfgu.anat.ox.ac.uk/cgi-bin/gbrowse/$${genome}/?name=dmel_vs_dmel4_%s" \
			    --radius=2000 \
			    --contig-sizes=$(PARAM_DIR_PREDICTIONS)$${genome}/contig_sizes \
		    < $${x} |\
		    grep -v "#" > $${x}.svg; \
		fi; \
	done
	@for x in duplications_*/absolute*.hist; do \
		if [ ! -e $${x}.png ]; then \
		    $(CMD_MSG2) "processing $${x}"; \
		    $(YT)plot_histogram.py \
		    --hardcopy=$${x}.png \
		    --xrange=-0.2,2.0 \
		    --truncate \
		    < $${x} > /dev/null; \
		fi; \
	done
	@for x in duplications_*/relative*.hist; do \
		if [ ! -e $${x}.png ]; then \
		    $(CMD_MSG2) "processing $${x}"; \
		    $(YT)plot_histogram.py \
		    --hardcopy=$${x}.png \
		    --xrange=-0.2,1.0 \
		    --truncate \
		    < $${x} > /dev/null; \
		fi; \
	done
	@for x in duplications_*/*.matrix; do \
		if [ ! -e $${x}.png ]; then \
		    $(CMD_MSG2) "processing $${x}"; \
		    $(YT)plot_matrix.py \
		    --headers --labels="Genomes","Genomes" \
		    --hardcopy=$${x}.png \
		    < $${x} > /dev/null ; \
		fi; \
	done
	$(EPILOG)

################################################################################################
################################################################################################
################################################################################################
################################################################################################
## Analyse duplications with respect to the master genome
################################################################################################
master_duplications_step1_%.list: ANALYSIS_MASTER_DUPLICATIONS_FILE=$(ANALYSIS_FILE_STEP1_DUPLICATIONS)
master_duplications_step2_%.list: ANALYSIS_MASTER_DUPLICATIONS_FILE=$(ANALYSIS_FILE_STEP2_DUPLICATIONS)

## column 4: number of members in this cluster.
## starting from column 6, these are the columns:
## "local", "nonlocal", "cis-transposition", "trans-transposition", "junk", "unknown", "overlap", "single")
## no junk filters: 6,7,8,9 > 0 or 10,11,12 == 0
master_duplications_step1_nojunk.list: ANALYSIS_MASTER_DUPLICATIONS_SELECT=&& $$4 > 0 && ( ($$6+$$7+$$8+$$9 > 0) || ($$10+$$11+$$12 == 0) )
master_duplications_step2_nojunk.list: ANALYSIS_MASTER_DUPLICATIONS_SELECT=&& $$4 > 0 && ( ($$6+$$7+$$8+$$9 > 0) || ($$10+$$11+$$12 == 0) )

## cis filters: 6,7 > 0, 8,9,10,11,12 = 0 
master_duplications_step1_cis.list: ANALYSIS_MASTER_DUPLICATIONS_SELECT=&& $$4 > 0 && ( ($$6+$$7 > 0) || ($$8+$$9+$$10+$$11+$$12 == 0) )
master_duplications_step2_cis.list: ANALYSIS_MASTER_DUPLICATIONS_SELECT=&& $$4 > 0 && ( ($$6+$$7 > 0) || ($$8+$$9+$$10+$$11+$$12 == 0) )

## only get cis duplicated genes, which are duplicated in the other genome
master_duplications_step2_inother_cis.list: ANALYSIS_MASTER_DUPLICATIONS_SELECT=&& $$4 == 1 && ( ($$6+$$7 > 0) || ($$8+$$9+$$10+$$11+$$12 == 0) )

## only get cis duplicated genes, which are duplicated in the master genome
master_duplications_step2_inmaster_cis.list: ANALYSIS_MASTER_DUPLICATIONS_SELECT=&& $$4 > 1 && ( ($$6+$$7 > 0) || ($$8+$$9+$$10+$$11+$$12 == 0) )

################################################################################################
## get a list duplicated genes for each species starting from the master species.
## The paired genes have either one member which is local,nonlocal,cis/trans-transpositions.
## (to exclude full junkies).
## Note: the npseudo/nfunctional counts are inaccurate, as they do not take into account
## junk/overlap duplications.
## additional rule: do not take those which are designated as overlap
master_duplications_%.list:
	$(PRELOG)
	@printf "gene\tschema\tnfunctional\tnpseudo\n" > $@
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES); ++x )); do \
		genome1=$(PARAM_GENOME_MASTER); \
		genome2=$${genomes[$$x]} ; \
		if test -e $(ANALYSIS_MASTER_DUPLICATIONS_FILE); then \
			awk -v genome1=$${genome1} -v genome2=$${genome2} \
			'$$1 == "species" && \
				$$3 == "$(PARAM_GENOME_MASTER)" \
			   { if ($$4 == "overlap") { keep = 0; } else { keep = 1; } } \
			 $$1 == "pairs" && \
				$$3 == "$(PARAM_GENOME_MASTER)" \
			        $(ANALYSIS_MASTER_DUPLICATIONS_SELECT) \
			   { if (keep) {printf("%s\t%s\t%i\t%i\n", $$5, genome2, $$13, $$14);} } \
			 '\
			< $(ANALYSIS_MASTER_DUPLICATIONS_FILE) >> $@; \
		fi; \
	done
	$(EPILOG)

################################################################################################
################################################################################################
################################################################################################
################################################################################################
## Get information about duplicated genes
## Define variables: 
################################################################################################
excerpt:
	awk 'BEGIN { while (getline < "$(CMDLINE_PARAM_FILE_LIST)") { take[$$1] = 1; } keep = 0;} \
		/^#/ { if(keep) { printf("%s\n", result); } result = ""; keep = 0; } \
		/^members/ && $$3 == "$(PARAM_GENOME_MASTER)" \
		{ split($$4, a, "\t"); keep = 0; \
		  for (x in a) { if (take[a[x]]) { keep = 1; } } \
		  } \
		{ result = result "\n" $$0; }' < $(CMDLINE_PARAM_FILE_DUPLICATIONS)

################################################################################################
################################################################################################
################################################################################################
################################################################################################
## Go analysis of duplications
################################################################################################
## Calculate GO. Background frequencies are all for which there is orthology information.
ANALYSIS_TARGETS_MASTER_GO_CATEGORIES=step1_withjunk step1_nojunk step1_cis step2_withjunk step2_nojunk step2_cis 

ANALYSIS_TARGETS_MASTER_GO=$(ANALYSIS_TARGETS_MASTER_GO_CATEGORIES:%=master_duplications_%.list) \
	$(ANALYSIS_TARGETS_MASTER_GO_CATEGORIES:%=master_duplications_%.go) \
	$(ANALYSIS_TARGETS_MASTER_GO_CATEGORIES:%=master_duplications_%.go.counts) \
	$(ANALYSIS_TARGETS_MASTER_GO_CATEGORIES:%=master_duplications_%.go.eps) \
	$(ANALYSIS_TARGETS_MASTER_GO_CATEGORIES:%=master_duplications_%.go.svg)

## hook for getting lists of duplicated genes in master
master-duplications-hook: $(ANALYSIS_TARGETS_MASTER_GO_CATEGORIES:%=master_duplications_%.list)

## calculate go analysis
master-duplications-go-hook: $(ANALYSIS_TARGETS_MASTER_GO)

master_duplications_%.go:ANALYSIS_GO_BACKGROUND=master_orthologs_step1.list
master_duplications_%.go:ANALYSIS_GO_BACKGROUND=master_orthologs_step2.list

################################################################################################
################################################################################################
################################################################################################
################################################################################################
## Interpro analysis of duplications
################################################################################################
ANALYSIS_TARGETS_MASTER_INTERPRO_CATEGORIES=step1_withjunk step1_nojunk step1_cis step2_withjunk step2_nojunk step2_cis 

ANALYSIS_TARGETS_MASTER_INTERPRO=$(ANALYSIS_TARGETS_MASTER_INTERPRO_CATEGORIES:%=master_duplications_%.list) \
	$(ANALYSIS_TARGETS_MASTER_INTERPRO_CATEGORIES:%=master_duplications_%.interpro) \
	$(ANALYSIS_TARGETS_MASTER_INTERPRO_CATEGORIES:%=master_duplications_%.interpro.counts) \
	$(ANALYSIS_TARGETS_MASTER_INTERPRO_CATEGORIES:%=master_duplications_%.interpro.eps) \
	$(ANALYSIS_TARGETS_MASTER_INTERPRO_CATEGORIES:%=master_duplications_%.interpro.svg)

## calculate interpro analysis
master-duplications-interpro-hook: $(ANALYSIS_TARGETS_MASTER_INTERPRO)

master_duplications_%.interpro:ANALYSIS_INTERPRO_BACKGROUND=master_orthologs_step1.list
master_duplications_%.interpro:ANALYSIS_INTERPRO_BACKGROUND=master_orthologs_step2.list

################################################################################################
################################################################################################
################################################################################################
################################################################################################
## Shared duplications in D. melanogaster when compare to other pairs
################################################################################################
master_duplications_shared.dir/%.matrix: master_duplications_%.list
	$(PRELOG)
	@-mkdir master_duplications_shared.dir
	@rm -f $@_tmp; 
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES); ++x )); do \
		genome1=$${genomes[$$x]}; \
		for (( y = 0; y < $(PARAM_NUM_GENOMES); ++y )); do \
			genome2=$${genomes[$$y]} ; \
			if [[ "$${genome1}" != "$(PARAM_GENOME_MASTER)" && "$${genome2}" != "$(PARAM_GENOME_MASTER)" ]]; then \
			    grep $${genome1} master_duplications_$*.list | cut -f 1 > $@_tmp1; \
			    grep $${genome2} master_duplications_$*.list | cut -f 1 > $@_tmp2; \
			    printf "%s\t%s\t%i\n" $${genome1} $${genome2} \
			    `$(ET)set_intersection.pl $@_tmp1 $@_tmp2 | wc -l` >> $@_tmp; \
			fi; \
		done; \
	done
	@$(YT)sparse2full.py \
	--row-names=$(GENOMES_COMMA) \
	--col-names=$(GENOMES_COMMA) \
	--asymmetric \
	< $@_tmp | $(CMD_SUBSTITUTE) > $@
	@rm -f $@_tmp*
	@$(YT)matrix2matrix.py \
		--method=normalize-by-min-diagonal \
		< $@ > master_duplications_shared.dir/$*_normalized.matrix
	$(EPILOG)

################################################################################################
## Build excel file with duplication information
duplications.xls:
	$(PRELOG)
	@$(YT)csv2xls.py --outfile=$@ \
	duplications_*.hist 
	$(EPILOG)

################################################################################################
################################################################################################
################################################################################################
################################################################################################
## Analysis of orphans in D. melanogaster
################################################################################################
ANALYSIS_TARGETS_MASTER_ORPHANS_CATEGORIES=step1
ANALYSIS_TARGETS_MASTER_ORPHANS_GO=$(ANALYSIS_TARGETS_MASTER_ORPHANS_CATEGORIES:%=master_orthologs_%.list) \
				   $(ANALYSIS_TARGETS_MASTER_ORPHANS_CATEGORIES:%=master_orphans_%.list) \
				   $(ANALYSIS_TARGETS_MASTER_ORPHANS_CATEGORIES:%=master_orphans_%.go) \
				   $(ANALYSIS_TARGETS_MASTER_ORPHANS_CATEGORIES:%=master_orphans_%.go.counts) \
				   $(ANALYSIS_TARGETS_MASTER_ORPHANS_CATEGORIES:%=master_orphans_%.go.eps) \
				   $(ANALYSIS_TARGETS_MASTER_ORPHANS_CATEGORIES:%=master_orphans_%.go.svg) 

master-orphans-go-hook: $(ANALYSIS_TARGETS_MASTER_ORPHANS_GO)

master_orphans_step1.go:ANALYSIS_GO_BACKGROUND=master_orthologs_step1.list
master_orphans_step2.go:ANALYSIS_GO_BACKGROUND=master_orthologs_step2.list

master_orphans_step1.list: ANALYSIS_FILE_ORPHANS=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step5.dir/step5_orphans.stats
master_orphans_step2.list: ANALYSIS_FILE_ORPHANS=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step10.dir/step10_orphans.stats

################################################################################################
## The list orphaned genes for each pair starting from the master species.
## Do not include alternative transcripts.
master_orphans_%.list:
	$(PRELOG)
	@printf "gene\tschema\tstatus\n" > $@
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES); ++x )); do \
		genome1=$(PARAM_GENOME_MASTER); \
		genome2=$${genomes[$$x]} ; \
		if test -e $(ANALYSIS_FILE_ORPHANS); then \
			awk -v genome1=$${genome1} -v genome2=$${genome2} \
			'/^# summary/ { exit 0; } \
			 /^#/ { next; } \
			 $$1 == "geneid" { next }; \
			 $$4 == "alternative" { next; } \
			 { printf("%s$(PARAM_SEPARATOR)%s$(PARAM_SEPARATOR)%s$(PARAM_SEPARATOR)UK\t%s\t%s\n", genome1, $$1, $$1, genome2, $$4 ); } '\
			< $(ANALYSIS_FILE_ORPHANS) >> $@; \
		fi; \
	done
	$(EPILOG)

################################################################################################
################################################################################################
################################################################################################
################################################################################################
## Analysis of orthologs to D. melanogaster
################################################################################################
ANALYSIS_TARGETS_SRC=master_orthologs orthologs
ANALYSIS_TARGETS_ORTHOLOGS=$(ANALYSIS_TARGETS_SRC:%=%_step1.list) \
				$(ANALYSIS_TARGETS_SRC:%=%_step2.list)

orthologs-lists-hook: $(ANALYSIS_TARGETS_ORTHOLOGS)

master_orthologs_step1.list:  ANALYSIS_FILE_ORTHOLOGS=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step5.dir/step5_orthologs.stats
master_orthologs_step2.list: ANALYSIS_FILE_ORTHOLOGS=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step10.dir/step10_orthologs.stats
orthologs_step1.list: ANALYSIS_FILE_ORTHOLOGS=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step5.dir/step5_orthologs.stats
orthologs_step2.list: ANALYSIS_FILE_ORTHOLOGS=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step10.dir/step10_orthologs.stats

################################################################################################
## Write a list of all orthologs together with their degeneracy for the master genome
master_orthologs_%.list:
	$(PRELOG)
	@printf "gene\tschema\tnstatus\n" > $@
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	genome1=$(PARAM_GENOME_MASTER); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES); ++x )); do \
		genome2=$${genomes[$$x]} ; \
		if [ "$${genome1}" != "$${genome2}" ]; then \
			awk -v genome1=$${genome1} -v genome2=$${genome2} \
				'$$1 == "$(PARAM_GENOME_MASTER)" && $$2 == "gene" \
			 	{ printf("%s\t%s\t%s\n", $$3, genome2, $$4); }' \
			< $(ANALYSIS_FILE_ORTHOLOGS) >> $@; \
		fi; \
	done
	$(EPILOG)

################################################################################################
## Write a list of all orthologs together with their degeneracy
orthologs_%.list:
	$(PRELOG)
	@printf "schema1\tgene\tschema2\tnstatus\n" > $@
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES) - 1; ++x )); do \
	 	genome1=$${genomes[$$x]} ; \
		for (( y = $$x + 1; y < $(PARAM_NUM_GENOMES); ++y )); do \
			genome2=$${genomes[$$y]} ; \
			awk -v genome1=$${genome1} -v genome2=$${genome2} \
			'$$1 ~ genome1 && $$2 == "gene" \
			 { printf ("%s\t%s\t%s\t%s\n", genome1, $$3, genome2, $$4); }' \
			< $(ANALYSIS_FILE_ORTHOLOGS) >> $@; \
			awk -v genome1=$${genome2} -v genome2=$${genome1} \
			'$$1 ~ genome1 && $$2 == "gene" \
			 { printf ("%s\t%s\t%s\t%s\n", genome1, $$3, genome2, $$4); }' \
			< $(ANALYSIS_FILE_ORTHOLOGS) >> $@; \
		done; \
	done
	$(EPILOG)

################################################################################################
## Matrix with dots for each present ortholog for genes in master
master_orthologs_%.matrix: master_orthologs_%.list
	$(PRELOG)
	awk '{split( $$3, a, ":"); \
		if (a[1] == 1) { \
			if (a[2] == 1) { x = 10; } \
			else { x = 20; } \
		} else { \
			if (a[2] == 1) { x = 30; } \
			else { x = 40; } \
		} \
		printf("%s\t%s\t%s\n", $$1, $$2, x); }' < master_orthologs.list |\
	$(YT)sparse2full.py \
	--asymmetric \
	--col-names="$(GENOMES_COMMA)" \
	> $@
	$(EPILOG)

################################################################################################
################################################################################################
################################################################################################
################################################################################################
## Analysis of expansion of genes with respect to and from the master genome
##
## Targets without modifier are counts based on master genome genes.
##
## Targets with _reverse are the counts based on the query genome.
##
## Print out lists of 1:1 orthologs, degenerate orthologs and the number of orphans.
## The number of orphans is inferred from the input minus the number of asigned orthologs.
################################################################################################
ANALYSIS_EXPANSION_TARGETS=step1 step2

expansion-hook: expansion.dir \
		$(ANALYSIS_EXPANSION_TARGETS:%=expansion.dir/expansion_%_counts.table) \
		$(ANALYSIS_EXPANSION_TARGETS:%=expansion.dir/expansion_%_all.table) \
		$(ANALYSIS_EXPANSION_TARGETS:%=expansion.dir/expansion_%_normalized.table) \
		$(ANALYSIS_EXPANSION_TARGETS:%=expansion.dir/expansion_%_counts.png) \
		$(ANALYSIS_EXPANSION_TARGETS:%=expansion.dir/expansion_%_normalized_reverse.table) \


expansion.dir/expansion_step1_%.table: ANALYSIS_FILE_EXPANSION=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step5.dir/step5_expansion.stats
expansion.dir/expansion_step2_%.table: ANALYSIS_FILE_EXPANSION=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step10.dir/step10_expansion.stats
expansion.dir/expansion_step1_%.table: ANALYSIS_FILE_INPUT=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step5.dir/step5_input.stats
expansion.dir/expansion_step2_%.table: ANALYSIS_FILE_INPUT=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step10.dir/step10_input.stats

################################################################################################
expansion.dir/expansion_%_counts.table:
	@genomes=( $(PARAM_SORTED_SCHEMAS) ); \
	ninput=`$(PSQL_CONNECTION) "SELECT COUNT(DISTINCT rep_token) FROM $(PARAM_GENOME_MASTER).queries" $(PSQL_CONNECTION_OPTIONS)`; \
	for (( x = 0; x < $(PARAM_NUM_GENOMES); ++x )); do \
		genome1=$(PARAM_GENOME_MASTER); \
		genome2=$${genomes[$$x]} ; \
		if [[ "$${genome1}" != "$${genome2}" ]]; then \
		    none2ones=`awk '/^[^0-9]/ && !/^#/ { printf("%s\t%s\t", $$1, $$2); } \
				    ($$1 == 1 && $$2 == 1) { printf("%s\n", $$3) }' \
				< $(ANALYSIS_FILE_EXPANSION) | cut -f 3`; \
		    awk -v genome1=$${genome1} -v genome2=$${genome2} -v none2ones="$${none2ones}" -v ninput="$${ninput}" \
			 '/genes with self-links/ { total = $$1; } \
			  /genes with assigned orthology/ { assigned = $$1; } \
			    END {   printf("category\t%s\n", genome2); \
				    printf("straight\t%i\n",none2ones);  \
				    printf("degenerate\t%i\n",assigned-none2ones);  \
				    printf("orphans\t%i\n", ninput-assigned);  \
				}' \
			< $(ANALYSIS_FILE_INPUT) > $@_$${genome2}_tmp; \
		fi; \
	done
	@$(YT)combine_tables.py \
	--missing="na" \
	--sort="$(GENOMES_COMMA)" \
	$@_*tmp |\
	$(CMD_TRANSLATE) > expansion.dir/expansion_$*_counts.table
	@rm -f $@_*tmp*
	$(EPILOG)

###########################################################################################
## Get table of orthologs assigned in master normalized by the total number of genes with
## pairwise links.
##
## This measures the effectiveness of the orthology assignment step.
expansion.dir/expansion_%_all.table:
	@genomes=( $(PARAM_SORTED_SCHEMAS) ); \
	printf "genome\ttotal\t\tstraight\t\tdegenerate\t\torphans\t\n" > $@; \
	for (( x = 0; x < $(PARAM_NUM_GENOMES); ++x )); do \
		genome1=$(PARAM_GENOME_MASTER); \
		genome2=$${genomes[$$x]} ; \
		if [[ "$${genome1}" != "$${genome2}" ]]; then \
		    none2ones=`awk '/^[^0-9]/ && !/^#/ { printf("%s\t%s\t", $$1, $$2); } \
				    ($$1 == 1 && $$2 == 1) { printf("%s\n", $$3) }' \
				< $(ANALYSIS_FILE_EXPANSION) | cut -f 3`; \
		    awk -v genome1=$${genome1} -v genome2=$${genome2} -v none2ones="$${none2ones}" \
			'BEGIN { printf("%s\t", genome2 ); } \
			  /genes with self-links/ { total = $$1; } \
			  /genes with assigned orthology/ { assigned = $$1; } \
			    END { printf("%i\t%5.2f\t%i\t%5.2f\t%i\t%5.2f\t%i\t%5.2f\n", \
					total, total * 100 / total,  \
					none2ones, none2ones * 100 / total, \
					assigned-none2ones, (assigned-none2ones) * 100 / total, \
					total-assigned, (total-assigned) * 100 / total ); \
				}' \
			< $(ANALYSIS_FILE_INPUT) | $(CMD_TRANSLATE) >> $@; \
		fi; \
	done
	$(EPILOG)

###########################################################################################
## Get table of orthologs assigned in master normalized by the total number of genes in 
## the input set (rep_tokens).
##
## This measures the effectiveness of the whole orthology assignment pipeline.
expansion.dir/expansion_%_normalized.table:
	@genomes=( $(PARAM_SORTED_SCHEMAS) ); \
	ninput=`$(PSQL_CONNECTION) "SELECT COUNT(DISTINCT rep_token) FROM $(PARAM_GENOME_MASTER).queries" $(PSQL_CONNECTION_OPTIONS)`; \
	printf "# effectiveness of the whole orthology assignment pipeline, normalized by %i query tokens.\n" $${ninput} > $@; \
	printf "genome\tsubmitted\t\tstraight\t\tdegenerate\t\torphans\t\n" >> $@; \
	for (( x = 0; x < $(PARAM_NUM_GENOMES); ++x )); do \
		genome1=$(PARAM_GENOME_MASTER); \
		genome2=$${genomes[$$x]} ; \
		if [[ "$${genome1}" != "$${genome2}" ]]; then \
		    none2ones=`awk '/^[^0-9]/ && !/^#/ { printf("%s\t%s\t", $$1, $$2); } \
				    ($$1 == 1 && $$2 == 1) { printf("%s\n", $$3) }' \
				< $(ANALYSIS_FILE_EXPANSION) | cut -f 3`; \
		    awk -v genome1="$${genome1}" -v genome2="$${genome2}" -v none2ones="$${none2ones}" -v ninput="$${ninput}" \
			'BEGIN { printf("%s\t", genome2 ); } \
			  /genes with self-links/ { total = $$1; } \
			  /genes with assigned orthology/ { assigned = $$1; } \
			    END { printf("%i\t%5.2f\t%i\t%5.2f\t%i\t%5.2f\t%i\t%5.2f\n", \
					total, total * 100 / ninput,  \
					none2ones, none2ones * 100 / ninput, \
					assigned-none2ones, (assigned-none2ones) * 100 / ninput, \
					ninput-assigned, (ninput-assigned) * 100 / ninput ); \
				}' \
			< $(ANALYSIS_FILE_INPUT) >> $@; \
		fi; \
	done
	$(EPILOG)

expansion.dir/expansion_%.png: expansion.dir/expansion_%.table
	$(PRELOG)
	@$(YT)r_table2scatter.py \
	--plot=bar \
	--file=<(cat $< | $(CMD_SUBSTITUTE)) \
	--columns=all \
	--legend=1 \
	--options="cex.lab=1.5, cex.names=1.5, cex.legend=1.5, cex.axis=1.5" \
	--labels="Genome","Number of genes" \
	--hardcopy=$@ > /dev/null
	$(EPILOG)

###########################################################################################
## Get table of orthologs assigned in query normalized by the total number of genes in 
## the input set.
##
## This measures the effectiveness of the whole orthology assignment pipeline.
## The difference between the previous target: 
## 1. it uses column 2 in $(ANALYSIS_FILE_INPUT)
## 2. the total is given by the number of genes with status $(PARAM_QUALITY_INPUT_QUOTED_COMMA).
expansion.dir/expansion_%_normalized_reverse.table:
	@genomes=( $(PARAM_SORTED_SCHEMAS) ); \
	printf "# effectiveness of the whole orthology assignment pipeline - orthologs in query genomes.\n" > $@; \
	printf "genome\ttotal\tsubmitted\t\tstraight\t\tdegenerate\t\torphans\t\n" >> $@; \
	for (( x = 0; x < $(PARAM_NUM_GENOMES); ++x )); do \
		genome1=$(PARAM_GENOME_MASTER); \
		genome2=$${genomes[$$x]} ; \
		ninput=`$(PSQL_CONNECTION) "SELECT COUNT(DISTINCT gene_id) FROM $${genome2}.geneinfo \
			WHERE best_class IN ($(PARAM_QUALITY_INPUT_QUOTED_COMMA))" \
			$(PSQL_CONNECTION_OPTIONS)`; \
		if [[ "$${genome1}" != "$${genome2}" ]]; then \
		    none2ones=`awk '/^[^0-9]/ && !/^#/ { printf("%s\t%s\t", $$1, $$2); } \
				    ($$1 == 1 && $$2 == 1) { printf("%s\n", $$3) }' \
				< $(ANALYSIS_FILE_EXPANSION) | cut -f 3`; \
		    awk -v genome1="$${genome1}" -v genome2="$${genome2}" -v none2ones="$${none2ones}" -v ninput="$${ninput}" \
			'BEGIN { printf("%s\t", genome2 ); } \
			  /genes with self-links/ { total = $$2; } \
			  /genes with assigned orthology/ { assigned = $$2; } \
			    END { printf("%i\t%i\t%5.2f\t%i\t%5.2f\t%i\t%5.2f\t%i\t%5.2f\n", \
					ninput, total, total * 100 / ninput,  \
					none2ones, none2ones * 100 / ninput, \
					assigned-none2ones, (assigned-none2ones) * 100 / ninput, \
					ninput-assigned, (ninput-assigned) * 100 / ninput ); \
				}' \
			< $(ANALYSIS_FILE_INPUT) >> $@; \
		fi; \
	done
	$(EPILOG)

################################################################################################
################################################################################################
################################################################################################
################################################################################################
## Analysis of orthologs and their degeneracy: counts
################################################################################################
ANALYSIS_QUERIES_ORTHOLOGS1=counts percent_assigned percent_all
ANALYSIS_QUERIES_ORTHOLOGS2=$(ANALYSIS_QUERIES_ORTHOLOGS1:%=%_step1) $(ANALYSIS_QUERIES_ORTHOLOGS1:%=%_step2)
ANALYSIS_TARGETS_ORTHOLOGS=$(ANALYSIS_QUERIES_ORTHOLOGS2:%=orthologs_%_strict.matrix) \
				$(ANALYSIS_QUERIES_ORTHOLOGS2:%=orthologs_%_degenerate.matrix)
ANALYSIS_ORTHOLOGS_IMAGES_SRC=$(wildcard orthologs_counts*.matrix) \
				$(wildcard orthologs_percent_assigned*.matrix) \
				$(wildcard orthologs_percent_all*.matrix) 

orthologs-counts-hook: $(ANALYSIS_TARGETS_ORTHOLOGS) orthologs-counts-images
orthologs-counts-images: $(ANALYSIS_ORTHOLOGS_IMAGES_SRC:%.matrix=%.png) 

orthologs_counts_step1_%.matrix: ANALYSIS_FILE_EXPANSION=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step5.dir/step5_expansion.stats
orthologs_counts_step2_%.matrix: ANALYSIS_FILE_EXPANSION=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step10.dir/step10_expansion.stats
orthologs_counts_step1_strict.matrix:   ANALYSIS_EXPANSION_SELECT=($$1 == 1 && $$2 == 1) 
orthologs_counts_step2_strict.matrix:   ANALYSIS_EXPANSION_SELECT=($$1 == 1 && $$2 == 1) 
orthologs_counts_step1_degenerate.matrix: ANALYSIS_EXPANSION_SELECT=($$1 > 1 || $$2 > 1) 
orthologs_counts_step2_degenerate.matrix: ANALYSIS_EXPANSION_SELECT=($$1 > 1 || $$2 > 1) 

orthologs_percent_assigned_step1_%.matrix: ANALYSIS_FILE_EXPANSION=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step5.dir/step5_expansion.stats
orthologs_percent_assigned_step2_%.matrix: ANALYSIS_FILE_EXPANSION=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step10.dir/step10_expansion.stats
orthologs_percent_assigned_step1_strict.matrix:   ANALYSIS_EXPANSION_SELECT=($$1 == 1 && $$2 == 1) 
orthologs_percent_assigned_step2_strict.matrix:   ANALYSIS_EXPANSION_SELECT=($$1 == 1 && $$2 == 1) 
orthologs_percent_assigned_step1_degenerate.matrix: ANALYSIS_EXPANSION_SELECT=($$1 > 1 || $$2 > 1) 
orthologs_percent_assigned_step2_degenerate.matrix: ANALYSIS_EXPANSION_SELECT=($$1 > 1 || $$2 > 1) 

orthologs_percent_all_step1_%.matrix: ANALYSIS_FILE_EXPANSION=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step5.dir/step5_expansion.stats
orthologs_percent_all_step2_%.matrix: ANALYSIS_FILE_EXPANSION=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step10.dir/step10_expansion.stats
orthologs_percent_all_step1_strict.matrix:   ANALYSIS_EXPANSION_SELECT=($$1 == 1 && $$2 == 1) 
orthologs_percent_all_step2_strict.matrix:   ANALYSIS_EXPANSION_SELECT=($$1 == 1 && $$2 == 1) 
orthologs_percent_all_step1_degenerate.matrix: ANALYSIS_EXPANSION_SELECT=($$1 > 1 || $$2 > 1) 
orthologs_percent_all_step2_degenerate.matrix: ANALYSIS_EXPANSION_SELECT=($$1 > 1 || $$2 > 1) 

################################################################################################
## print counts of 1:1 orthologs
orthologs_counts_%.matrix:
	$(PRELOG)
	@rm -f $@_tmp
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES) - 1; ++x )); do \
		for (( y = $$x + 1; y < $(PARAM_NUM_GENOMES); ++y )); do \
			genome1=$${genomes[$$x]}; \
			genome2=$${genomes[$$y]}; \
			grep -v "#" $(ANALYSIS_FILE_EXPANSION) |\
			awk '/^[^0-9]/ { a = $$1; b = $$2; next } \
	     			$(ANALYSIS_EXPANSION_SELECT) \
				{ n1 += $$9; n2 += $$10; } \
				END { \
				printf("%s\t%s\t%s\n", a, b, n1); \
				printf("%s\t%s\t%s\n", b, a, n2); \
			}' >> $@_tmp; \
		done; \
	done
	@$(YT)sparse2full.py \
	--asymmetric \
	--row-names=$(GENOMES_COMMA) \
	--col-names=$(GENOMES_COMMA) \
	< $@_tmp |\
	$(CMD_SUBSTITUTE) > $@
	@rm -rf $@_tmp
	$(EPILOG)

################################################################################################
## print matrix normalized by the number of genes.
orthologs_percent_assigned_%.matrix:
	$(PRELOG)
	@rm -f $@_tmp
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES) - 1; ++x )); do \
		for (( y = $$x + 1; y < $(PARAM_NUM_GENOMES); ++y )); do \
			genome1=$${genomes[$$x]}; \
			genome2=$${genomes[$$y]}; \
			grep -v "#" $(ANALYSIS_FILE_EXPANSION) |\
			awk '/^[^0-9]/ { a = $$1; b = $$2; next } \
	     			$(ANALYSIS_EXPANSION_SELECT) { \
				n1 += $$5; n2 += $$6; } \
				END { \
				printf("%s\t%s\t%s\n", a, b, n1); \
				printf("%s\t%s\t%s\n", b, a, n2); \
			    }' >> $@_tmp; \
		done; \
	done
	@$(YT)sparse2full.py \
	--asymmetric \
	--row-names=$(GENOMES_COMMA) \
	< $@_tmp |\
	$(CMD_SUBSTITUTE) > $@
	@rm -f $@_tmp
	$(EPILOG)

################################################################################################
## print matrix normalized by the number of genes.
orthologs_percent_all_%.matrix:
	$(PRELOG)
	@rm -f $@_tmp
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES) - 1; ++x )); do \
		for (( y = $$x + 1; y < $(PARAM_NUM_GENOMES); ++y )); do \
			genome1=$${genomes[$$x]}; \
			genome2=$${genomes[$$y]}; \
			grep -v "#" $(ANALYSIS_FILE_EXPANSION) |\
			awk '/^[^0-9]/ { a = $$1; b = $$2; next } \
	     		$(ANALYSIS_EXPANSION_SELECT) { \
				n1 += $$7; n2 += $$8; } \
			END { \
			printf("%s\t%s\t%s\n", a, b, n1); \
			printf("%s\t%s\t%s\n", b, a, n2); \
	    		}' >> $@_tmp ; \
		done; \
	done
	@$(YT)sparse2full.py \
	--asymmetric \
	--row-names=$(GENOMES_COMMA) < $@_tmp |\
	$(CMD_SUBSTITUTE) > $@
	@rm -f $@_tmp
	$(EPILOG)

################################################################################################
################################################################################################
################################################################################################
################################################################################################
## Distance plots for orthologs
## Orthologs are taken from the ka assignments.
################################################################################################
ANALYSIS_TARGETS_T92=transcripts_all_t92 transcripts_d4_t92 genes_all_t92 genes_d4_t92 
orthologs-t92-hook:     $(ANALYSIS_TARGETS_T92:%=orthologs_%.dir/stats) \
			$(ANALYSIS_TARGETS_T92:%=orthologs_%.dir/mean.matrix) \
			$(ANALYSIS_TARGETS_T92:%=orthologs_%.dir/median.matrix) \
			$(ANALYSIS_TARGETS_T92:%=orthologs_%.dir/mean.png) \
			$(ANALYSIS_TARGETS_T92:%=orthologs_%.dir/median.png) \
			$(ANALYSIS_TARGETS_T92:%=images.orthologs_%)

ANALYSIS_TARGETS_KS=transcripts_ks genes_ks
orthologs-ks-hook:     $(ANALYSIS_TARGETS_KS:%=orthologs_%.dir/stats) \
			$(ANALYSIS_TARGETS_KS:%=orthologs_%.dir/mean.matrix) \
			$(ANALYSIS_TARGETS_KS:%=orthologs_%.dir/mean.tree) \
			$(ANALYSIS_TARGETS_KS:%=orthologs_%.dir/mean_fitted.tree) \
			$(ANALYSIS_TARGETS_KS:%=orthologs_%.dir/median.matrix) \
			$(ANALYSIS_TARGETS_KS:%=orthologs_%.dir/median.tree) \
			$(ANALYSIS_TARGETS_KS:%=orthologs_%.dir/median_fitted.tree) \
			$(ANALYSIS_TARGETS_KS:%=orthologs_%.dir/mean.png) \
			$(ANALYSIS_TARGETS_KS:%=orthologs_%.dir/median.png) \
			$(ANALYSIS_TARGETS_KS:%=images.orthologs_%)

ANALYSIS_TARGETS_KA=transcripts_ka genes_ka
orthologs-ka-hook:     $(ANALYSIS_TARGETS_KA:%=orthologs_%.dir/stats) \
			$(ANALYSIS_TARGETS_KA:%=orthologs_%.dir/mean.matrix) \
			$(ANALYSIS_TARGETS_KA:%=orthologs_%.dir/mean.tree) \
			$(ANALYSIS_TARGETS_KA:%=orthologs_%.dir/mean_fitted.tree) \
			$(ANALYSIS_TARGETS_KA:%=orthologs_%.dir/median.matrix) \
			$(ANALYSIS_TARGETS_KA:%=orthologs_%.dir/median.tree) \
			$(ANALYSIS_TARGETS_KA:%=orthologs_%.dir/median_fitted.tree) \
			$(ANALYSIS_TARGETS_KA:%=orthologs_%.dir/mean.png) \
			$(ANALYSIS_TARGETS_KA:%=orthologs_%.dir/median.png) \
			$(ANALYSIS_TARGETS_KA:%=images.orthologs_%)


ANALYSIS_TARGETS_KAKS=transcripts_kaks genes_kaks
orthologs-kaks-hook: $(ANALYSIS_TARGETS_KAKS:%=orthologs_%.dir) \
			$(ANALYSIS_TARGETS_KAKS:%=orthologs_%.dir/kaks.tree) 

ANALYSIS_MIN_ALIGNED?=300

################################################################################################
## Set table name to pick up transcripts/genes
orthologs_transcripts_%: ANALYSIS_TABLE_NAME_DISTANCES=$(PARAM_TABLE_NAME_DISTANCES)
orthologs_transcripts_%: ANALYSIS_JOIN_FIELD=prediction_id
orthologs_transcripts_%: EXTRA_SELECT_OPTIONS=d.all_aligned > $(ANALYSIS_MIN_ALIGNED) AND

orthologs_genes_%:       ANALYSIS_TABLE_NAME_DISTANCES=$(PARAM_TABLE_NAME_DISTANCES_GENES)
orthologs_genes_%:       ANALYSIS_JOIN_FIELD=gene_id
orthologs_genes_%:       EXTRA_SELECT_OPTIONS=d.max_aligned > $(ANALYSIS_MIN_ALIGNED) AND


ANALYSIS_ORTHOLOGS_XRANGE=-0.2,5
ANALYSIS_TABLE_NAME_ORTHOLOGS=$(PARAM_TABLE_NAME_ORTHOLOGLINKS)_first

# pattern does not work?
orthologs_transcripts_d4_t92.dir/stats: ANALYSIS_BIN_SIZE=0.02
orthologs_transcripts_all_t92.dir/stats: ANALYSIS_BIN_SIZE=0.02
orthologs_genes_d4_t92.dir/stats: ANALYSIS_BIN_SIZE=0.02
orthologs_genes_all_t92.dir/stats: ANALYSIS_BIN_SIZE=0.02

orthologs_transcripts_ks.dir/stats: ANALYSIS_BIN_SIZE=0.1
orthologs_genes_ks.dir/stats: ANALYSIS_BIN_SIZE=0.1
orthologs_genes_ks.dir/stats: EXTRA_HAVING_OPTIONS+=HAVING AVG(d.$${f})<=$(PARAM_MAX_KS)

images.orthologs_transcripts_ka: ANALYSIS_ORTHOLOGS_XRANGE=-0.1,1.0
images.orthologs_genes_ka: ANALYSIS_ORTHOLOGS_XRANGE=-0.1,1.0

orthologs_transcripts_ka.dir/stats: ANALYSIS_BIN_SIZE=0.02
orthologs_genes_ka.dir/stats: ANALYSIS_BIN_SIZE=0.02

################################################################################################
## Build images for orthologs histograms
images.orthologs_%: orthologs_%.dir/stats
	$(PRELOG)
	@for x in orthologs_$*.dir/*.hist; do \
		$(YT)plot_histogram.py \
		--normalize \
		--hardcopy=$${x}.png \
		--xrange=$(ANALYSIS_ORTHOLOGS_XRANGE) \
		--truncate \
		< $${x}; \
	done
	@touch $@
	$(EPILOG)

################################################################################################
## Calculate histograms and statistics for all pairs.
##
## The data is normalized by cluster, because histone genes might 
## give rise to spurious peaks.
##
## Doing the analysis by transcripts and genes should give similar
## results (depends on how transcript ds's are converted to gene
## ds's)
##
## Only use 1:1 orthologs and below maximum distance of PARAM_MAX_KS

orthologs_%.dir/stats: 
	$(PRELOG)	
	@-mkdir orthologs_$*.dir
	@f=`echo $* | perl -p -e "s/genes_|transcripts_//"`; \
	$(PSQL_CONNECTION) \
		    "SELECT l.schema1, l.schema2, AVG(d.$${f}) AS distance \
	      	    FROM \
			    $(ANALYSIS_TABLE_NAME_ORTHOLOGS) AS l \
		    INNER JOIN \
			    $(ANALYSIS_TABLE_NAME_DISTANCES) AS d \
		    ON      l.$(ANALYSIS_JOIN_FIELD)1 = d.$(ANALYSIS_JOIN_FIELD)1 AND \
			    l.$(ANALYSIS_JOIN_FIELD)2 = d.$(ANALYSIS_JOIN_FIELD)2 AND \
			    l.schema1 = d.schema1 AND \
			    l.schema2 = d.schema2 \
		    WHERE \
			    l.gd1 = 1 AND l.gd2 = 1 AND \
			    d.$${f} > 0 AND d.$${f} != 'NaN' AND \
			    $(EXTRA_SELECT_OPTIONS) \
			    l.schema1 < l.schema2 \
		   GROUP BY \
			    l.schema1, l.schema2, l.cluster_id \
		   $(EXTRA_HAVING_OPTIONS) " \
			    $(PSQL_CONNECTION_OPTIONS) |\
	$(CMD_SUBSTITUTE) |\
	$(YT)graph2histograms.py \
		--output-pattern="orthologs_$*.dir/%s.hist" \
		--output-format="semi" \
		--method="summary,histograms" \
		--bin-size=$(ANALYSIS_BIN_SIZE) \
		--min-value=0.0 \
		--sort="$(NAMES_COMMA)" \
		--no-self > $@

orthologs_%.dir/mean.matrix: orthologs_%.dir/stats
	$(PRELOG)
	@awk '!/^#/ { printf("%s\t%s\t%s\n", $$1, $$2, $$6) }' < $< |\
	$(YT)sparse2full.py \
	--row-names=$(NAMES_COMMA) \
	--col-names=$(NAMES_COMMA) \
	--asymmetric > $@
	$(EPILOG)

orthologs_%.dir/median.matrix: orthologs_%.dir/stats
	$(PRELOG)
	@awk '!/^#/ { printf("%s\t%s\t%s\n", $$1, $$2, $$7) }' < $< |\
	$(YT)sparse2full.py \
	--row-names=$(NAMES_COMMA) \
	--col-names=$(NAMES_COMMA) \
	--asymmetric > $@
	$(EPILOG)

#######################################################################################################
#######################################################################################################
#######################################################################################################
##
## Build kaks tree
##
## Use the fitted trees so that they are guaranteed to be congruent.
#######################################################################################################
orthologs_%_kaks.dir/kaks.tree: orthologs_%_ka.dir/median_fitted.tree orthologs_%_ks.dir/median_fitted.tree
	$(PRELOG)
	@$(YT)tree2tree.py \
		--filename-tree2=orthologs_$*_ks.dir/median_fitted.tree \
		--method=divide-by-tree \
	< $< > $@
	$(EPILOG)

#######################################################################################################
#######################################################################################################
#######################################################################################################
## Build a tree from a matrix with FITCH
#######################################################################################################
%.tree: %.matrix
	$(PRELOG)
	@$(YT)sparse2full.py \
		--verbose=0 \
		--full2sparse \
	< $< | grep -v "row" |\
	tree_fitch > $@
	$(EPILOG)

#######################################################################################################
#######################################################################################################
#######################################################################################################
## Build a tree from a matrix with FITCH
#######################################################################################################
%_fitted.tree: %.matrix
	$(PRELOG)
	@$(YT)matrix2matrix.py \
		--output-format=phylip \
		--verbose=0 \
		< $< |\
	$(YT)matrix2tree.py \
		--filename-tree=<(echo "$(PARAM_SPECIES_TREE)") \
		--method=fitch \
	> $@
	$(EPILOG)


#######################################################################################################
#######################################################################################################
#######################################################################################################
#######################################################################################################
## Analysis of orphans
#######################################################################################################
ANALYSIS_QUERIES_ORPHANS=counts percent
ANALYSIS_TARGETS_ORPHANS=$(ANALYSIS_QUERIES_ORPHANS:%=orphans_%_step1.matrix) $(ANALYSIS_QUERIES_ORPHANS:%=orphans_%_step2.matrix)

ANALYSIS_ORPHANS_IMAGES_SRC=$(wildcard orphans_counts*.matrix) \
				$(wildcard orphans_percent*.matrix) 

orphans-counts-hook: $(ANALYSIS_TARGETS_ORPHANS) 
orphans-counts-images: $(ANALYSIS_ORPHANS_IMAGES_SRC:%.matrix=%.png) 

orphans_counts_step1.matrix: ANALYSIS_FILE_INPUT=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step5.dir/step5_input.stats
orphans_counts_step2.matrix: ANALYSIS_FILE_INPUT=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step10.dir/step10_input.stats

orphans_percent_step1.matrix: ANALYSIS_FILE_INPUT=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step5.dir/step5_input.stats
orphans_percent_step2.matrix: ANALYSIS_FILE_INPUT=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step10.dir/step10_input.stats

#######################################################################################################
## Total counts of orphans
orphans_counts_%.matrix:
	$(PRELOG)
	@rm -f $@_tmp
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES) - 1; ++x )); do \
		for (( y = $$x + 1; y < $(PARAM_NUM_GENOMES); ++y )); do \
			genome1=$${genomes[$$x]}; \
			genome2=$${genomes[$$y]}; \
			grep -v "#" $(ANALYSIS_FILE_INPUT) |\
			awk '/^[^0-9]/ { a = $$1; b= $$2; } \
	    		/genes without assigned orthology/ \
			{ printf("%s\t%s\t%s\n", a, b, $$1); \
			  printf("%s\t%s\t%s\n", b, a, $$2); \
			}' >> $@_tmp; \
		done; \
	done
	@$(YT)sparse2full.py \
	--row-names=$(GENOMES_COMMA) \
	--col-names=$(GENOMES_COMMA) \
	--asymmetric < $@_tmp |\
	$(CMD_SUBSTITUTE) > $@
	@rm -f $@_tmp
	$(EPILOG)

#######################################################################################################
## Orphans normalized by the number of genes
orphans_percent_%.matrix:
	$(PRELOG)
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES) - 1; ++x )); do \
		for (( y = $$x + 1; y < $(PARAM_NUM_GENOMES); ++y )); do \
			genome1=$${genomes[$$x]}; \
			genome2=$${genomes[$$y]}; \
			grep -v "#" $(ANALYSIS_FILE_INPUT) |\
			awk '/^[^0-9]/ { a = $$1; b= $$2; } \
			    /genes without assigned orthology/ \
				{ printf("%s\t%s\t%s\n", a, b, $$3); \
				  printf("%s\t%s\t%s\n", b, a, $$4); \
				}' >> $@_tmp; \
		done; \
	done
	@$(YT)sparse2full.py \
	--row-names=$(GENOMES_COMMA) \
	--col-names=$(GENOMES_COMMA) \
	--asymmetric < $@_tmp |\
	$(CMD_SUBSTITUTE) > $@
	@rm -f $@_tmp
	$(EPILOG)

#######################################################################################################
#######################################################################################################
#######################################################################################################
#######################################################################################################
## Analysis of orphans in 
#######################################################################################################
master-orphans-hook: master_orphans.dir master_orphans.dir/lists

master_orphans.dir/lists:
	$(PRELOG)
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 1; x < $(PARAM_NUM_GENOMES); ++x )); do \
		genome=$${genomes[$$x]}; \
		$(PSQL_CONNECTION) \
		"SELECT query_token, rep_token, l.* \
	      	 FROM \
			$(PARAM_GENOME_MASTER).queries AS q \
		 LEFT JOIN \
			$(ANALYSIS_TABLE_NAME_ORTHOLOGS) AS l \
		 ON q.query_token = l.prediction_id1 AND \
		    l.schema1 = '$(PARAM_GENOME_MASTER)' AND \
		    l.schema2 = '$${genome}' \
		 WHERE \
		    l.cluster_id IS NULL;" \
		$(PSQL_CONNECTION_OPTIONS); \
	done
	$(EPILOG)

#######################################################################################################
#######################################################################################################
#######################################################################################################
#######################################################################################################
## Analysis of orphans that are shared between two species (in comparison to D. melanogaster).
#######################################################################################################
orphans-common-hook: full_orphans.counts

#######################################################################################################
## Collect all stages for all genes
traces.list:
	$(PRELOG)
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES) - 1; ++x )); do \
		for (( y = $$x + 1; y < $(PARAM_NUM_GENOMES); ++y )); do \
			genome1=$${genomes[$$x]}; \
			genome2=$${genomes[$$y]}; \
			file=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step11_$${genome1}.trace; \
			$(YT)csv_cut.py -v 0 gene stage < $${file} |\
			awk -v genome=$${genome2} '/orthologs1/ {next;} /^gene/ {printf("gene\t%s\n", genome); next} {print;}' > $@.tmp_$${x}_$${y}; \
			file=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step11_$${genome2}.trace; \
			$(YT)csv_cut.py -v 0 gene stage < $${file} |\
			awk -v genome=$${genome1} '/orthologs1/ {next}; /^gene/ {printf("gene\t%s\n", genome); next} {print;}' > $@.tmp_$${y}_$${x}; \
		done; \
	done; \
	for (( x = 0; x < $(PARAM_NUM_GENOMES); ++x )); do \
		genome=$${genomes[$$x]}; \
		$(YT)combine_tables.py $@.tmp_$${x}_* > $@_$${genome} ; \
	done
	@rm -f $@.tmp*
	@touch $@
	$(EPILOG)	

#######################################################################################################
#######################################################################################################
#######################################################################################################
## Write counts of completely orphaned sequences, i.e. those without any
## any ortholog in any of the other species.
#######################################################################################################
full_orphans.counts: traces.list
	$(PRELOG)
	@rm -f $@_tmp
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	printf "schema\tntotal\tnorthos\tporthos\tnorphaned\tporphans\n" > $@; \
	for (( x = 0; x < $(PARAM_NUM_GENOMES); ++x )); do \
		genome=$${genomes[$$x]}; \
		awk -v genome=$${genome} \
			'/^#/ {next;} \
			{ntotal+=1; keep=0;for(x=2;x<=NF;++x){if($$x>=6){keep=1}}; if(keep){northos+=1} else { norphans+=1;}} \
		    	END { printf("%s\t%i\t%i\t%5.2f\t%i\t%5.2f\n",genome,ntotal,northos,100*northos/ntotal,norphans,100*norphans/ntotal); }' \
		< $<_$${genome} >> $@; \
	done
	$(EPILOG)

#######################################################################################################
#######################################################################################################
#######################################################################################################
## get a list of shared orphans
#######################################################################################################
master_common_orphans_%.list: master_orphans_%.list
	$(PRELOG)
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES); ++x )); do \
		genome=$${genomes[$$x]} ; \
		printf "gene\t%s\n" $${genome} > $@_tmp_$${genome}; \
		awk -v g=$${genome} '!/^#/ && $$2 == g {split($$1, a, "$(PARAM_SEPARATOR)");printf("%s\t%s\n",  a[3], g); }' \
		< $< >> $@_tmp_$${genome}; \
	done
	@$(YT)combine_tables.py \
	--missing="na" \
	$@_tmp_* > $@
	@rm -f $@_tmp_*
	$(EPILOG)

## list of queries which are always orphans
orphans_shared.list: orphans_common.list
	 grep -v -e "#" -e "na" orphans_common.list | cut -f 1 > $@

## get missed orphans due to missed class
orphans_missed_class:
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES); ++x )); do \
		genome1=dmel_vs_dmel; \
		genome2=$${genomes[$$x]} ; \
		awk -v genome1=$${genome1} -v genome2=$${genome2} \
		     '/^# summary/ { keep = 1; next;} \
		      /^# ninput/ { keep = 0; next; } \
		        keep { print; split($$0, a, " " ); \
		      	printf ("%s\t%s\t%i\t%s\t%s\n", genome1, genome2, a[3], a[4], a[5]); } ' \
		    < $(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step5.dir/step5_orphans.stats; \
	done

#		`grep "# missed-class" pair_$${genome1}-$${genome2}/step5.dir/step5_orphans.stats |\
#		perl -p -e "s/.*\'all\': (\d+).*/\1/"`; \


#######################################################################################################
## Analysis of specific families

## Get gene orthologs for a list of _dmel_ identifiers
%.get-gene-ks_orthologs: % 
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	(for (( x = 0; x < $(PARAM_NUM_GENOMES); ++x )); do \
		genome1=$(PARAM_GENOME_MASTER); \
		genome2=$${genomes[$$x]} ; \
		if [ "$${genome1}" != "$${genome2}" ]; then \
			awk -v g=$${genome2} '$$2 == "gene" { printf("%s\t%s\t%s\n", $$3, g, $$4); }' \
			< $(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step10.dir/step10_orthologs.stats |\
			grep -f $*; \
		fi; \
	done) |\
	$(YT)sparse2full.py \
	--asymmetric \
	--col-names=$(GENOMES_COMMA) |\
	$(CMD_SUBSTITUTE) 

## Get gene orthologs for a list of _dmel_ identifiers
%.get-gene-ka_orthologs: % 
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	(for (( x = 0; x < $(PARAM_NUM_GENOMES); ++x )); do \
		genome1=$(PARAM_GENOME_MASTER); \
		genome2=$${genomes[$$x]} ; \
		if [ "$${genome1}" != "$${genome2}" ]; then \
			awk -v g=$${genome2} '$$2 == "gene" { printf("%s\t%s\t%s\n", $$3, g, $$4); }' \
			< $(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step5.dir/step5_orthologs.stats |\
			grep -f $*; \
		fi; \
	done) |\
	$(YT)sparse2full.py \
	--asymmetric \
	--col-names=$(GENOMES_COMMA) |\
	$(CMD_SUBSTITUTE) 

################################################################################################
## Calculate GO. Background frequencies are all for which there is orthology information.
## The foreground set is added to the background set in order to make sure that all goids are
## present in the background set. Redundancy in the gene lists is removed by the script.
## This routine can used for any gene lists. First field is master gene, second field is species.
master_%.go: master_%.list $(ANALYSIS_GO_BACKGROUND)
	$(PRELOG)
	@-mkdir $@.dir
	@python $(DIR_SCRIPTS_GENEPREDICTION)runGO.py \
			    --user=andreas \
			    --password=HeinBloed \
			    --database=$(PARAM_ANALYSIS_GO_ENSEMBL) \
			    --filename-dump=$@_go > /dev/null
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	rm -f $@_fg $@_bg; \
	for (( x = 0; x < $(PARAM_NUM_GENOMES); ++x )); do \
		genome2=$${genomes[$$x]} ; \
		if [ "$${genome2}" != "$(PARAM_GENOME_MASTER)" ]; then \
		    $(CMD_LOG2) "building foreground."; \
		    grep "$${genome2}" master_$*.list |\
			    cut -f 1 |\
			    awk 'BEGIN { FS="|";} { printf("%s\n", $$2); }' |\
			    perl -p -e "s/-..//" | sort | uniq > $@_fg_tmp; \
		    $(CMD_LOG2) "building background."; \
		    grep "$${genome2}" $(ANALYSIS_GO_BACKGROUND) |\
			    cut -f 1 |\
			    perl -p -e "s/-..//" | sort | uniq > $@_bg_tmp; \
		    cat $@_fg_tmp >> $@_bg_tmp; \
		    nfg=`wc -l < $@_fg_tmp`; \
		    $(CMD_LOG2) "starting GO analysis: fg=$${nfg} bg=`wc -l < $@_bg_tmp`."; \
		    if [[ $${nfg} > 0 ]]; then \
			python $(DIR_SCRIPTS_GENEPREDICTION)runGO.py \
				--genes=$@_fg_tmp \
				--background=$@_bg_tmp \
				--user=andreas \
				--password=HeinBloed \
				--database=$(PARAM_ANALYSIS_GO_ENSEMBL) \
				--threshold=$(PARAM_ANALYSIS_GO_THRESHOLD) \
				--filename-input=$@_go \
				--fdr \
				--sample=$(PARAM_ANALYSIS_GO_SAMPLES) \
				--slims=$(PARAM_ANALYSIS_GO_SLIMS)  \
				--filename-output-pattern="$@.dir/$${genome2}_%(go)s_%(section)s" \
		    	> $@.dir/$${genome2}.log; \
		    fi; \
		    cat $@_fg_tmp >> $@_fg; \
		    cat $@_bg_tmp >> $@_bg; \
		    rm -f $@_fg_tmp $@_bg_tmp; \
		else \
			$(CMD_LOG2) "empty set - no GO calculated"; \
		fi; \
	done; \
	sort < $@_fg | uniq > $@_tmp; mv $@_tmp $@_fg; \
	sort < $@_bg | uniq > $@_tmp; mv $@_tmp $@_bg; \
	nfg=`wc -l < $@_fg`; \
	$(CMD_LOG2) "starting GO analysis: fg=$${nfg} bg=`wc -l < $@_bg`."; \
	if [[ $${nfg} > 0 ]]; then \
	    python $(DIR_SCRIPTS_GENEPREDICTION)runGO.py \
		    --genes=$@_fg \
		    --background=$@_bg \
		    --user=andreas \
		    --password=HeinBloed \
		    --database=$(PARAM_ANALYSIS_GO_ENSEMBL) \
		    --threshold=$(PARAM_ANALYSIS_GO_THRESHOLD) \
		    --filename-input=$@_go \
		    --fdr \
		    --sample=$(PARAM_ANALYSIS_GO_SAMPLES) \
		    --slims=$(PARAM_ANALYSIS_GO_SLIMS) \
		    --filename-output-pattern="$@.dir/all_%(go)s_%(section)s" \
	    > $@.dir/all.log; \
	else \
		$(CMD_LOG2) "empty set - no GO calculated"; \
	fi; 
	@touch $@
	@rm -f $@_fg $@_bg $@_go 
	$(EPILOG)

master_%.xgo: master_%.list $(ANALYSIS_GO_BACKGROUND)
	@-mkdir $@.dir
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	rm -f $@_fg $@_bg; \
	for (( x = 0; x < $(PARAM_NUM_GENOMES); ++x )); do \
		genome2=$${genomes[$$x]} ; \
		if [ "$${genome2}" != "$(PARAM_GENOME_MASTER)" ]; then \
		    grep "$${genome2}" master_$*.list |\
			    cut -f 1 |\
			    awk 'BEGIN { FS="|";} { printf("%s\n", $$2); }' |\
			    perl -p -e "s/-..//" | sort | uniq > $@_fg_tmp; \
		    grep "$${genome2}" $(ANALYSIS_GO_BACKGROUND) |\
			    cut -f 1 |\
			    perl -p -e "s/-..//" | sort | uniq > $@_bg_tmp; \
		    cat $@_fg_tmp >> $@_bg_tmp; \
		    nfg=`wc -l < $@_fg_tmp`; \
		    cat $@_fg_tmp >> $@_fg; \
		    cat $@_bg_tmp >> $@_bg; \
		    rm -f $@_fg_tmp $@_bg_tmp; \
		fi; \
	done; \
	sort < $@_fg | uniq > $@_tmp; mv $@_tmp $@_fg; \
	sort < $@_bg | uniq > $@_tmp; mv $@_tmp $@_bg; \


################################################################################################
master_%.go.eps: master_%.go
	$(PRELOG)
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for category in $(PARAM_ANALYSIS_GO_CATEGORIES); do \
	    $(YT)go2plot.py \
	    --verbose=0 \
	    --headers \
	    --pattern-filename="master_$*.go.dir/%s_$${category}_results" \
	    --title="$(PARAM_PROJECT_NAME): over/under-represented GO-categories [$${category}]" \
	    --footer="$@" \
	    all $(PARAM_SORTED_SCHEMAS) > master_$*.go.dir/$${category}.eps; \
	    rm -f $@_tmp*; \
	done
	@touch $@
	$(EPILOG)

################################################################################################
master_%.go.svg: master_%.go
	$(PRELOG)
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for category in $(PARAM_ANALYSIS_GO_CATEGORIES); do \
	    $(YT)go2svg.py \
	    --verbose=0 \
	    --headers \
	    --pattern-filename="master_$*.go.dir/%s_$${category}_results" \
	    --title="$(PARAM_PROJECT_NAME): $*: [$${category}]" \
	    --footer="$@" \
	    $(PARAM_SORTED_SCHEMAS) |\
	    $(CMD_TRANSLATE) > master_$*.go.dir/$${category}.svg; \
	    rm -f $@_tmp*; \
	done
	@touch $@
	$(EPILOG)

################################################################################################
## extract the GO counting information for all runs in order to check, if the sample sizes
## are large enough.
master_%.go.counts: master_%.go
	$(PRELOG)
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for category in $(PARAM_ANALYSIS_GO_CATEGORIES); do \
	    rm -f $@_tmp; \
	    for genome in $(PARAM_SORTED_SCHEMAS) all; do \
		    if test -e master_$*.go.dir/$${genome}_$${category}_parameters; then \
		    	cat master_$*.go.dir/$${genome}_$${category}_parameters |\
		    	awk -v genome=$${genome} 'BEGIN { FS="\t"; } !/^#/ { printf("%s\t%s\t%s\n", genome, $$2, $$1); }' \
		    	>> $@_tmp; \
		    fi; \
	    done; \
	    grep -v "parameter" < $@_tmp |\
	    $(YT)sparse2full.py \
	   	--row-names=all,$(GENOMES_COMMA) --asymmetric |\
	    $(CMD_SUBSTITUTE) |\
	    $(YT)csv_cut.py \
		"" \
		"genes in sample with GO assignments" \
		"genes in sample" \
		"percent genes in sample with GO assignments" \
		"genes in background with GO assignments"\
		"input background"\
		"percent genes background with GO assignments" \
		"significant results reported" \
		> master_$*.go.dir/$${category}.counts; \
	done
	@touch $@
	@rm -f $@_tmp;
	$(EPILOG)

################################################################################################
## Build a matrix of a gene list.
master_%.matrix: master_%.list
	$(PRELOG)
	awk '{printf("%s\t%s\t1\n", $$1, $$2); }' < master_$*.list |\
	$(YT)sparse2full.py \
	--asymmetric \
	--col-names="$(GENOMES_COMMA)" \
	> $@
	$(EPILOG)

################################################################################################
## Retrieve peptide sequences of master genes 
## TODO: fix the gene2transcript mapping for ks based duplications!!!
master_%.fasta: master_%.list
	$(PRELOG)
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES); ++x )); do \
		genome1=$(PARAM_GENOME_MASTER); \
		genome2=$${genomes[$$x]} ; \
		perl $(DIR_SCRIPTS_GENEPREDICTION)extract_fasta.pl \
		<( grep "$${genome2}" master_duplications_$*.list | cut -f 1) \
		< $(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/peptides1.fasta > $@_$${genome2}; \
	done
	$(EPILOG)


################################################################################################
################################################################################################
################################################################################################
################################################################################################
## Saturation plots for orthologs
################################################################################################
ANALYSIS_SATURATION_TARGETS=genes transcripts
saturation-hook: $(ANALYSIS_SATURATION_TARGETS:%=saturation_%) 

## Minimum aligned positions for alignments to be considered for 
## saturation analysis.
ANALYSIS_SATURATION_MIN_ALIGNED?=300

################################################################################################
################################################################################################
################################################################################################
## Transition/transversion ratio for all and d4 positions for all orthologous transcripts.
## The averages per gene and the total is returned.
## Note: the ortholog graph is redundant for genes, thus I need to group and can't use global
## aggregate functions.
################################################################################################
saturation_transcripts: ANALYSIS_TABLE_NAME_DISTANCES=$(PARAM_TABLE_NAME_DISTANCES)
saturation_transcripts: ANALYSIS_JOIN_FIELD=prediction_id
saturation_genes:       ANALYSIS_TABLE_NAME_DISTANCES=$(PARAM_TABLE_NAME_DISTANCES_GENES)
saturation_genes:       ANALYSIS_JOIN_FIELD=gene_id

ANALYSIS_SATURATION_BINSIZE=0.01
ANALYSIS_SATURATION_CATEGORIES=all_ratio d4_ratio all_ti all_tv d4_ti d4_tv

saturation_%:
	$(PRELOG)
	@-mkdir $@.dir
	@if test ! -e $@.dir/data; then \
	    $(PSQL_CONNECTION) \
			"SELECT d.schema1, d.schema2, \
				CAST(d.all_transitions AS FLOAT) / CAST(d.all_transversions AS FLOAT), \
				CAST(d.d4_transitions AS FLOAT) / CAST(d.d4_transversions AS FLOAT), \
				CAST(d.all_transitions AS FLOAT) / CAST(d.all_aligned AS FLOAT), \
				CAST(d.all_transversions AS FLOAT) / CAST(d.all_aligned AS FLOAT), \
				CAST(d.d4_transitions AS FLOAT) / CAST(d.d4_aligned AS FLOAT), \
				CAST(d.d4_transversions AS FLOAT) / CAST(d.d4_aligned AS FLOAT) \
			FROM \
				$(PARAM_TABLE_NAME_ORTHOLOGLINKS) AS l \
			INNER JOIN \
				$(ANALYSIS_TABLE_NAME_DISTANCES) AS d \
			ON   l.$(ANALYSIS_JOIN_FIELD)1 = d.$(ANALYSIS_JOIN_FIELD)1 AND \
			     l.$(ANALYSIS_JOIN_FIELD)2 = d.$(ANALYSIS_JOIN_FIELD)2 AND \
			     l.schema1 = d.schema1 AND \
			     l.schema2 = d.schema2 \
			WHERE \
				l.schema1 > l.schema2 AND \
				d.all_transversions > 0 AND \
				d.d4_transversions > 0 AND \
				d.all_aligned > $(ANALYSIS_SATURATION_MIN_ALIGNED) \
			GROUP BY d.schema1, d.schema2, \
				d.$(ANALYSIS_JOIN_FIELD)1, d.$(ANALYSIS_JOIN_FIELD)2, \
				d.all_transitions, d.all_transversions, d.all_aligned, \
				d.d4_transitions,  d.d4_transversions,  d.d4_aligned" \
	    $(PSQL_CONNECTION_OPTIONS) > $@.dir/data; \
	fi
	@categories=( $(ANALYSIS_SATURATION_CATEGORIES) ); \
	for (( x = 0, y = 3; x < 6; ++x, ++y)) ; do \
		prefix=$${categories[$$x]}; \
		if test ! -e $@.dir/$${prefix}.stats; then \
		    cut -f 1,2,$${y} $@.dir/data |\
		    $(YT)graph2histograms.py \
			--output-pattern="$@.dir/$${prefix}_%s.hist" \
			--output-format="semi" \
			--method="summary,histograms" \
			--bin-size=$(ANALYSIS_SATURATION_BIN_SIZE) \
			--min-value=0.0 \
			--sort="$(GENOMES_COMMA)" \
			--no-self |\
		    $(CMD_SUBSTITUTE) > $@.dir/$${prefix}.stats; \
		fi; \
	done; \
	for (( x = 0; x < 6; ++x)) ; do \
		prefix=$${categories[$$x]}; \
		for method in mean median; do \
			$(YT)csv_cut.py token1 token2 $${method} < $@.dir/$${prefix}.stats |\
			$(YT)sparse2full.py \
			--row-names=$(NAMES_COMMA) \
			--col-names=$(NAMES_COMMA) \
		> $@.dir/$${prefix}_$${method}.matrix; \
		done; \
	done
	@touch $@
	$(EPILOG)

#########################################################################
#########################################################################
#########################################################################
#########################################################################
## Analyse consistency
#########################################################################
ANALYSIS_CONSISTENCY_STEPS=first second

consistency.dir/consistency_first_%.stats: ANALYSIS_CONSISTENCY_LINKS=$(PARAM_DIR_SRC)orthologs_first.links.gz
consistency.dir/consistency_second_%.stats: ANALYSIS_CONSISTENCY_LINKS=$(PARAM_DIR_SRC)orthologs_second.links.gz
consistency.dir/consistency_counts.matrix: ANALYSIS_CONSISTENCY_LINKS=$(PARAM_DIR_SRC)orthologs_first.links.gz

consistency-hook: consistency.dir \
	$(ANALYSIS_CONSISTENCY_STEPS:%=consistency.dir/consistency_%_genes.stats) 

#########################################################################
#########################################################################
#########################################################################
#########################################################################
## get consistency by transcripts
#########################################################################
consistency.dir/consistency_%_transcripts.stats:
	$(PRELOG)
	@gunzip < $(ANALYSIS_CONSISTENCY_LINKS) |\
	awk '{  split($$1, a, "$(PARAM_SEPARATOR)"); \
		split($$2, b, "$(PARAM_SEPARATOR)"); \
		if (a[1] == b[1]) next; \
		printf("%s\t%s\t%s\n", $$1, $$2, $$6); }' |\
	$(YT)graph_check_transitivity.py \
	--use-subsets \
	--filename-missing=$@_missing > $@
	$(EPILOG)

#########################################################################
#########################################################################
#########################################################################
#########################################################################
## get consistency by genes
## remove internal links, because they cause over-counting
## in case of large duplicated clusters.
## Also, only count one link per cluster.
#########################################################################
consistency.dir/consistency_%_genes.stats:
	$(PRELOG)
	@gunzip < $(ANALYSIS_CONSISTENCY_LINKS) |\
	awk '{  split($$1, a, "$(PARAM_SEPARATOR)"); \
		split($$2, b, "$(PARAM_SEPARATOR)"); \
		if (a[1] == b[1]) next; \
		printf("%s%s%s\t%s%s%s\t%s\n", \
		a[1], "$(PARAM_SEPARATOR)", a[3], \
		b[1], "$(PARAM_SEPARATOR)", b[3], \
		$$6); }' |\
	sort | uniq |\
	$(YT)graph_check_transitivity.py \
	--use-subsets \
	--filename-found=$@_found \
	--filename-missing=$@_missing > $@
	$(EPILOG)

consistency.dir/consistency_%.matrix: consistency.dir/consistency_%.stats
	$(PRELOG)
	@cut -f 1,3 consistency.dir/consistency_$*.stats_missing |\
	sort | uniq |\
	perl -p -e "s/[$(PARAM_SEPARATOR)]\S+//g;" |\
	awk '$$1 < $$2 { printf("%s\t%s\n", $$1, $$2); next } { printf("%s\t%s\n", $$2, $$1);}' |\
	$(YT)graph2stats.py --method=counts  |\
	$(YT)sparse2full.py \
	--row-names=$(GENOMES_COMMA) \
	--col-names=$(GENOMES_COMMA) |\
	$(CMD_TRANSLATE) > $@
	$(EPILOG)

## Matrix to use for normalization. This is the number of orhtolog ids
## between each pair of species.
consistency.dir/consistency_counts.matrix: 
	$(PRELOG)
	@gunzip < $(ANALYSIS_CONSISTENCY_LINKS) |\
	awk '{  split($$1, a, "$(PARAM_SEPARATOR)"); \
		split($$2, b, "$(PARAM_SEPARATOR)"); \
		if (a[1] == b[1]) next; \
		printf("%s\t%s\t%s\n", a[1], b[1], $$6); }' |\
	$(YT)graph2stats.py --method=counts |\
	$(YT)sparse2full.py \
	--row-names=$(GENOMES_COMMA) \
	--col-names=$(GENOMES_COMMA) |\
	$(CMD_TRANSLATE) > $@
	$(EPILOG)

#########################################################################
#########################################################################
#########################################################################
#########################################################################
## Matrix to use for normalization. This is the number of ortholog ids
## between each pair of species.
consistency.dir/consistency_counts_%.matrix: 
	$(PRELOG)
	@perl -p -e "s/[$(PARAM_SEPARATOR)]\S+//g;" < consistency.dir/consistency_$*.stats_found |\
	cut -f 1,3 |\
	$(YT)graph2stats.py --method=counts |\
	$(YT)sparse2full.py \
	--row-names=$(GENOMES_COMMA) \
	--col-names=$(GENOMES_COMMA) |\
	$(CMD_TRANSLATE) > $@
	$(EPILOG)

#########################################################################
#########################################################################
#########################################################################
#########################################################################
## Note: it would be better to take dmel orthologs?
## Queries for genes which are inconsistent
## Note: this is fly specific hack
consistency.dir/consistency_out:
	$(PRELOG)
	@awk '{  printf("%s\n%s\n%s\n", $$1, $$2, $$3) }' < consistency.dir/consistency_first_genes.stats_missing |\
	sort | uniq |\
	awk '{ split( $$1, a, "$(PARAM_SEPARATOR)"); \
	       printf("SELECT q.rep_token FROM %s.predictions AS p, %s.queries AS q WHERE q.query_token = p.query_token AND prediction_id = %i;\n", a[1], a[1], a[2]); }' > $@_tmp
	@$(PSQL_CONNECTION_BATCH) $@_tmp $(PSQL_CONNECTION_OPTIONS) | sort | uniq > $@_tmp2
	awk 'BEGIN { while (getline < "$@_tmp2") { found[$$1] = 1; } } $$2 in found' < ../../../data_1v5/interpro.list > $@_tmp3
	sort -k4,4 $@_tmp3 | cut -f 4,5,6 | uniq -c | awk '{printf("%s\t%s\t%s\t%s\n", $$1, $$2, $$3, $$4);}' | sort -k1,1n > $@_interpro
	awk 'BEGIN { while (getline < "$@_tmp2") { found[$$1] = 1; } } $$2 in found' < ../../../data_1v5/lowcomplexity.list > $@_tmp4
	sort -k4,4 $@_tmp4 | cut -f 4 | uniq -c | awk '{printf("%s\t%s\n", $$1, $$2);}' | sort -k1,1n > $@_lowcomplexity
	$(EPILOG)

##############################################################################
##############################################################################
##############################################################################
##############################################################################
## calculate cluster separation using scaled bitscores
##############################################################################
COLUMN_SCORE=3
ANALYSIS_SEPARATION_MAX_LINKS=1000000
ANALYSIS_SEPARATION_FILES_WITHIN= $(PARAM_SRC_SCHEMAS:%=separation_$*.dir/within_$${genome1}-%_total.hists)
ANALYSIS_SEPARATION_FILES_BETWEEN=$(PARAM_SRC_SCHEMAS:%=separation_$*.dir/between_$${genome1}-%_total.hists)
separation_all: ANALYSIS_SEPARATION_FILE=step2.scaled.links.gz
separation_seed: ANALYSIS_SEPARATION_FILE=step2.seed.links
separation_all: ANALYSIS_SEPARATION_CMD=gunzip
separation_seed: ANALYSIS_SEPARATION_CMD=cat

separation_%:
	$(PRELOG)
	@if [ ! -e $@.dir ]; then \
		mkdir $@.dir; \
		$(CMD_LOG2) "collecting data"; \
	fi
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES) - 1; ++x )); do \
	    for (( y = $$x + 1; y < $(PARAM_NUM_GENOMES); ++y )); do \
		    for method in within between; do \
			genome1=$${genomes[$$x]}; \
			genome2=$${genomes[$$y]}; \
			if [ ! -e $@.dir/$${method}_$${genome1}-$${genome2}.log ]; then \
			    if [ -e $(PARAM_DIR_SRC)/pair_$${genome1}-$${genome2} ]; then \
				    links_file=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/$(ANALYSIS_SEPARATION_FILE); \
				    components_file=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step3.dir/components; \
			    else \
				    links_file=$(PARAM_DIR_SRC)pair_$${genome2}-$${genome1}/$(ANALYSIS_SEPARATION_FILE); \
				    components_file=$(PARAM_DIR_SRC)pair_$${genome1}-$${genome2}/step3.dir/components; \
			    fi; \
			    $(ANALYSIS_SEPARATION_CMD) < $${links_file} |\
			    head -n $(ANALYSIS_SEPARATION_MAX_LINKS) |\
			    python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_clustering.py \
				--pattern=$@.dir/$${method}_$${genome1}-$${genome2}_%s.%s \
				--methods=hists,stats \
				--map=$${components_file} \
				--columns=$(COLUMN_SCORE) \
				--only-total \
				--$${method}-clusters \
				--minbin=0.0 --maxbin=1.0 --binsize=0.01 \
			    > $@.dir/$${method}_$${genome1}-$${genome2}.log; \
			fi; \
		   done; \
	      done; \
	done; \
	for (( x = 0; x < $(PARAM_NUM_GENOMES) - 1; ++x )); do \
	    for (( y = $$x + 1; y < $(PARAM_NUM_GENOMES); ++y )); do \
		genome1=$${genomes[$$x]}; \
		genome2=$${genomes[$$y]}; \
	     	python $(DIR_SCRIPTS_TOOLS)combine_histograms.py \
			separation_$*.dir/within_$${genome1}-$${genome2}_total.hists \
			separation_$*.dir/between_$${genome1}-$${genome2}_total.hists |\
		$(CMD_TRANSLATE) \
		> separation_$*.dir/combined_$${genome1}-$${genome2}.hist; \
	    done; \
	done; \
	for (( x = 0; x < $(PARAM_NUM_GENOMES) - 1; ++x )); do \
	    for (( y = $$x + 1; y < $(PARAM_NUM_GENOMES); ++y )); do \
		genome1=$${genomes[$$x]}; \
	     	python $(DIR_SCRIPTS_TOOLS)combine_histograms.py \
		--headers=bin,$(GENOMES_COMMA) \
		$(ANALYSIS_SEPARATION_FILES_WITHIN) |\
		$(CMD_TRANSLATE) \
		> separation_$*.dir/within_$${genome1}_total.hist; \
	     	python $(DIR_SCRIPTS_TOOLS)combine_histograms.py \
		--headers=bin,$(GENOMES_COMMA) \
		$(ANALYSIS_SEPARATION_FILES_BETWEEN) |\
		$(CMD_TRANSLATE) \
		> separation_$*.dir/between_$${genome1}_total.hist; \
	    done; \
	done
	@touch $@
	$(EPILOG)

ANALYSIS_SEPARATION_XRANGE=0,1
images.separation_seed: ANALYSIS_SEPARATION_XRANGE=0,0.8

images.separation_%: separation_%
	python $(DIR_SCRIPTS_TOOLS)combine_histograms.py \
		separation_$*.dir/within_total.hists \
		separation_$*.dir/between_total.hists |\
	python $(DIR_SCRIPTS_TOOLS)plot_histogram.py \
		--legend=bin,within,between \
		--normalize \
		--xrange=$(ANALYSIS_SEPARATION_XRANGE) \
		--truncate \
		--hardcopy=separation_$*.dir/totals.png	

##############################################################################
##############################################################################
##############################################################################
##############################################################################
## check for ortholgs for each entry in GENOME_MASTER
##############################################################################
master_orthologs-hook: master_orthologs

master_orthologs:
	$(PRELOG)
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES); ++x )); do \
		genome=$${genomes[$$x]}; \
		printf "query\tngenes_%s\tnpreds_%s\n" \
			$${genome} $${genome} > $@_tmp_$${genome}; \
		$(PSQL_CONNECTION) \
		    "SELECT l.gene_id1, \
			COUNT(DISTINCT l.gene_id2), \
			COUNT(DISTINCT l.prediction_id2) \
	      	    FROM \
			    $(ANALYSIS_TABLE_NAME_ORTHOLOGS) AS l \
		    WHERE \
			l.schema1 = '$(PARAM_GENOME_MASTER)' AND\
			l.schema2 = '$${genome}' \
		   GROUP BY \
			    l.schema1, l.gene_id1, l.schema2" \
		$(PSQL_CONNECTION_OPTIONS) >> $@_tmp_$${genome}; \
	done; 
	@python $(DIR_SCRIPTS_TOOLS)combine_tables.py \
		--missing="0" \
		$@_tmp_* > $@;
	$(EPILOG)
#########################################################################
include $(DIR_SCRIPTS_GENEPREDICTION)/makefiles/Makefile.common
