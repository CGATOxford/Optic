################################################################################
#   Gene prediction pipeline 
#
#   $Id: Makefile.orthology_pairwise_multiple 2781 2009-09-10 11:33:14Z andreas $
#
#   Copyright (C) 2004 Andreas Heger
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License
#   as published by the Free Software Foundation; either version 2
#   of the License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#################################################################################
##
## Multiple pairwise orthology prediction
##
################################################
## Section parameters: start
################################################
## project name
PARAM_PROJECT_NAME?=geneprediction

PARAM_DIR_UPLOAD?=/home/andreas/uploads/

################################################
## Directory with all the transcript data
PARAM_DIR_SRC?=../../export/export_clustering.dir/

################################################
## Table names
## postgres schema to use
PARAM_PSQL_SCHEMA?=$(PARAM_PROJECT_NAME)

## table with pairwise ortholog assignments
PARAM_TABLE_NAME_ORTHOLOGLINKS?=$(PARAM_PSQL_SCHEMA).orthologlinks
## table with distances: transcripts
PARAM_TABLE_NAME_DISTANCES?=$(PARAM_PSQL_SCHEMA).distances
## table with distances: genes
PARAM_TABLE_NAME_DISTANCES_GENES?=$(PARAM_PSQL_SCHEMA).distances_genes
## table with pairwise ka/ks assignments
PARAM_TABLE_NAME_KAKS?=$(PARAM_PSQL_SCHEMA).kaks

################################################
## genome parameters

## number of genomes to use
PARAM_NUM_GENOMES?=`echo $(PARAM_SRC_SCHEMAS) | wc -w`

## id of master genome
PARAM_GENOME_MASTER?=

################################################
## directories and database schemas
## IMPORTANT: Add new entries to the end for update to work

## schemas in input
PARAM_SRC_SCHEMAS?=

## These should be sorted in the same way.
PARAM_SRC_DIRS?=$(PARAM_SRC_SCHEMAS)

PARAM_DATA_DIR?=data

PARAM_SEPARATOR?=|

## names of genomes (for export)
PARAM_SRC_NAMES?=$(PARAM_SRC_SCHEMAS)


################################################
## define, if you want to map genes in STEP9
## (currently broken)
PARAM_STEP9_MAP_GENES?=

################################################
## define, if you want to use ks as a distance measure
## already in step 2.
## default = use normalized bitscore
PARAM_STEP2_USE_KS?=

################################################
# Section parameters: end
################################################

GENOMES_COMMA=`echo $(PARAM_SRC_SCHEMAS) | perl -p -e "s/ +/,/g"`
NAMES_COMMA=`echo $(PARAM_SRC_NAMES) | perl -p -e "s/ +/,/g"`

########################################################################
include $(DIR_SCRIPTS_GENEPREDICTION)/makefiles/Makefile.orthology_export_gbrowser

## target to do in subdirectories
MASTER_TARGET?=all

########################################################################
## setup directories for blast runs and pairwise orthology assignments
## each directory gets copies of
## 1. exon boundaries as exons1.exons and exons2.exons
## 2. peptides.fasta as peptides1.fasta and genome2.fasta
## 3. cds.fasta as cds1.fasta and cds2.fasta
##
## If you need to add further entries, add them to the end of PARAM_SRC_SCHEMAS and PARAM_SRC_DIRS.
prepare: create-schema create-tables
	$(PRELOG)
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES) - 1; ++x )); do \
		for (( y = $$x + 1; y < $(PARAM_NUM_GENOMES); ++y )); do \
			genome1=$${genomes[$$x]}; \
			genome2=$${genomes[$$y]}; \
			target_dir=pair_$${genome1}-$${genome2}; \
			if [ ! -e $${target_dir} ]; then \
			    echo "setting up $${target_dir}" $(TOLOG); \
			    mkdir $${target_dir}; \
			    python $(DIR_SCRIPTS_GENEPREDICTION)gpipe/setup.py \
			    -f \
			    -m orthology_pairwise \
			    -p orthology_$${genomes[$$x]}-$${genomes[$$y]} \
			    --include=../data/Makefile.inc \
			    -d $(CURDIR)/$${target_dir} \
			    -o $(DIR_ROOT) \
			    PARAM_GENOME1=$${genome1} \
			    PARAM_GENOME2=$${genome2} \
			    DIR_TMP=./ \
			    PARAM_STEP9_MAP_GENES=$(PARAM_STEP9_MAP_GENES) \
			    PARAM_STEP2_USE_KS=$(PARAM_STEP2_USE_KS) \
			    > $${target_dir}/setup.log; \
			    ln -s $(PARAM_DIR_SRC)export_clustering_$${genome1}_peptides.fasta $${target_dir}/peptides1.fasta; \
			    ln -s $(PARAM_DIR_SRC)export_clustering_$${genome1}_cds.fasta $${target_dir}/cds1.fasta; \
			    ln -s $(PARAM_DIR_SRC)export_clustering_$${genome1}.exons $${target_dir}/exons1.exons; \
			    ln -s $(PARAM_DIR_SRC)export_clustering_$${genome2}_peptides.fasta $${target_dir}/peptides2.fasta; \
			    ln -s $(PARAM_DIR_SRC)export_clustering_$${genome2}_cds.fasta $${target_dir}/cds2.fasta; \
			    ln -s $(PARAM_DIR_SRC)export_clustering_$${genome2}.exons $${target_dir}/exons2.exons; \
			else \
				echo "$${target_dir} already exists: skipped" $(TOLOG); \
			fi; \
		done; \
	done
	$(EPILOG)

update:
	$(PRELOG)
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	dirs=( $(PARAM_SRC_DIRS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES) - 1; ++x )); do \
		for (( y = $$x + 1; y < $(PARAM_NUM_GENOMES); ++y )); do \
			genome1=$${genomes[$$x]}; \
			genome2=$${genomes[$$y]}; \
			target_dir=pair_$${genome1}-$${genome2}; \
			    ln -fs $(PARAM_DIR_SRC)export_clustering_$${genome1}_peptides.fasta $${target_dir}/peptides1.fasta; \
			    ln -fs $(PARAM_DIR_SRC)export_clustering_$${genome1}_cds.fasta $${target_dir}/cds1.fasta; \
			    ln -fs $(PARAM_DIR_SRC)export_clustering_$${genome1}.exons $${target_dir}/exons1.exons; \
			    ln -fs $(PARAM_DIR_SRC)export_clustering_$${genome2}_peptides.fasta $${target_dir}/peptides2.fasta; \
			    ln -fs $(PARAM_DIR_SRC)export_clustering_$${genome2}_cds.fasta $${target_dir}/cds2.fasta; \
			    ln -fs $(PARAM_DIR_SRC)export_clustering_$${genome2}.exons $${target_dir}/exons2.exons; \
		done; \
	done
	$(EPILOG)


SUBDIRS?=$(wildcard pair_*)

$(SUBDIRS):
	$(MAKE) -C $@ $(MASTER_TARGET)

all: 
	$(PRELOG)
	$(MAKE) -j $(PARAM_NUM_JOBS) all-hook
	$(EPILOG)

all-hook: $(SUBDIRS)


finish: bestmatches.links orthologs.links.gz orthologs.load

clean:
	$(MAKE) all MASTER_TARGET=clean

.PHONY: subdirs $(SUBDIRS) all-hook

#############################################################################################
#############################################################################################
#############################################################################################
## Various managment targets
#############################################################################################

#############################################################################################
## progress report on blast
blast.show-progress:
	@echo "# blast progress at `date`" >> blast.progress
	@printf "# NFIN\tNTOT\tPFIN\tCAT\n" >> blast.progress
	@for dir in pair_*; do \
		total="`find $${dir} -name "query*.fasta" | wc -l`"; \
		finished="`grep "finished" $${dir}/step1.dir/blast.dir/*.log | wc -l`"; \
		if [[ $$total -gt 0 ]]; then \
			printf "%i\t%i\t%i%%\t%s\n" $${finished} $${total} $$(( 100 * $${finished} / $${total} )) $${dir} >> blast.progress; \
		fi; \
	done
	@total="`find -name "query*.fasta" | wc -l`"; \
	finished="`find -regex ".*blast.dir/.*.log" -exec grep "finished" {} \; | wc -l`"; \
	if [[ $$total -gt 0 ]]; then \
		printf "%i\t%i\t%i%%\tall\n" $${finished} $${total} $$(( 100 * $${finished} / $${total} )) >> blast.progress; \
	fi
	@cat blast.progress	

blast.show-unfinished:
	@for dir in pair_*; do \
		if [[ -d $${dir}/step1.dir/blast.dir ]]; then \
		echo "processing $${dir}"; \
		for file in $${dir}/step1.dir/blast.dir/query_*.log; do \
			tail -n 1 $${file} | grep -q "finished"; \
			if [[ $$? == 1 ]] ; then \
				echo "unfinished: $${file}"; \
			fi \
		done; \
		fi; \
	done

#############################################################################################
blast.remove-unfinished:
	$(PRELOG)
	@for dir in pair_*; do \
		if [[ -d $${dir}/step1.dir/blast.dir ]]; then \
		    $(CMD_MSG2) "processing $${dir}"; \
		    do_reset=0; \
		    for file in $${dir}/step1.dir/blast.dir/query_*.log; do \
			    tail -n 1 $${file} | grep -q "job finished"; \
			    if [[ $$? == 1 ]] ; then \
				    $(CMD_LOG2) "$${dir}: removing unfinished: $${file}"; \
				    rm -f $${file}; \
				    do_reset=1; \
			    fi \
		    done; \
		    if [[ $${do_reset} == 1 ]]; then \
			    $(CMD_LOG2) "$${dir}: resetting step1.run."; \
			    rm -f $${dir}/step1.run; \
			    rm -f $${dir}/step1.dir/blast.run; \
		    fi; \
		fi; \
	done
	$(EPILOG)

#############################################################################################
trees.show-unfinished:
	@for dir in pair_*; do \
		if [[ -d $${dir}/step3.dir/data.dir ]]; then \
		echo "processing $${dir}"; \
		for file in $${dir}/step3.dir/data.dir/cluster.*.tree; do \
			tail -n 1 $${file} | grep -q "finished"; \
			if [[ $$? == 1 ]] ; then \
				echo "unfinished: $${file}"; \
			fi \
		done; \
		fi; \
	done

#############################################################################################
trees.remove-unfinished:
	$(PRELOG)
	@for dir in pair_*; do \
		if [[ -d $${dir}/step3.dir/data.dir ]]; then \
		    $(CMD_MSG2) "processing $${dir}"; \
		    for file in $${dir}/step3.dir/data.dir/cluster.*.tree ; do \
			    do_reset=0; \
			    tail -n 1 $${file} | grep -q "finished"; \
			    if [[ $$? == 1 ]] ; then \
				    $(CMD_LOG2) "$${dir}: removing unfinished: $${file}"; \
				    rm -f $${file}; \
				    do_reset=1; \
			    fi \
		    done; \
		    if [[ $${do_reset} == 1 ]]; then \
			    $(CMD_LOG2) "$${dir}: resetting step3.run."; \
			    rm -f $${dir}/step3.run; \
			    rm -f $${dir}/step3.dir/data.run; \
		    fi; \
		fi; \
	done
	$(EPILOG)

################################################################################
## progress report on trees
trees.show-progress:
	@echo "# trees progress at `date`" >> trees.progress
	@printf "# NCHUNKS\tNSTART\tUNCHANGED\tNREJOINED\tDIRECTORY\n" >> trees.progress
	@for dir in pair_*; do \
		printf "%i\t%i\t%i\t%i\t%i\t%s\n" \
					`find $${dir}/step3.dir/data.dir/ -name "*.ks" | wc -l` \
					`find $${dir}/step3.dir/data.dir/ -name "*.tree" ! -empty | wc -l` \
					`find $${dir}/step3.dir/data.dir/ -name "*.unchanged" ! -empty | wc -l` \
					`find $${dir}/step3.dir/data.dir/ -name "*.rejoined" ! -empty | wc -l` \
					`if [ -e $${dir}/step3.dir/interpretation ]; then echo 1; else echo 0; fi` \
					$${dir} \
		>> trees.progress; \
	done
	@cat trees.progress	


################################################################################
## create summary output from pairwise comparisons and write them to logfile.
trees.check: 
	$(PRELOG)
	@for target_dir in pair_*; do \
		if [ -e $${target_dir} ]; then \
			echo "checking $${target_dir}" $(TOLOG); \
			if [ -e $${target_dir}/step3.dir ]; then \
				printf "jobs: total=%i rejoined=%i unchanged=%i\n" \
					`find $${target_dir}/step3.dir/data.dir/ -name "*.ks" | wc -l` \
					`find $${target_dir}/step3.dir/data.dir/ -name "*.rejoined" ! -empty | wc -l` \
					`find $${target_dir}/step3.dir/data.dir/ -name "*.unchanged" ! -empty | wc -l` $(TOLOG); \
				if [ -e $${target_dir}/step3.dir/interpretation ]; then \
					for file in ortho_1_to_1 ortho_1_to_m ortho_m_to_1 orphaned_tax1 orphaned_tax2; do \
						if [ -e $${target_dir}/step3.dir/orthology_$${file} ]; then \
							printf "%-20s : %10i\n" $${file} `grep -c -v -e ">" -e "^$$" < $${target_dir}/step3.dir/orthology_$${file}` $(TOLOG); \
						else \
							printf "%-20s : %10i\n" $${file} 0 $(TOLOG); \
						fi; \
					done; \
				else \
					printf "job has not assigned orthologies."; \
				fi; \
			else \
				printf "job has not computed any trees."; \
			fi; \
		fi; \
	done
	@touch $@
	$(EPILOG)

#############################################################################################
## progress report on kaks
kaks.show-progress:
	@echo "# kaks progress at `date`" >> kaks.progress
	@printf "# NFIN\tNTOT\tPFIN\tCAT\n" >> kaks.progress
	@for dir in pair_*; do \
		total="`find $${dir} -name "step6*.chunk" | wc -l`"; \
		finished="`grep "finished" $${dir}/step6.dir/*.log | wc -l`"; \
		if [[ $$total -gt 0 ]]; then \
			printf "%i\t%i\t%i%%\t%s\n" $${finished} $${total} $$(( 100 * $${finished} / $${total} )) $${dir} >> kaks.progress; \
		fi; \
	done
	@total="`find -name "step6*.chunk" | wc -l`"; \
	finished="`find -regex ".*step6.dir/.*.log" -exec grep "finished" {} \; | wc -l`"; \
	if [[ $$total -gt 0 ]]; then \
		printf "%i\t%i\t%i%%\tall\n" $${finished} $${total} $$(( 100 * $${finished} / $${total} )) >> kaks.progress; \
	fi
	@cat kaks.progress	

kaks.show-unfinished:
	@for dir in pair_*; do \
		if [[ -d $${dir}/step6.dir ]]; then \
		echo "processing $${dir}"; \
		for file in $${dir}/step6.dir/step6*.log; do \
			tail -n 1 $${file} | grep -q "finished"; \
			if [[ $$? == 1 ]] ; then \
				echo "unfinished: $${file}"; \
			fi \
		done; \
		fi; \
	done

#############################################################################################
kaks.remove-unfinished:
	$(PRELOG)
	@for dir in pair_*; do \
		if [[ -d $${dir}/step6.dir ]]; then \
		    $(CMD_MSG2) "processing $${dir}"; \
		    do_reset=0; \
		    for file in $${dir}/step6.dir/step6*.log; do \
			    tail -n 1 $${file} | grep -q "job finished"; \
			    if [[ $$? == 1 ]] ; then \
				    $(CMD_LOG2) "$${dir}: removing unfinished: $${file}"; \
				    rm -f $${file}; \
				    do_reset=1; \
			    fi \
		    done; \
		    if [[ $${do_reset} == 1 ]]; then \
			    $(CMD_LOG2) "$${dir}: resetting step6.run."; \
			    rm -f $${dir}/step6.run; \
		    fi; \
		fi; \
	done
	$(EPILOG)

#############################################################################################
#############################################################################################
#############################################################################################
## Various monitoring targets
#############################################################################################

#############################################################################################
## Get number of links for all step1
monitor.dir/step1: 
	$(PRELOG)
	@rm -f monitor.dir/summary_step1.links
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	printf "schema1\tschema2\tnqueries\tnsbjcts\tnvertices\tnlinks\n" > monitor.dir/summary_step1.links; \
	for (( x = 0; x < $(PARAM_NUM_GENOMES) - 1; ++x )); do \
		for (( y = $$x + 1; y < $(PARAM_NUM_GENOMES); ++y )); do \
			target_file=pair_$${genomes[$$x]}-$${genomes[$$y]}/step1.dir/blast.links.gz; \
			if [ -e $${target_file} ]; then \
				printf "%s\t%i\t%i\t%i\t%i\n" \
				$${target_file} \
				`gunzip < $${target_file} | perl $(DIR_SCRIPTS_TOOLS)graph_howmany.pl | grep -v "#"` >> monitor.dir/summary_step1.links; \
			else \
				printf "%s\tmissing\n" $${target_file} >> monitor.dir/summary_step1.links ; \
			fi; \
		done; \
	done
	$(EPILOG)

#############################################################################################
## Monitoring the graphs
monitor: monitor.dir monitor.dir/step2 monitor.dir/step4 monitor.dir/step6 monitor.dir/step7

monitor.dir/step2: monitor.dir/summary_step2.scaled.links monitor.dir/summary_step2.seed.links
monitor.dir/step4: monitor.dir/summary_step4.besthits.links
monitor.dir/step6: monitor.dir/summary_step6.orthologs  monitor.dir/summary_step6.kaks 
monitor.dir/step7: monitor.dir/summary_step7.pairs

monitor.dir/summary: 
	$(PRELOG)
	python $(DIR_SCRIPTS_TOOLS)combine_tables.py \
		--columns=1,2 \
		monitor.dir/summary_step1.links \
		monitor.dir/summary_step2.scaled.links \
		monitor.dir/summary_step2.seed.links \
		monitor.dir/summary_step4.besthits.links \
		monitor.dir/summary_step6.orthologs \
		monitor.dir/summary_step6.kaks \
		monitor.dir/summary_step7.pairs > $@
	$(EPILOG)

monitor.dir/summary_%:
	$(PRELOG)
	@rm -f $@
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	printf "schema1\tschema2\tnqueries\tnsbjcts\tnvertices\tnlinks\n" > $@; \
	for (( x = 0; x < $(PARAM_NUM_GENOMES) - 1; ++x )); do \
		for (( y = $$x + 1; y < $(PARAM_NUM_GENOMES); ++y )); do \
			genome1=$${genomes[$$x]}; \
			genome2=$${genomes[$$y]}; \
			target_file=pair_$${genome1}-$${genome2}/$*; \
			if [[ -e $${target_file} || -e $${target_file}.gz ]]; then \
				if [[ -e $${target_file}.gz ]]; then \
					cmd="gunzip"; file=$${target_file}.gz; \
				else \
					cmd="cat"; file=$${target_file}; \
				fi; \
				printf "%s\t%s\t%i\t%i\t%i\t%i\n" \
				$${genome1} $${genome2} \
				`$${cmd} < $${file} | perl $(DIR_SCRIPTS_TOOLS)graph_howmany.pl | $(CMD_REMOVE_HEADER)` >> $@; \
			else \
				printf "%s\t%s\tmissing\n" $${genome1} $${genome2} >> $@ ; \
			fi; \
		done; \
	done
	$(EPILOG)

#############################################################################################
#############################################################################################
#############################################################################################
#############################################################################################
## Perform various checks on the link files
#############################################################################################
## Number of links for each pairwise combination
check.dir/%.matrix: %.links.gz
	$(EPILOG)
	@gunzip < $^ |\
	perl -p -e "s/[$(PARAM_SEPARATOR)]\S+//g;" |\
	cut -f 1,2 |\
	python $(DIR_SCRIPTS_TOOLS)graph2stats.py --method=counts |\
	python $(DIR_SCRIPTS_TOOLS)sparse2full.py \
	--row-names=$(GENOMES_COMMA) \
	--col-names=$(GENOMES_COMMA) > $@
	$(EPILOG)

#############################################################################################
#############################################################################################
#############################################################################################
#############################################################################################
## Setup up analysis
#############################################################################################
analysis: analysis.prepare analysis.run

analysis.prepare:
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)gpipe/setup.py \
		-m orthology_pairwise_analysis -d analysis.dir -p $(PARAM_PROJECT_NAME) \
		-o $(DIR_ROOT) \
		"PARAM_DIR_SRC=../" \
		"PARAM_SRC_SCHEMAS=$(PARAM_SRC_SCHEMAS)" \
		"PARAM_GENOME_MASTER=$(PARAM_GENOME_MASTER)" \
		> $@
	$(EPILOG)

analysis.run: analysis.prepare
	$(PRELOG)
	@$(MAKE) -C analysis.dir analysis
	$(EPILOG)

#############################################################################################
#############################################################################################
#############################################################################################
#############################################################################################
## Collect summary information
#############################################################################################
SUMMARY_TARGETS=\
	distances.links.gz \
	kaks.links.gz \
	orthologs_first.links.gz \
	orthologs_first.load \
	orthologs_second.links.gz \
	orthologs_second.load \
	distances.load \
	distances_genes.load \
	orphans_first.links.gz \
	orphans_second.links.gz \
	besthits.links.gz 

summary: summary.dir $(SUMMARY_TARGETS:%=summary.dir/%)

#############################################################################################
#############################################################################################
#############################################################################################
## Summarize the summary
#############################################################################################
SUMMARY_CHECK_FILES=besthits.links.gz distances.links.gz kaks.links.gz orthologs_first.ka.gz orthologs_first.ks.gz \
	orthologs_first.links.gz orthologs_second.links.gz 

orthologs.check: 
	$(PRELOG)
	@printf "file\tqueries\tsbjcts\tvertices\tedges\n" > $@
	@for x in $(SUMMARY_CHECK_FILES:%=summary.dir/%); do \
		printf "%s\t" $${x} >> $@; \
		gunzip < $${x} |\
		perl $(DIR_SCRIPTS_TOOLS)graph_howmany.pl | grep -v "#" >> $@; \
	done
	$(CMD_LOG) "checking kaks results"
	@cat $@ $(TOLOG)
	$(EPILOG)

#############################################################################################
#############################################################################################
#############################################################################################
## Compile a file with best matches
#############################################################################################
summary.dir/besthits.links.gz:
	$(PRELOG)
	@rm -f $@
	@for target_dir in pair_*; do \
		if [ -s $${target_dir}/step4.besthits.links.gz ]; then \
			gunzip < $${target_dir}/step4.besthits.links.gz |\
			grep -v "#" |\
			awk '{ cova = ($$5-$$4+1)/$$12; \
			       covb = ($$8-$$7+1)/$$13; \
			       if (cova > covb) { maxcov = cova; mincov = covb; } \
			       else { maxcov = covb; mincov = cova; } \
			       printf("%s\t%s\t%s\t%5.2f\t%5.2f\n", $$1, $$2, $$3, mincov, maxcov); \
			     }' \
			>> $@_tmp; \
		else \
			$(CMD_MSG2) "warning: missing file: $${target_dir}/step4.besthits.links.gz"; \
			$(CMD_LOG2) "warning: missing file: $${target_dir}/step4.besthits.links.gz"; \
		fi; \
	done
	@sort -k1,1 -k3,3n < $@_tmp | gzip > $@
	@gunzip < $@ | perl $(DIR_SCRIPTS_TOOLS)graph_howmany.pl < $@ $(TOLOG)
	$(EPILOG)

#############################################################################################
#############################################################################################
#############################################################################################
## collect all data. Sort and make non-redundant (longest alignment between any pair.)
#############################################################################################
summary.dir/distances.links.gz:
	$(PRELOG)
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	grep "id1" pair_$${genomes[0]}-$${genomes[1]}/step7.pairs > $@_tmp; 
	@for target_dir in pair_*; do \
		if [ -s $${target_dir}/step7.pairs ]; then \
			cat $${target_dir}/step7.pairs | grep -v -e "#" -e "id1" |\
			perl -p -e "s/ \d+ \d+//g" >> $@_tmp; \
		else \
			$(CMD_MSG2) "warning: missing file: $${target_dir}/step7.pairs"; \
			$(CMD_LOG2) "warning: missing file: $${target_dir}/step7.pairs"; \
		fi; \
	done
	@sort -k1,1 -k2,2 -k3,3nr $@_tmp |\
	awk '{ if ($$1 != l1 || $$2 != l2) { print; } l1 = $$1; l2 = $$2; }' |\
	gzip > $@
	@rm -f $@_tmp
	$(CMD_LOG) "number of links: `gunzip < $@ | wc -l`"
	$(EPILOG)


#############################################################################################
#############################################################################################
#############################################################################################
## collect all data from kaks calculations. Sort and make non-redundant
## The data collected is ka, ks and tau. 
## (If tau is 50, the run is likely not to have converged and is removed)
summary.dir/kaks.links.gz:
	$(PRELOG)
	@rm -f $@_tmp
	@for target_dir in pair_*; do \
		if [ -s $${target_dir}/step6.kaks ]; then \
			cut -f 1,2,3,4,12 $${target_dir}/step6.kaks |\
			awk '$$5 != 50' >> $@_tmp; \
			awk '$$3 ~ /identical/ \
			{ printf("%s\t%s\t%i\t%i\t%i\n", $$1, $$2, 0, 0, 0); }' \
			< $${target_dir}/step6.pairs.links >> $@_tmp; \
		else \
			$(CMD_MSG2) "warning: missing file: $${target_dir}/step6.kaks"; \
			$(CMD_LOG2) "warning: missing file: $${target_dir}/step6.kaks"; \
		fi; \
	done
	@sort -k1,1 -k2,2 -k4,4n $@_tmp |\
	awk '{ if ($$1 != l1 || $$2 != l2) { print; } l1 = $$1; l2 = $$2; }' |\
	gzip > $@
	@rm -f $@_tmp
	$(CMD_LOG) "number of links: `gunzip < $@ | wc -l`"
	$(EPILOG)


#############################################################################################
#############################################################################################
#############################################################################################
## Write orthologous pairs for which kaks calculation has failed.
#############################################################################################
summary.dir/orthologs.missing.gz: summary.dir/kaks.links.gz summary.dir/orthologs.links.gz
	$(PRELOG)
	@gunzip < summary.dir/orthologs.links.gz |\
	perl $(DIR_SCRIPTS_TOOLS)graph_filter_links_links.pl -r \
	<(gunzip < summary.dir/kaks.links.gz | cut -f 1,2) |\
	gzip > $@	
	$(EPILOG)

#############################################################################################
#############################################################################################
#############################################################################################
########################################################################
## Concatenating links from the pairwise orthology assignments
## Links are classified into 1 to many depending on the number of transcripts and genes
#############################################################################################
summary.dir/orthologs_first.links.gz: ORTHOLOGS_FILE=$${target_dir}/step3.dir/interpretation
summary.dir/orthologs_second.links.gz: ORTHOLOGS_FILE=$${target_dir}/step9.dir/interpretation

## filter out crud (why?)
summary.dir/orthologs_first.links.gz: ORTHOLOGS_FILTER=\
			--filename-restrict-filter1=<(grep ">" $${target_dir}/peptides1.fasta | perl -p -e "s/^>//") \
			--filename-restrict-filter2=<(grep ">" $${target_dir}/peptides2.fasta | perl -p -e "s/^>//") \

summary.dir/orthologs_%.links.gz: 
	$(PRELOG)
	@rm -f $@.tmp
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES) - 1; ++x )); do \
		for (( y = $$x + 1; y < $(PARAM_NUM_GENOMES); ++y )); do \
			genome1=$${genomes[$$x]}; \
			genome2=$${genomes[$$y]}; \
			target_dir=pair_$${genome1}-$${genome2}; \
			if [ -e $(ORTHOLOGS_FILE) ]; then \
				python $(DIR_SCRIPTS_GENEPREDICTION)optic/orthologs2list.py \
				--species-regex="^([^$(PARAM_SEPARATOR)]+)\$(PARAM_SEPARATOR)" \
				--gene-regex="^[^$(PARAM_SEPARATOR)]+\$(PARAM_SEPARATOR)[^$(PARAM_SEPARATOR)]+\$(PARAM_SEPARATOR)([^$(PARAM_SEPARATOR)]+)\$(PARAM_SEPARATOR)" \
				--no-combine-genes \
				--genome1="$${genome1}" \
				--genome2="$${genome2}" \
				$(ORTHLOGS_FILTER) \
			< $(ORTHOLOGS_FILE) >> $@.tmp; \
			else \
				$(CMD_MSG2) "warning: missing file: $(ORTHOLOGS_FILE) "; \
				$(CMD_LOG2) "warning: missing file: $(ORTHOLOGS_FILE) "; \
			fi; \
		done; \
	done
	@cat $@.tmp |\
	awk '!/^#/ { if (l != $$6) { a += 1; } \
		     printf("%s\t%s\t%s\t%s\t%s\t%i\n", $$1, $$2, $$3, $$4, $$5, a); l = $$6; }' \
	| gzip > $@
	@rm -f $@.tmp
	@gunzip < $@ | perl $(DIR_SCRIPTS_TOOLS)graph_howmany.pl $(TOLOG)
	$(EPILOG)

#############################################################################################
#############################################################################################
#############################################################################################
#########################################################################
## split identifiers at separator
## Note: there are are redundant edges in orthologs.links.gz, because
## identical m:m clusters in two species pairs with one shared species 
## will result in multiple duplicate entries.
## The whole table is symmetrized to faciliate select statements
#############################################################################################
summary.dir/orthologs_%.load: summary.dir/orthologs_%.links.gz
	$(PRELOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_ORTHOLOGLINKS)_$*;" > /dev/null
	@gunzip < $< |\
	awk '!/^#/ \
	{ split($$1, a, "$(PARAM_SEPARATOR)"); split($$2, b, "$(PARAM_SEPARATOR)"); \
	  split($$4, c, ""); split($$5, d, ""); \
	  printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", \
	  a[1], a[2], a[3], b[1], b[2], b[3], c[1], c[2], d[1], d[2], $$3, $$6); \
	  printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", \
	  b[1], b[2], b[3], a[1], a[2], a[3], c[2], c[1], d[2], d[1], $$3, $$6); \
	}' |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_ORTHOLOGLINKS)_$* FROM STDIN WITH NULL AS 'na'" > $@ 
	@$(PSQL_CONNECTION) "ANALYSE $(PARAM_TABLE_NAME_ORTHOLOGLINKS)_$*" >> $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_ORTHOLOGLINKS)_$*: `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_ORTHOLOGLINKS)_$*;' -t `"  >> $(LOG)
	@touch $@
	$(EPILOG)

#############################################################################################
#############################################################################################
#############################################################################################
########################################################################
## Concatenating links from the pairwise orthology assignments for orphans
## 
#############################################################################################
summary.dir/orphans_first.links.gz: ORPHANS_FILE=$${target_dir}/step3.dir/orthology_orphaned
summary.dir/orphans_second.links.gz: ORPHANS_FILE=$${target_dir}/step9.dir/orthology_orphaned

## filter out crud (why?)
summary.dir/orphans_first.links.gz: ORPHANS_FILTER=\
			--filename-restrict-filter1=<(grep ">" $${target_dir}/peptides1.fasta | perl -p -e "s/^>//") \
			--filename-restrict-filter2=<(grep ">" $${target_dir}/peptides2.fasta | perl -p -e "s/^>//") \

summary.dir/orphans_%.links.gz: summary.dir/orthologs_%.links.gz
	$(PRELOG)
	@rm -f $@.tmp
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES) - 1; ++x )); do \
		for (( y = $$x + 1; y < $(PARAM_NUM_GENOMES); ++y )); do \
			genome1=$${genomes[$$x]}; \
			genome2=$${genomes[$$y]}; \
			target_dir=pair_$${genome1}-$${genome2}; \
			if [ -e $(ORPHANS_FILE) ]; then \
				python $(DIR_SCRIPTS_GENEPREDICTION)optic/orthologs2list.py \
				--species-regex="^([^$(PARAM_SEPARATOR)]+)\$(PARAM_SEPARATOR)" \
				--gene-regex="^[^$(PARAM_SEPARATOR)]+\$(PARAM_SEPARATOR)[^$(PARAM_SEPARATOR)]+\$(PARAM_SEPARATOR)([^$(PARAM_SEPARATOR)]+)\$(PARAM_SEPARATOR)" \
				--no-combine-genes \
				--mode=orphans \
				--genome1="$${genome1}" \
				--genome2="$${genome2}" \
				$(ORTHLOGS_FILTER) \
			< $(ORPHANS_FILE) >> $@.tmp; \
			else \
				$(CMD_MSG2) "warning: missing file: $(ORPHANS_FILE) "; \
				$(CMD_LOG2) "warning: missing file: $(ORPHANS_FILE) "; \
			fi; \
		done; \
	done
	@gunzip < $< | perl $(DIR_SCRIPTS_TOOLS)graph_links2tokens.pl > $@.tmp2
	@perl $(DIR_SCRIPTS_TOOLS)graph_filter_links_vertices.pl -r -s $@.tmp2 < $@.tmp |\
	awk '!/^#/ {if ($$1 < $$2) { printf("%s\t%s\n", $$1, $$2); } else { printf("%s\t%s\n", $$1, $$2);}} ' |\
	sort | uniq -c |\
	awk '{ printf("%s\t%s\t%i\n", $$2, $$3, $$1); }' | gzip > $@
	@rm -f $@.tmp*
	$(EPILOG)

#############################################################################################
#############################################################################################
#############################################################################################
#########################################################################
## load kaks results into database
## Note: ka, ks and distances should be non-redundant (only one link per pair) and sorted in the 
## same way (on the first and second fields)
## Make symmetric
#############################################################################################
summary.dir/distances.load: summary.dir/kaks.links.gz summary.dir/distances.links.gz
	$(PRELOG)	
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_DISTANCES);" > /dev/null
	@python $(DIR_SCRIPTS_TOOLS)join_tables.py \
		--columns=1,2 \
		--missing=0 \
		<(gunzip < summary.dir/kaks.links.gz) \
		<(gunzip < summary.dir/distances.links.gz) |\
	awk '!/^#/ && !/^id1/ && !/^seq1/ \
	{ split($$1, a, "$(PARAM_SEPARATOR)"); split($$2, b, "$(PARAM_SEPARATOR)"); \
	  $$1 = sprintf("%s\t%s\t%s", a[1], a[2], a[3]); $$2 = sprintf("%s\t%s\t%s", b[1], b[2], b[3]); print; \
	  $$2 = sprintf("%s\t%s\t%s", a[1], a[2], a[3]); $$1 = sprintf("%s\t%s\t%s", b[1], b[2], b[3]); print; \
	}' |\
	perl -p -e "s/ +/\t/g;" |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_DISTANCES) FROM STDIN WITH NULL AS 'na'" > $@ 
	@$(PSQL_CONNECTION) "ANALYSE $(PARAM_TABLE_NAME_DISTANCES)" >> $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_DISTANCES): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_DISTANCES);' -t `"  >> $(LOG)
	@touch $@
	$(EPILOG)

#############################################################################################
#############################################################################################
#############################################################################################
## load distances between genes into database.
## This simply executes a SQL statement to aggregate distances between transcripts.
## Take minimum distance.
#############################################################################################
summary.dir/distances_genes.load: summary.dir/distances.load
	$(PRELOG)	
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_DISTANCES_GENES);" > /dev/null
	@$(PSQL_CONNECTION) "INSERT INTO $(PARAM_TABLE_NAME_DISTANCES_GENES) \
		(schema1, \
		 gene_id1, \
		 schema2, \
		 gene_id2, \
		 ka, \
		 ks, \
		 max_aligned, \
		 all_jc69, \
		 all_t92, \
		 codon3_jc69, \
		 codon3_t92, \
		 d4_jc69, \
		 d4_t92) SELECT \
		 schema1, \
		 gene_id1, \
		 schema2, \
		 gene_id2, \
		 MIN(ka), \
		 MIN(ks), \
		 MAX(all_aligned), \
		 MIN(all_jc69), \
	         MIN(all_t92), \
		 MIN(codon3_jc69), \
	         MIN(codon3_t92), \
		 MIN(d4_jc69), \
		 MIN(d4_t92) FROM $(PARAM_TABLE_NAME_DISTANCES) \
		 GROUP BY schema1, gene_id1, schema2, gene_id2" >> $@
	@$(PSQL_CONNECTION) "ANALYSE $(PARAM_TABLE_NAME_DISTANCES_GENES)" >> $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_DISTANCES_GENES): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_DISTANCES_GENES);' -t `"  >> $(LOG)
	@touch $@
	$(EPILOG)

########################################################################
########################################################################
########################################################################
## Various additional targets
########################################################################
## Minimum ks between transcript pairs
## Note: is not symmetric
summary.dir/orthologs_%.ks.gz: summary.dir/orthologs_%.links.gz summary.dir/kaks.links.gz
	$(PRELOG)
	@gunzip < summary.dir/kaks.links.gz |\
	perl $(DIR_SCRIPTS_TOOLS)graph_filter_links_links.pl \
	<(gunzip < summary.dir/orthologs_$*.links.gz | cut -f 1,2) |\
	cut -f 1,2,4 |\
	sort -k1,1 -k2,2 |\
	python $(DIR_SCRIPTS_TOOLS)graph_combine_links_redundant.py |\
	cut -f 1,2,3 |\
	gzip > $@	
	$(EPILOG)

########################################################################
## Minimum ka between transcript pairs
## Note: is not symmetric
summary.dir/orthologs_%.ka.gz: summary.dir/orthologs_%.links.gz summary.dir/kaks.links.gz
	$(PRELOG)
	@gunzip < summary.dir/kaks.links.gz |\
	perl $(DIR_SCRIPTS_TOOLS)graph_filter_links_links.pl \
	<(gunzip < summary.dir/orthologs_$*.links.gz | cut -f 1,2) |\
	cut -f 1,2,3 |\
	sort -k1,1 -k2,2 |\
	python $(DIR_SCRIPTS_TOOLS)graph_combine_links_redundant.py |\
	cut -f 1,2,3 |\
	gzip > $@	
	$(EPILOG)

#############################################################################################
#############################################################################################
#############################################################################################
########################################################################
## Concatenating links from the pairwise orthology assignments
## Links are classified into 1 to many depending on the number of transcripts and genes
#############################################################################################
summary.dir/orthologs_first.stats: ORTHOLOGS_FILE=$${target_dir}/step3.dir/interpretation
summary.dir/orthologs_second.stats: ORTHOLOGS_FILE=$${target_dir}/step9.dir/interpretation

## filter out crud (why?)
summary.dir/orthologs_first.stats: ORTHOLOGS_FILTER=\
			--filename-restrict-filter1=<(grep ">" $${target_dir}/peptides1.fasta | perl -p -e "s/^>//") \
			--filename-restrict-filter2=<(grep ">" $${target_dir}/peptides2.fasta | perl -p -e "s/^>//") \

summary.dir/orthologs_%.stats: 
	$(PRELOG)
	@printf "schema1\tschema2\t" > $@
	@python $(DIR_SCRIPTS_TOOLS)data2stats.py --write-header --verbose=0 >> $@
	@genomes=( $(PARAM_SRC_SCHEMAS) ); \
	for (( x = 0; x < $(PARAM_NUM_GENOMES) - 1; ++x )); do \
		for (( y = $$x + 1; y < $(PARAM_NUM_GENOMES); ++y )); do \
			genome1=$${genomes[$$x]}; \
			genome2=$${genomes[$$y]}; \
			printf "%s\t%s\t" $${genome1} $${genome2} >> $@ ; \
			target_dir=pair_$${genome1}-$${genome2}; \
			if [ -e $(ORTHOLOGS_FILE) ]; then \
				awk 'BEGIN{printf("distance\n");} {printf("%f\n", $$1*2);}' \
			< $(ORTHOLOGS_FILE) |\
			python $(DIR_SCRIPTS_TOOLS)data2stats.py --no-title --flat --skip-header --verbose=0 >> $@ ; \
			else \
				$(CMD_MSG2) "warning: missing file: $(ORTHOLOGS_FILE) "; \
				$(CMD_LOG2) "warning: missing file: $(ORTHOLOGS_FILE) "; \
			fi; \
		done; \
	done
	$(EPILOG)


#########################################################################
## load kaks results into database
## Note: ka and ks should be sorted in the same way (on the first field)
## Make symmetric
kaks.load: summary.dir/orthologs.ks.gz summary.dir/orthologs.ka.gz
	$(PRELOG)	
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_KAKS);" > /dev/null
	@join -t "	" \
		<(gunzip < summary.dir/orthologs.ka.gz | grep -v "#" | cut -f 1,2,3 | nl) \
		<(gunzip < summary.dir/orthologs.ks.gz | grep -v "#" | cut -f 3 | nl) |\
	awk '!/^#/ \
	{ split($$2, a, "$(PARAM_SEPARATOR)"); split($$3, b, "$(PARAM_SEPARATOR)"); \
	  printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", \
	  a[1], a[2], a[3], b[1], b[2], b[3], $$4, $$5); \
	  printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", \
	  b[1], b[2], b[3], a[1], a[2], a[3], $$4, $$5); }' |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_KAKS) FROM STDIN WITH NULL AS 'na'" > $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_KAKS): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_KAKS);' -t `"  >> $(LOG)
	@touch $@
	$(EPILOG)

########################################################################
## Combine minimum ka and ks per transcript
orthologs_%.kaks.gz: orthologs_%.ks.gz orthologs_%.ka.gz
	$(PRELOG)
	@join <(orthologs.ka.gz) <(orthologs.ks.gz) > $@
	$(EPILOG)

########################################################################
## Minimum ks per gene
orthologs_%.min_gene.gz: summary.dir/orthologs_%.gz
	$(PRELOG)
	@gunzip < $< |\
	awk '!/^#/\
	     { split($$1, a, "$(PARAM_SEPARATOR)"); split($$2, b, "$(PARAM_SEPARATOR)"); \
	       printf("%s$(PARAM_SEPARATOR)%s$(PARAM_SEPARATOR)%s$(PARAM_SEPARATOR)UK\t%s\t%s\n", a[1], a[2], a[2], b[1], $$3); \
	       printf("%s$(PARAM_SEPARATOR)%s$(PARAM_SEPARATOR)%s$(PARAM_SEPARATOR)UK\t%s\t%s\n", b[1], b[2], b[2], a[1], $$3); \
	     }' |\
	sort -k1,1 -k2,2 |\
	python $(DIR_SCRIPTS_TOOLS)graph_combine_links_redundant.py |\
	gzip > $@	
	$(EPILOG)

#########################################################################
create-schema:
	$(PRELOG)
	-@$(PSQL_CONNECTION) "CREATE SCHEMA $(PARAM_PSQL_SCHEMA)" $(TO_NULL)
	$(EPILOG)

#########################################################################
create-tables: \
		$(PARAM_TABLE_NAME_ORTHOLOGLINKS)_first.create-table-orthologlinks \
		$(PARAM_TABLE_NAME_ORTHOLOGLINKS)_second.create-table-orthologlinks \
		$(PARAM_TABLE_NAME_DISTANCES_GENES).create-table-distances-genes \
		$(PARAM_TABLE_NAME_DISTANCES).create-table-distances

#########################################################################
%.create-table-orthologlinks: 
	$(PRELOG)
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL);
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	schema1 TEXT, \
	prediction_id1 TEXT, \
	gene_id1 TEXT, \
	schema2 TEXT, \
	prediction_id2 TEXT, \
	gene_id2 TEXT, \
	gd1 CHAR(1), \
	gd2 CHAR(1), \
	td1 CHAR(1), \
	td2 CHAR(1), \
	weight FLOAT, \
	cluster_id INTEGER )" $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (schema1,prediction_id1);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index2 ON $* (schema2,prediction_id2);" $(TO_NULL) 
	$(EPILOG)

#########################################################################
%.create-table-kaks: 
	$(PRELOG)
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	schema1 TEXT, \
	prediction_id1 TEXT, \
	gene_id1 TEXT, \
	schema2 TEXT, \
	prediction_id2 TEXT, \
	gene_id2 TEXT, \
	ka FLOAT, \
	ks FLOAT )" $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_prediction_id1 ON $* (prediction_id1);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_prediction_id2 ON $* (prediction_id2);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_schema1 ON $* (schema1);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_schema2 ON $* (schema2);" $(TO_NULL)  
	$(EPILOG)

#########################################################################
%.create-table-distances-genes: 
	$(PRELOG)
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE" $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	schema1 TEXT, \
	gene_id1 TEXT, \
	schema2 TEXT, \
	gene_id2 TEXT, \
	ka FLOAT, \
	ks FLOAT, \
	max_aligned INTEGER, \
	all_jc69 FLOAT, \
	all_t92 FLOAT, \
	codon3_jc69 FLOAT, \
	codon3_t92 FLOAT, \
	d4_jc69 FLOAT, \
	d4_t92 FLOAT)" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (schema1,gene_id1);" $(TO_NULL)  
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index2 ON $* (schema2,gene_id2);" $(TO_NULL) 
	$(EPILOG)

#########################################################################
%.create-table-distances: 
	$(PRELOG)
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE" $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	schema1 TEXT, \
	prediction_id1 TEXT, \
	gene_id1 TEXT, \
	schema2 TEXT, \
	prediction_id2 TEXT, \
	gene_id2 TEXT, \
	ka FLOAT, \
	ks FLOAT, \
	tau FLOAT, \
	all_aligned INTEGER, \
	all_identical INTEGER, \
	all_transitions INTEGER, \
	all_transversions INTEGER, \
	all_jc69 FLOAT, \
	all_t92 FLOAT, \
	codon3_aligned INTEGER, \
	codon3_identical INTEGER, \
	codon3_transitions INTEGER, \
	codon3_transversions INTEGER, \
	codon3_jc69 FLOAT, \
	codon3_t92 FLOAT, \
	d4_aligned INTEGER, \
	d4_identical INTEGER, \
	d4_transitions INTEGER, \
	d4_transversions INTEGER, \
	d4_jc69 FLOAT, \
	d4_t92 FLOAT)" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (schema1,prediction_id1);" $(TO_NULL)  
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index2 ON $* (schema2,prediction_id2);" $(TO_NULL) 
	$(EPILOG)

#########################################################################
## Get statistics
##
## Matrix of 1:1 orthologs in all pairs
stats: stats.prepare stats.run

stats.prepare: summary.dir/orthologs.links
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)gpipe/setup.py \
		-f -m stats \
		-p $(PARAM_PROJECT_NAME)_stats \
		-d stats.dir \
		-o $(DIR_ROOT) \
	PARAM_SCHEMAS="$(PARAM_SRC_SCHEMAS)" \
	PARAM_SRC_PEPTIDES="$(PARAM_DATA_DIR)peptides.fasta" \
	> $@
	@grep "$(PARAM_GENOME_MASTER)" orthologs.links  | cut -f 1,2 | perl $(DIR_SCRIPTS_TOOLS)graph_links2tokens.pl > stats.dir/filter
	$(EPILOG)

stats.run: stats.prepare
	$(PRELOG)
	@if [[ -e stats.dir ]]; then \
		$(MAKE) -C stats.dir missed_queries.summary classes_genes.summary ; \
	fi
	$(EPILOG)

################################################################################################
%.csv: % translation
	rm -f $@
	python $(DIR_SCRIPTS_TOOLS)substitute_tokens.py \
	--apply=translation --multiple --columns=all \
	< $* |\
	grep -v "#" |\
	perl -p -e "s/\t/,/g" > $@

################################################################################################
## How to make a picture out of a matrix
%.png: %.matrix
	@python $(DIR_SCRIPTS_TOOLS)plot_matrix.py \
	$(PNG_OPTIONS) \
	--headers --labels="Genomes","Genomes" \
	--hardcopy=$@ \
	< $*.matrix > /dev/null

#########################################################################
include $(DIR_SCRIPTS_GENEPREDICTION)/makefiles/Makefile.common

