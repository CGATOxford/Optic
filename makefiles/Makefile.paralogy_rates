################################################################################
#   Gene prediction pipeline 
#
#   $Id: Makefile.paralogy_rates 2781 2009-09-10 11:33:14Z andreas $
#
#   Copyright (C) 2005 Andreas Heger
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License
#   as published by the Free Software Foundation; either version 2
#   of the License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#################################################################################
#################################################################################
#################################################################################
##
## Analyzing multiple alignments for duplications
##
## The input is obtained from a directory of multiple alignments and a file
## of components/sequences to take.
##
##
## The pipeline performs the following steps:
## * calculate pairwise ka and ks
## * build phylogeny incrementally
##   1. bootstrap topolog
##   2. fit ks branch lengths globally on bootstrap topology
##   3. fit ks branch lenghts locally (ks < PARAM_REFINEMENT1_THRESHOLD) without topology changes
##   4. fit ks branch lenghts locally (ks < PARAM_REFINEMENT2_THRESHOLD) with topology changes
## * Analyze trees for duplications and split into subtrees based
##   on out-paralogs or out-groups (if given)
##
## * Build ML trees for each subtrees.
##   * build ML tree for whole subtree
##   * split subtrees into subclusters according to transcript information
##     * build ML tree for each subcluster
##
#################################################################################
##
## The analysis section contains many analysis targets.
##
#################################################################################

################################################
## Section parameters: start
################################################
## Project name
PARAM_PROJECT_NAME?=paralogy_trees

PARAM_PSQL_SCHEMA?=$(PARAM_PROJECT_NAME)

################################################
################################################
################################################
## Source information for collecting data for this analysis

## Directory with multiple alignments
PARAM_DIR_SRC_MALIS?=../malis/

## Directory with trees
PARAM_DIR_SRC_TREES?=../paralogy_trees/

## Filename with mali summary information
PARAM_SRC_MALIS=$(PARAM_DIR_SRC_MALIS)/summary.dir/malis_genes_na.fasta

## Filename with mali summary information
PARAM_SRC_TREES=$(PARAM_DIR_SRC_TREES)/analysis.dir/trees

## Pattern to find multiple alignments
PARAM_PATTERN_EXONS?=$(PARAM_DIR_SRC_MALIS)data.dir/cluster_%s.dir/cluster_%s.exons

################################################
################################################
################################################
## directories and database schemas
PARAM_SRC_SCHEMAS?=

## Number of genomes
PARAM_NUM_GENOMES?=`echo $(PARAM_SRC_SCHEMAS) | wc -w`

## Pattern for translation
PARAM_PATTERN_TRANSLATION?=s/_vs_dmel\d+//g

PARAM_SRC_NAMES=`echo $(PARAM_SRC_SCHEMAS) | perl -p -e "$(PARAM_PATTERN_TRANSLATION)"`

################################################
PARAM_SEPARATOR?=|

################################################
################################################
################################################
## Parameters for analysing duplications

PARAM_DIR_DATA?=../../../data/

## Tree in njtree format with correct names
PARAM_FILENAME_SPECIES_TREE?=$(PARAM_DIR_DATA)species_tree_sp

## Tree with permutations
PARAM_ANALYSIS_DUPLICATIONS_TREE?=$(PARAM_DIR_DATA)species_tree_permutations

## Map of schema names to swissprot names for njtree
PARAM_ANALYSIS_DUPLICATIONS_SPECIES2SP?=$(PARAM_DIR_DATA)schema2sp

## Map of species names to colours
PARAM_ANALYSIS_DUPLICATIONS_COLOURS?=$(PARAM_DIR_DATA)schema2colour

## Map of species names to urls
PARAM_ANALYSIS_DUPLICATIONS_URLS?=$(PARAM_DIR_DATA)schema2url

## Map of species to names
PARAM_ANALYSIS_DUPLICATIONS_TRANSLATION?=$(PARAM_DIR_DATA)schema2name

## Distance between "syntenic" transcripts
PARAM_ANALYSIS_DUPLICATIONS_MAX_SEPARATION?=1000000

## Outgroups to use for rooting trees. If not given, the
## tree is rooted using midpoint rooting.
PARAM_ANALYSIS_DUPLICATIONS_OUTGROUPS?=

## ortholog sets to compute
PARAM_ANALYSIS_DUPLICATIONS_ORTHOLOG_SETS?=exhaustive

## Input table to get ortholog groups
PARAM_TABLE_NAME_ORTHOGROUPS?=$(PARAM_PSQL_SCHEMA).clusters_members

################################################
## Output table with ks tress
PARAM_TABLE_NAME_KS_TREES?=$(PARAM_PSQL_SCHEMA).groups_ks_trees

## Output table with ka trees
PARAM_TABLE_NAME_KA_TREES?=$(PARAM_PSQL_SCHEMA).groups_ka_trees

################################################
## Output table with all tree information
PARAM_TABLE_NAME_GROUPS_TREES?=$(PARAM_PSQL_SCHEMA).groups_trees

################################################
## Output table with ancestral sequences
PARAM_TABLE_NAME_ANCESTRAL_SEQUENCES?=$(PARAM_PSQL_SCHEMA).ancestral_sequences

################################################
## Reduce convergence thresholds if there are many sequences
## in the tree.
## apply lower threshold at this number of sequences or more
PARAM_RATES_THRESHOLD_OPTIMIZATION_NSEQUENCES?=30

## use default value for rates
PARAM_RATES_THRESHOLD_OPTIMIZATION?=1e-6

################################################
## Options for Gblocks
## allow up to half the sequence to have gaps
PARAM_GBLOCKS_OPTIONS?=-b5=h

## Accept Gblocks alignments, if at least 50% of positions are kept,
## otherwise keep the original.
PARAM_GBLOCKS_MIN_KEPT?=50

################################################
## Analysis options

## Filtering of multiple alignments to exclude gappy 
## alignments from the analysis

## Minimum character occupancy of rows
PARAM_ANALYSIS_THRESHOLD_MIN_NROWS=100

## Minimum character occupancy of rows in percent
PARAM_ANALYSIS_THRESHOLD_MIN_PROWS=40

## Maximum distance in tree. Distances larger than 
## this value are treated as missing and trees
## with branch lengths longer than this are removed.
PARAM_MAX_DISTANCE?=5

################################################
# Section parameters: end
################################################

REQUISITES=

nop:

##################################################################################
prepare: create-log create-tables input.map input.species all.map_id2pos
	$(PRELOG)
	$(EPILOG)

create-tables: \
		$(PARAM_TABLE_NAME_KS_TREES).create-table-trees \
		$(PARAM_TABLE_NAME_KA_TREES).create-table-trees \
		$(PARAM_TABLE_NAME_GROUPS_TREES).create-table-groups-trees \
		$(PARAM_TABLE_NAME_ANCESTRAL_SEQUENCES).create-table-ancestral-sequences 

all: data.prepare data.run 

finish: analysis summary

summary: data.run analysis summary.dir
	$(PRELOG)
	if test -e summary.dir; then \
		$(CMD_REMOTE_SUBMIT) $(MAKE) $@-hook; \
	fi
	$(EPILOG)

summary-hook: summary.dir/ks_trees summary.dir/ks_trees.load \
		summary.dir/ka_trees summary.dir/ka_trees.load \
		summary.dir/ancestral_sequences.table summary.dir/ancestral_sequences.load \
		summary.dir/groups.trees summary.dir/groups.trees.load

.PHONY: summary-hook

####################################################################################
####################################################################################
####################################################################################
## build input.map from a clade genomics pipeline table.
####################################################################################
input.map:
	$(PRELOG)
	@rm -f $@
	@for x in $(PARAM_SRC_SCHEMAS); do \
		$(PSQL_CONNECTION) \
		"SELECT DISTINCT '$${x}$(PARAM_SEPARATOR)' || o.gene_id, \
			g.group_id1 \
			FROM $${x}.overview AS o, $(PARAM_TABLE_NAME_ORTHOGROUPS) AS g \
			WHERE CAST(g.gene_id AS TEXT) = CAST(o.gene_id AS TEXT) AND o.gene_id != '0' AND g.group_id1 != '0'" \
		$(PSQL_CONNECTION_OPTIONS) >> $@; \
	done
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
input.species: 
	$(PRELOG)
	@rm -f $@
	@for x in $(PARAM_SRC_SCHEMAS); do \
		printf "%s\n" $${x} >> $@; \
	done
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
all.map_id2pos:
	$(PRELOG)
	@ln -s $(PARAM_DIR_SRC_TREES)/summary.dir/$@ $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Prepare data directory
#######################################################################################
data.prepare: 
	$(PRELOG)
	$(MAKE) data.dir
	$(CMD_LOG) "creating directories and writing trees."
	@python $(DIR_SCRIPTS_TOOLS)trees2trees.py \
		--output-filename-map=trees.map \
		--output-pattern="data.dir/cluster_%s.dir/cluster_%s.tree" \
	< $(PARAM_SRC_TREES) > $@
	@python $(DIR_SCRIPTS_GENEPREDICTION)split_fasta.py \
		--map=trees.map \
		--output-pattern="data.dir/cluster_%s.dir/cluster_%s.fasta" \
		< $(PARAM_SRC_MALIS) >> $@
	$(CMD_LOG) "adding Makefiles to directories."
	@for d in data.dir/cluster_*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		ln -s ../../Makefile $${d}/Makefile; \
	done
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Progress report
#######################################################################################
data.show-progress:
	@echo "# prediction status at `date`" >> data.progress
	@nfixed=0;nvar=0;nhook=0;nfasta=0; \
	for d in data.dir/cluster*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		if test -s $${d}/cluster_$${cluster_id}.fasta; then let "nfasta=nfasta+1"; fi; \
		if test -s $${d}/cluster_$${cluster_id}_fixed_w_ml.tree; then let "nfixed=nfixed+1"; fi; \
		if test -s $${d}/cluster_$${cluster_id}_variable_w_ml.tree; then let "nvar=nvar+1"; fi; \
		if test -e $${d}/data.run-subhook; then let "nhook=nhook+1"; fi; \
	done; \
	awk -v nfasta="$${nfasta}" -v nvar=$${nvar} -v nfixed=$${nfixed} -v nhook=$${nhook} \
	'END {  printf("# N\tNFIXED\tPLEFT\tRSUCC\tNVAR\tPLEFT\tRSUCC\tNHOOK\tPLEFT\tRSUCC\n"); \
		printf("%i\t%i\t%5.2f\t%5.2f\t%i\t%5.2f\t%5.2f\t%i\t%5.2f\t%5.2f\n", \
			nfasta,\
			nfixed,((nfasta-nfixed)*100)/nfasta,(nfasta > 0) ? 100*nfixed/nfasta : 0, \
			nvar,((nfasta-nvar)*100)/nfasta,(nfasta > 0) ? 100*nvar/nfasta : 0 , \
			nhook,((nfasta-nhook)*100)/nfasta,(nfasta > 0) ? 100*nhook/nfasta : 0 ); }' \
	</dev/null >> data.progress
	@tail data.progress

#######################################################################################
#######################################################################################
#######################################################################################
## Show missing files
#######################################################################################
data.show-unfinished:
	@for d in data.dir/cluster_*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		file=$${d}/cluster_$${cluster_id}_fixed_w.paml; \
		if test -e $${file} && ! grep -q "Time used:" $${file}; then \
			$(CMD_MSG2)  "unfinished $${file};"; \
		fi; \
		file=$${d}/cluster_$${cluster_id}_fixed_w_ml.tree; \
		if test -e $${file} && ! grep -q ">" $${file}; then \
			$(CMD_MSG2) "unfinished $${file};"; \
		fi; \
	done

#######################################################################################
#######################################################################################
#######################################################################################
## Remove debris from aborted runs
#######################################################################################
data.remove-unfinished:
	$(PRELOG)
	@nfixed=0; nfixed_tree=0; \
	for d in data.dir/cluster_*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		files_to_remove="$${d}/data.run-subhook $${d}/rates.run"; \
		file=$${d}/cluster_$${cluster_id}_fixed_w.paml; \
		if test -e $${file} && ! grep -q "Time used:" $${file}; then \
			$(CMD_MSG2)  "removing $${file};" >> $@.log; \
			rm -f $${file} $${files_to_remove} ; \
			let "nfixed=nfixed+1"; \
		fi; \
		file=$${d}/cluster_$${cluster_id}_fixed_w_ml.tree; \
		if test -e $${file} && ! test -s $${file}; then \
			$(CMD_MSG2)  "removing $${file};" >> $@.log; \
			rm -f $${file} $${files_to_remove}; \
			let "nfixed_tree=nfixed_tree+1"; \
		fi; \
	done; \
	$(CMD_LOG2) "removed $${nfixed} files: nfixed.paml"; \
	$(CMD_LOG2) "removed $${nfixed_tree} files: nfixed.tree"
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Build targets in subdirectories
#######################################################################################
DATA=$(wildcard cluster_[0-9]*.dir)

data.run: data.prepare
	$(PRELOG)
	@if test -e data.dir; then \
		$(MAKE) -C data.dir -k -j $(PARAM_NUM_JOBS) $@-hook; \
	fi
	@touch $@
	$(EPILOG)

$(DATA):
	@$(MAKE) -C $@ data.run-subhook 

data.run-hook: $(DATA)

data.run-subhook: 
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) $(MAKE) rates-hook < /dev/null
	@touch $@
	$(EPILOG)

.PHONY: $(DATA)

#######################################################################################
#######################################################################################
#######################################################################################
#######################################################################################
## Targets to execute in subdirectory
##
## If there are only two sequences, skip the tree building step.
##
#######################################################################################
rates-hook: rates.prepare rates.run rates.finish

#################################################################################
#################################################################################
#################################################################################
## Mask sequences for composition and incomplete codons and remove fully gapped 
## columns
#################################################################################
%.masked_mali: %.fasta
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)fasta2fasta.py --method=mask-seg --log=$@.log < $< > $@
	$(EPILOG)

#################################################################################
#################################################################################
#################################################################################
## Run Gblocks on mali.
## Note: Gblocks always ends on error code 1, thus ignore it.
## If more than 50% is removed, keep the original alignment
#################################################################################
%.mali: %.masked_mali
	$(PRELOG)
	@rm -f $@.log
	@grep -v "#" $< |\
	perl -p -e "s/ //g unless (/^>/);" > $@_tmp
	@-Gblocks $@_tmp -t=c $(PARAM_GBLOCKS_OPTIONS) > $@.log
	@nkept=`grep "Gblocks alignment" $@.log | tail -n 1 | perl -p -e "s/.*positions \(//; s/ %\).*//;"`; \
	if [[ $${nkept} -lt "$(PARAM_GBLOCKS_MIN_KEPT)" ]]; then \
		printf "using original alignment\n" >> $@.log; \
		$(CMD_LOG2) "using original alignment"; \
		mv $@_tmp $@; \
	else \
		mv $@_tmp-gb $@; \
	fi; \
	rm -f $@_tmp*
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
## Estimate ks tree for each multiple alignment using PAML and the
## topology estimated previously.
## Here is the logic for running jobs in parallel
###########################################################################

## Split according to transcripts
RATES_PREPARE_QUERIES=$(wildcard cluster*.fasta)
RATES_PREPARE_TARGETS=$(RATES_PREPARE_QUERIES:%.fasta=%.clusters) 

#			$(RATES_PREPARE_QUERIES:%.fasta=%.split) \
#			$(RATES_PREPARE_QUERIES:%.fasta=%.split_clean)

rates.prepare:
	$(PREPARE)
	@touch $@
	$(EPILOG)

RATES_RUN_QUERIES=$(wildcard *.fasta)
RATES_RUN_TARGETS?= \
		$(RATES_RUN_QUERIES:%.fasta=%.masked_mali) \
		$(RATES_RUN_QUERIES:%.fasta=%.mali) \
		$(RATES_RUN_QUERIES:%.fasta=%.phylip) \
		$(RATES_RUN_QUERIES:%.fasta=%_fixed_w.paml) \
		$(RATES_RUN_QUERIES:%.fasta=%_fixed_w_ml.tree) 

# Disabled variable rate test
# ifneq ($(wildcard subtree_*_variable_w.ctl),)
# RATES_RUN_TARGETS+= $(RATES_RUN_QUERIES:%.fasta=%_variable_w.paml) \
# 		$(RATES_RUN_QUERIES:%.fasta=%_variable_w_ml.tree) \
# 		$(RATES_RUN_QUERIES:%.fasta=%.lrt) 
# endif

rates.run: rates.prepare
	$(PRELOG)
	@$(MAKE) rates.run-hook
	@touch $@
	$(EPILOG)

rates.run-hook: $(RATES_RUN_TARGETS)

rates.finish: rates.run 
	$(PREPARE)
	@touch $@
	$(EPILOG)

.PHONY: subtree.run-hook

###########################################################################
###########################################################################
###########################################################################
## Prepare data for input
## 1. Convert mali to phylip format and perform the following operations on it:
##    Remove unaligned sequences
##    Rename identifiers in mali and tree to short identifiers
##    Remove alternative transcripts
##    Unroot tree
%.phylip: %.mali
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)mali2mali.py \
		--method=remove-unaligned-pairs,remove-all-gaps \
		--verbose=0 \
	< $< |\
	python $(DIR_SCRIPTS_TOOLS)fasta2fasta.py \
		    --method=build-map \
		    --parameters=$*.map_old2new |\
	python $(DIR_SCRIPTS_TOOLS)mali2mali.py \
		--input-format=fasta \
		--output-format=phylip \
		--verbose=0 > $@; \
	python $(DIR_SCRIPTS_TOOLS)tree2tree.py \
		--method=rename,unroot \
		--parameters=$*.map_old2new \
		--verbose=0 \
	< $*.tree > $*_mapped.tree
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
%_fixed_w.ctl: %.fasta
	$(PRELOG)
	@nsequences=`grep -c ">" < $*.fasta`; \
	if [ "$${nsequences}" -gt "$(PARAM_RATES_THRESHOLD_OPTIMIZATION_NSEQUENCES)" ]; then \
		$(CMD_LOG2) "reduced sensitivity for alignment $${cluster_id} with $${nsequences} members."; \
		extra_options="--set-optimization-threshold=$(PARAM_RATES_THRESHOLD_OPTIMIZATION) --set-method=1"; \
	fi; \
	python $(DIR_SCRIPTS_GENEPREDICTION)WrapperCodeML.py \
		--filename-output=../$*_fixed_w.output \
		--filename-sequences=../$*.phylip \
		--filename-tree=../$*_mapped.tree \
		--estimate-ancestors \
		--write-control-file \
		$${extra_options} \
		--analysis=branch-fixed-kaks |\
	grep -v "#" > $@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
%_fixed_w.paml: %_fixed_w.ctl %.phylip
	$(PRELOG)
	@mkdir -p $@.dir
	@cd $@.dir >& /dev/null; codeml ../$< < /dev/null > ../$@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
%_variable_w.paml: %_variable_w.ctl %.phylip
	$(PRELOG)
	@mkdir -p $@.dir
	@cd $@.dir >& /dev/null; codeml ../$< < /dev/null > ../$@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
%_fixed_w_ml.tree: %_fixed_w.paml 
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)codeml2tsv.py \
		--prefix=$*_fixed_w \
		--method=write-ks-tree \
		$*_fixed_w.output |\
	python $(DIR_SCRIPTS_TOOLS)tree2tree.py \
		--method=rename,midpoint-root \
		--parameters=$*.map_old2new \
		--invert \
		--verbose=0 > $@
	$(EPILOG)

.PRECIOUS: %_fixed_w.ctl

#######################################################################################
#######################################################################################
#######################################################################################
#######################################################################################
## Primary targets for complete statistics
#######################################################################################
TARGET_STATS=$(QUERY_SUBDIR:%.fasta=%.stats)
OUTPUT_FILES=$(PARAM_OMEGA_VALUES:%=$*_%.output)

stats: $(TARGET_STATS)

%.stats: %.counts
	$(EPILOG)

%.counts:
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)codemls2tsv.py \
		--filter-probability=$(PARAM_FILTER_SITES_PROBABILITY) \
		--filter-omega=$(PARAM_FILTER_SITES_OMEGA) \
		--models=`echo $(PARAM_FILTER_MODELS) | perl -p -e "chop; s/\s+/,/g"` \
		--analysis=`echo $(PARAM_FILTER_METHOD) | perl -p -e "chop; s/\s+/,/g"` \
		--method=summary-numbers \
		--significance-threshold=$(PARAM_SIGNIFICANCE_THRESHOLD) \
		--prefix=$* \
		$(OUTPUT_FILES) > $@
	$(EPILOG)

.PRECIOUS: %.counts

#######################################################################################
#######################################################################################
#######################################################################################
## build a list of filtered malis
#######################################################################################
malis.filtered: malis.summary
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)csv_cut.py prefix nrow_mean prow_mean < $< |\
	awk '!/^#/ && \
	     $$2 >= $(PARAM_ANALYSIS_THRESHOLD_MIN_NROWS) && \
	     $$3 >= $(PARAM_ANALYSIS_THRESHOLD_MIN_PROWS) { \
	     printf("cluster_%s\n", $$0); }' > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
ANALYSIS_SECTIONS=ks ka kaks
ANALYSIS_SUBSECTIONS_RATES=all filtered_all filtered_genes filtered_pseudos

analysis:
	$(PRELOG)
	$(MAKE) $(ANALYSIS_SECTIONS:%=analysis-%.dir) analysis.dir
	$(MAKE) -k -j 4 $(ANALYSIS_SECTIONS:%=analysis-%-hook) analysis.dir/trees
	$(EPILOG)

analysis-%-hook:
	$(PRELOG)
	$(CMD_REMOTE_SUBMIT) $(MAKE) analysis-$*.dir/trees < /dev/null
	if test -e analysis-$*.dir; then \
		$(MAKE) -C analysis-$*.dir -k -j $(PARAM_NUM_JOBS) analysis-hook; \
	fi
	$(EPILOG)

analysis-hook: filtered trees.stats trees.recall 
#			$(ANALYSIS_SUBSECTIONS_RATES:%=trees_%.summary) \
#			$(ANALYSIS_SUBSECTIONS_RATES:%=duplications_%.summary) 

analysis-post-hook: 
#analysis-post-hook: local-duplications \
#			species_heights.stats species_relheights.stats \
#			species_all_heights.hist species_all_relheights.hist \
#			tree_heights.stats tree_relheights.stats \
#			tree_all_heights.hists tree_all_relheights.hists 

#######################################################################################
#######################################################################################
#######################################################################################
## collect all trees for ka, ks and kaks
#######################################################################################
TREES_AGGREGATES=mean stddev counts median
TREES_DISTANCES=ks ka kaks sds ndn
TREES_SECTIONS=fixed_w variable_w

analysis.dir/trees:
	$(PRELOG)
	@rm -f $@*
	@for section in $(TREES_SECTIONS); do \
		rm -f $@.tmp; \
		for dir in data.dir/cluster_*.dir; do \
			cluster_id=$${dir#data.dir/cluster_}; \
			cluster_id=$${cluster_id%.dir}; \
			fa=$${dir}/cluster_$${cluster_id}_$${section}.paml; \
			fn=$${dir}/cluster_$${cluster_id}_$${section}.output; \
			fm=$${dir}/cluster_$${cluster_id}.map_old2new; \
			if test -e $${fn} && grep -q "^Time used" $${fa}; then \
				printf "%s\t%s\t\t\t\t%s\n" $${fn} $${cluster_id} $${fm} >> $@.tmp; \
			else \
				printf "skipped incomplete file %s\n" $${fn} >> $@.err; \
			fi; \
		done; \
		if test -e $@.tmp; then \
			for distance in $(TREES_DISTANCES); do \
				python $(DIR_SCRIPTS_GENEPREDICTION)WrapperCodeML.py \
					--verbose=0 \
					--analysis=branch-specific-kaks \
					--parse-batch=$@.tmp \
					--parse-output=$${distance}-tree \
					--invert-map \
				< /dev/null \
				>> $@_$${section}_$${distance}.trees; \
			done; \
		fi; \
	done
	@rm -f $@.tmp
	@grep -c ">" $@_* > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## collect trees for ka, ks or kaks and perform analyses on them
##
## Possible targets: analysis-ka.dir/trees, analysis-kaks.dir/trees analysis-ks.dir/trees
#######################################################################################
analysis-%.dir/trees:
	$(PRELOG)
	@rm -f $@*
	@for dir in data.dir/cluster_*.dir; do \
		cluster_id=$${dir#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		printf "%s\t%i\t%s\t%s\t%s\t%s\n" \
			$${dir}/cluster_$${cluster_id}_fixed_w.output \
			$${cluster_id} \
			$${dir}/cluster_$${cluster_id}_fixed_w.paml \
			"" \
			"" \
			$${dir}/cluster_$${cluster_id}.map_old2new \
		>> $@.tmp; \
	done
	@python $(DIR_SCRIPTS_GENEPREDICTION)WrapperCodeML.py \
		--parse-batch=$@.tmp --invert-map \
		--parse-output=$*-tree \
		--analysis=branch-specific-kaks	\
		--log=$@.log |\
	python $(DIR_SCRIPTS_TOOLS)tree2tree.py \
		--method=midpoint-root \
		--log=$@.log |\
	awk '/^>/ { cluster_id=$$1; sub(">", "", cluster_id); \
			printf(">%i\n", cluster_id ); \
			printf("%s\t%i\n", substr($$1,2), cluster_id) >> "$@.map"; next; } \
		{ print; }' \
	> $@
	@rm -f $@.tmp
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Filtered trees
#######################################################################################
filtered: trees
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)tree2tree.py \
		--filter=max-branch-length \
		--parameters=$(PARAM_MAX_DISTANCE) \
	< $< > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Compare input to output and find out how many genes/transcripts have been dropped
## due to aborted computations
#######################################################################################
trees.recall: trees
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) python $(DIR_SCRIPTS_TOOLS)tree2taxa.py --skip-trees < $< > $@.taxa
	@$(CMD_REMOTE_SUBMIT) python $(DIR_SCRIPTS_GENEPREDICTION)diff_transcript_sets.py \
		--add-percent \
		--dump-sets=rest_genes2 \
		--output-pattern="trees.recall.%s" \
		$@.taxa ../trees.map \
	< /dev/null > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Statistics for trees
#######################################################################################
trees.stats: trees
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)tree2stats.py --method=branchlengths \
	< $< > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Get counts of trees for tree statistics
#######################################################################################
counts-trees:
	@grep "noutput=" analysis.dir/tree*.summary |\
	perl -p -e "s/analysis.dir\/subtrees_*//; s/\.summary.dir\//\t/; s/.summary/\t/; s/:#//; s/,/\t/g; " |\
	awk 'NR == 1 \
		{ t[1]="section1"; t[2]="section2";  \
		for (x = 2; x <= NF; ++x) { split($$x, a, "="); t[x] = a[1]; } \
		printf("%s", t[1]); for (x = 2; x <= NF; ++x) { printf ("\t%s", t[x]); } printf("\n"); } \
	     	{ v[1] = $$1; v[2] = $$2; \
		for (x = 2; x <= NF; ++x) { split($$x, a, "="); v[x] = a[2] } \
		printf("%s", v[1]); for (x = 2; x <= NF; ++x) { printf ("\t%s", v[x]); } printf("\n"); }' 

#######################################################################################
#######################################################################################
#######################################################################################
## Get counts of trees analized for duplications
#######################################################################################
counts-duplications:
	@grep "# ninput=" analysis.dir/duplications*.summary |\
	perl -p -e "s/analysis.dir\/subtrees_*//; s/\.summary.dir\//\t/; s/.summary/\t/; s/:#//; s/,/\t/g; " |\
	awk 'NR == 1 \
		{ t[1]="section1"; t[2]="section2";  \
		for (x = 2; x <= NF; ++x) { split($$x, a, "="); t[x] = a[1]; } \
		printf("%s", t[1]); for (x = 2; x <= NF; ++x) { printf ("\t%s", t[x]); } printf("\n"); } \
	     	{ v[1] = $$1; v[2] = $$2; \
		for (x = 2; x <= NF; ++x) { split($$x, a, "="); v[x] = a[2] } \
		printf("%s", v[1]); for (x = 2; x <= NF; ++x) { printf ("\t%s", v[x]); } printf("\n"); }' 

#######################################################################################
#######################################################################################
#######################################################################################
## Examine date of duplications
#######################################################################################

# filter for a subset of malis, if malis.filtered is given.
ifeq ($(wildcard ../../malis.filtered),)
DUPLICATIONS_FILTER_MALIS=
else
DUPLICATIONS_FILTER_MALIS=--filename-filter-positives=../../malis.filtered
endif

CMD_ANALYSIS_DUPLICATIONS=cat filtered |\
	$(CMD_REMOTE_SUBMIT) \
	python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_orthology_multiple.py \
		--filename-species-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		$(DUPLICATIONS_EXTRA_OPTIONS) \
		--output-pattern=$@.dir/%s.data \
		--filename-locations=../all.map_id2pos \
		$(DUPLICATIONS_FILTER_MALIS) \
		--filename-species-list=../input.species \
		--print-totals \
		--print-species-svg \
		--print-summaries \
		--gene-regex='"^[^|]+\|([^|]+)"' \
		--output-pattern-svg="$@.dir/%s.svg" \
		--svg-branch-lengths="uniform" \
		--svg-otus=`xargs < ../input.species | perl -p -e "s/\s+/,/g"` 


duplications_all.summary:
	$(PRELOG)
	@$(MAKE) $@.dir
	@$(CMD_ANALYSIS_DUPLICATIONS) > $@
	@if test -e $@.dir; then \
		$(MAKE) -C $@.dir analysis-duplications-data; \
	fi
	$(EPILOG)

duplications_filtered_all.summary:
	$(PRELOG)
	@$(MAKE) $@.dir
	@$(CMD_ANALYSIS_DUPLICATIONS) \
		--remove-unplaced --filter-quality="all" > $@
	@if test -e $@.dir; then \
		$(MAKE) -C $@.dir analysis-duplications-data; \
	fi
	$(EPILOG)

duplications_filtered_genes.summary:
	$(PRELOG)
	@$(MAKE) $@.dir
	@$(CMD_ANALYSIS_DUPLICATIONS) \
		--remove-unplaced --filter-quality="genes" > $@
	@if test -e $@.dir; then \
		$(MAKE) -C $@.dir analysis-duplications-data; \
	fi
	$(EPILOG)

duplications_filtered_pseudos.summary:
	$(PRELOG)
	@$(MAKE) $@.dir
	@$(CMD_ANALYSIS_DUPLICATIONS) \
		--remove-unplaced --filter-quality="pseudogenes" > $@
	@if test -e $@.dir; then \
		$(MAKE) -C $@.dir analysis-duplications-data; \
	fi
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Summarize duplications data
#######################################################################################
duplications.analysis:
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) \
	python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_orthology_multiple.py \
		--filename-species-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		$(DUPLICATIONS_EXTRA_OPTIONS) \
		--output-pattern=%s.analysis \
		--filename-locations=../../all.map_id2pos \
		--filename-species-list=../../input.species \
		--filename-gene-trees=../filtered \
		--filename-duplications=- \
		--analyze-duplication-data=stats \
		--analyze-duplication-data=local-dups \
	< duplications.data > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Count the number of species in each cluster
#######################################################################################
count_orgs: trees
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) \
	python $(DIR_SCRIPTS_GENEPREDICTION)optic/count_orgs.py \
		--reference-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		--format=trees \
		--filename-patterns=$@.patterns \
		--filename-summary=$@.summary \
	< $< > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Build a list with clusters that contain an outgroup (if given).
## If no outgroup is given, all clusters are taken for analysis.
#######################################################################################
ifneq ($(PARAM_ANALYSIS_DUPLICATIONS_OUTGROUPS), "")
clusters_with_outgroups: count_orgs
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)csv_cut.py mali $(PARAM_ANALYSIS_DUPLICATIONS_OUTGROUPS) < $< |\
		awk '/mali/ || $$2 > 0' > $@
	$(EPILOG)
else
clusters_with_outgroups: count_orgs
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)csv_cut.py mali < $< > $@
	$(EPILOG)
endif

#######################################################################################
#######################################################################################
#######################################################################################
## Examine branch length of trees
#######################################################################################
CMD_ANALYSIS_TREES=python $(DIR_SCRIPTS_TOOLS)gpipe/filter_fasta.py \
		--method=ids --parameter=clusters_with_outgroups < $< |\
	$(CMD_REMOTE_SUBMIT) \
	python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_genetrees.py \
		--filename-species-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		$(DUPLICATIONS_EXTRA_OPTIONS) \
		--output-pattern=$@.dir/%s.data \
		--filename-locations=../all.map_id2pos \
		--gene-regex='"^[^|]+\|([^|]+)"' \
		$(DUPLICATIONS_FILTER_MALIS) \
		--print-totals \
		--print-subtotals \
		--skip-without-outgroups 

trees_all.summary: filtered clusters_with_outgroups
	$(PRELOG)
	@$(MAKE) $@.dir
	@$(CMD_ANALYSIS_TREES) > $@
	$(EPILOG)

trees_filtered.summary: filtered clusters_with_outgroups
	$(PRELOG)
	@$(MAKE) $@.dir
	@$(CMD_ANALYSIS_TREES) \
		--remove-unplaced > $@
	$(EPILOG)

trees_filtered_all.summary: filtered clusters_with_outgroups
	$(PRELOG)
	@$(MAKE) $@.dir
	@$(CMD_ANALYSIS_TREES) \
		--remove-unplaced --filter-quality="all" > $@
	$(EPILOG)

trees_filtered_genes.summary: filtered clusters_with_outgroups
	$(PRELOG)
	@$(MAKE) $@.dir
	@$(CMD_ANALYSIS_TREES) \
		--remove-unplaced --filter-quality="genes" > $@
	$(EPILOG)

trees_filtered_pseudos.summary: filtered clusters_with_outgroups
	$(PRELOG)
	@$(MAKE) $@.dir
	@$(CMD_ANALYSIS_TREES) \
		--remove-unplaced --filter-quality="pseudogenes" > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Collect results from analysis for plots
#######################################################################################
ANALYSIS_SUBGROUPS?=all filtered_all filtered_genes filtered_pseudos

#######################################################################################
#######################################################################################
#######################################################################################
## collect mean and stddev of distance of species to root averaged over all trees
## use heights/relheights as target modifiers
#######################################################################################
species_%.stats: 
	$(PRELOG)
	@for s1 in $(ANALYSIS_SUBGROUPS); do \
		file=trees_$${s1}.summary.dir/species_$*.data; \
		if test -e $${file}; then \
			printf "species\t%s\t%s\n" $${s1} stderr > $@_tmp_$${s1}; \
			grep -e "total" -e "prefix" < $${file} |\
			$(YT)csv_cut.py species mean stddev -v 0 |\
			grep -v "species" >> $@_tmp_$${s1}; \
		fi; \
	done
	@$(YT)combine_tables.py -v 0 $@_tmp_* > $@
	@rm -f $@_tmp_*;
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## compute histograms of heights for species (longest distance of leaf to root)
#######################################################################################
CMD_SPECIES_HEIGHTS=@for genome in $(PARAM_SRC_SCHEMAS); do \
		printf "bin\t%s\n" $${genome} > $@_tmp_$${genome}; \
		grep -e "$${genome}" -e "prefix" < $@_tmp_total |\
		$(YT)csv_cut.py heights |\
		perl -p -e "s/,/\n/g" |\
		$(YT)data2histogram.py \
			--min-value=0.0 \
			--bin-size=0.01 \
			--normalize \
			--cumulative \
			--verbose=0 |\
		grep -v "bin" >> $@_tmp_$${genome}; \
		done; \
		rm -f $@_tmp_total; \
		$(YT)combine_histograms.py \
		--missing="-" \
		$@_tmp_* > $@; \
		rm -f $@_tmp_*;


species_%_relheights.hist: 
	$(PRELOG)
	@grep -e "total" -e "prefix" \
		trees_$*.summary.dir/species_relheights.data |\
		$(YT)csv_cut.py prefix species heights -v 0 > $@_tmp_total;
	$(CMD_SPECIES_HEIGHTS)
	$(EPILOG)



species_%_heights.hist: 
	$(PRELOG)
	@grep -e "total" -e "prefix" \
		trees_$*.summary.dir/species_heights.data |\
		$(YT)csv_cut.py prefix species heights -v 0 > $@_tmp_total;
	$(CMD_SPECIES_HEIGHTS)
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## compute histograms of heights of trees (longest distance of leaf to root)
## use heights/relheights as target modifiers
#######################################################################################
tree_%_heights.hists: ANALYSIS_TREE_HISTS_BIN_SIZE=0.1
tree_%_heights.hists: ANALYSIS_TREE_SECTION=heights
tree_%_relheights.hists: ANALYSIS_TREE_HISTS_BIN_SIZE=0.02
tree_%_relheights.hists: ANALYSIS_TREE_SECTION=relheights

pergroup_tree_%_heights.hists:    ANALYSIS_TREE_HISTS_BIN_SIZE=0.1
pergroup_tree_%_heights.hists:    ANALYSIS_TREE_SECTION=heights
pergroup_tree_%_relheights.hists: ANALYSIS_TREE_HISTS_BIN_SIZE=0.02
pergroup_tree_%_relheights.hists: ANALYSIS_TREE_SECTION=relheights

tree_%.hists:
	$(PRELOG)
	@for category in min max mean stddev; do \
	    for s1 in $(ANALYSIS_SUBGROUPS); do \
		file=trees_$${s1}.summary.dir/tree_$(ANALYSIS_TREE_SECTION).data; \
		if test -e $${file}; then \
			    printf "bin\t%s\n" $${s1} > $@_tmp_$${category}_$${s1}; \
			    grep -v "total" $${file} |\
			    $(YT)csv_cut.py $${category} -v 0 |\
			    $(YT)data2histogram.py \
				--min-value=0.0 \
				--bin-size=$(ANALYSIS_TREE_HISTS_BIN_SIZE) \
				--no-empty-bins |\
			    grep -v "bin" >> $@_tmp_$${category}_$${s1}; \
		fi; \
	    done; \
	    $(YT)combine_histograms.py -v 0 $@_tmp_* \
	    > $@_$${category}; \
	    rm -f $@_tmp_*; \
	done
	$(EPILOG)

pergroup_tree_%.hists:
	$(PRELOG)
	@for s1 in $(ANALYSIS_SUBGROUPS); do \
		for category in min max mean median stddev; do \
		file=trees_$${s1}.summary.dir/tree_$(ANALYSIS_TREE_SECTION).data; \
		if test -e $${file}; then \
			    printf "bin\t%s\n" $${category} > $@_tmp_$${s1}_$${category}; \
			    grep -v "total" $${file} |\
			    $(YT)csv_cut.py $${category} -v 0 |\
			    $(YT)data2histogram.py \
				--min-value=0.0 \
				--cumulative \
				--bin-size=$(ANALYSIS_TREE_HISTS_BIN_SIZE) \
				--no-empty-bins |\
			    grep -v "bin" >> $@_tmp_$${s1}_$${category}; \
		fi; \
	    done; \
	    $(YT)combine_histograms.py 	--missing="na" -v 0 $@_tmp_* \
	    > $@_$${s1}; \
	    rm -f $@_tmp_*; \
	done
	$(EPILOG)


tree_%.stats:
	$(PRELOG)
	@printf "section\tcategory\t" > $@
	@$(YT)data2stats.py --write-header -v 0  >> $@
	@for category in min max mean stddev; do \
		for s1 in $(ANALYSIS_SUBGROUPS); do \
		      	file=trees_$${s1}.summary.dir/tree_$*.data; \
			if test -e $${file}; then \
			    printf "%s\t" $${s1} >> $@; \
			    grep -v "total" $${file} |\
			    $(YT)csv_cut.py $${category} -v 0 |\
			    $(YT)data2stats.py --skip-header -v 0 --flat --format="%6.4f" --flat >> $@; \
			fi; \
		done; \
	done
	$(EPILOG)

###################################################################
subtrees.plot:
	$(PRELOG)
	@find data.dir -name "subtree_*_fixed_w_ml.tree" -exec cat {} \; |\
	python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_orthology_multiple.py \
		--filename-species-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		$(DUPLICATIONS_EXTRA_OPTIONS) \
		--output-pattern=$@_%s \
		--print-totals \
		--print-species-svg \
		--output-pattern-svg="test_%s.svg" \
		--svg-branch-lengths="uniform" \
		--filename-node-types=subtrees.summary_nodes \
	> $@
	$(EPILOG)

malis.summary:
	$(PRELOG)
	@cut -f 2 input.map | sort | uniq | grep "^[0-9]" |\
	python $(DIR_SCRIPTS_TOOLS)mali2summary.py \
		--pattern-mali=data.dir/cluster_%s.dir/cluster_%s.masked_mali > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Create table for with trees
#######################################################################################
%.create-table-trees:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	group_id INT, \
	nh TEXT, \
	svg TEXT );" \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (group_id);" $(TO_NULL) 
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Build ks and ka trees
#######################################################################################
summary.dir/%_trees: analysis-%.dir/trees all.map_id2pos
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_orthology_multiple.py \
		--filename-species-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		--filename-species2colour=$(PARAM_ANALYSIS_DUPLICATIONS_COLOURS) \
		--filename-species2url=$(PARAM_ANALYSIS_DUPLICATIONS_URLS) \
		--filename-species2name=$(PARAM_ANALYSIS_DUPLICATIONS_TRANSLATION) \
		--filename-locations=all.map_id2pos \
		--max-separation=$(PARAM_ANALYSIS_DUPLICATIONS_MAX_SEPARATION) \
		--svg-no-legend \
		--gene-regex="^[^|]+\|([^|]+)" \
		--print-svg \
		--output-format="table" \
		--log=$@.log \
		< $< > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Load ks trees into table.
#######################################################################################
summary.dir/ks_trees.load: summary.dir/ks_trees
	$(PRELOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_KS_TREES);" > /dev/null
	@grep -v -e "#" -e "^name" < $< |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_KS_TREES) FROM STDIN WITH NULL AS 'na'" > $@ 
	@$(PSQL_CONNECTION) "ANALYSE $(PARAM_TABLE_NAME_KS_TREES)" >> $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_KS_TREES): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_KS_TREES);' -t `"  >> $(LOG)
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Load ka trees into table.
#######################################################################################
summary.dir/ka_trees.load: summary.dir/ka_trees
	$(PRELOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_KA_TREES);" > /dev/null
	@grep -v -e "#" -e "^name" < $< |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_KA_TREES) FROM STDIN WITH NULL AS 'na'" > $@ 
	@$(PSQL_CONNECTION) "ANALYSE $(PARAM_TABLE_NAME_KA_TREES)" >> $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_KA_TREES): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_KA_TREES);' -t `"  >> $(LOG)
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Create table for ancestral sequences
#######################################################################################
%.create-table-ancestral-sequences:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	group_id INT, \
	taxon TEXT, \
	accuracy_site FLOAT, \
	accuracy_sequence FLOAT, \
	sequence TEXT ); " \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (group_id);" $(TO_NULL) 
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Compile information about ancestral sequences
#######################################################################################
summary.dir/ancestral_sequences.table:
	$(PRELOG)
	@rm -f $@.err $@.tmp
	@for dir in data.dir/cluster_*.dir; do \
		cluster_id=$${dir#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		file_out=$${dir}/cluster_$${cluster_id}_fixed_w.output; \
		file_rst=$${dir}/cluster_$${cluster_id}_fixed_w.paml.dir/rst; \
		if test -e $${file_out} && test -e $${file_rst}; then \
			printf "%s\t%s\t%s\t%s\n" $${file_out} $${cluster_id} "" $${file_rst}>> $@.tmp; \
		else \
			echo "file not found: $${file}" >> $@.err; \
		fi; \
	done
	@python $(DIR_SCRIPTS_GENEPREDICTION)WrapperCodeML.py \
		--flavour=codeml \
		--analysis=branch-fixed-kaks \
		--parse-output=ancestral-sequence \
		--parse-batch=$@.tmp \
		--parse-tabular \
	> $@
	@rm -f $@.tmp
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Load ancestral sequences into table
#######################################################################################
summary.dir/ancestral_sequences.load: summary.dir/ancestral_sequences.table
	$(PRELOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_ANCESTRAL_SEQUENCES);" > /dev/null
	@grep -v -e "#" -e "^id" -e "^parsing error" < $< |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_ANCESTRAL_SEQUENCES) FROM STDIN WITH NULL AS 'na'" > $@ 
	@$(PSQL_CONNECTION) "ANALYSE $(PARAM_TABLE_NAME_ANCESTRAL_SEQUENCES)" >> $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_ANCESTRAL_SEQUENCES): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_ANCESTRAL_SEQUENCES);' -t `"  >> $(LOG)
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Create table for paralog trees
#######################################################################################
%.create-table-groups-trees:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	group_id INT, \
	fixed_w_dn TEXT, \
	fixed_w_ds TEXT, \
	fixed_w_dnds TEXT, \
	fixed_w_ndn TEXT, \
	fixed_w_sds TEXT, \
	variable_w_dn TEXT, \
	variable_w_ds TEXT, \
	variable_w_dnds TEXT, \
	variable_w_ndn TEXT, \
	variable_w_sds TEXT)" \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (group_id);" $(TO_NULL) 

#######################################################################################
#######################################################################################
#######################################################################################
## Combine trees from ortholog sets
#######################################################################################
GROUPS_SECTIONS=fixed_w_ka fixed_w_ks fixed_w_kaks fixed_w_ndn fixed_w_sds \
	variable_w_ka variable_w_ks variable_w_kaks variable_w_ndn variable_w_sds

summary.dir/groups.trees:
	$(PRELOG)
	@for section in $(GROUPS_SECTIONS); do \
		if test -e analysis.dir/trees_$${section}.trees; then \
			awk '/^>/ { group_id = substr($$1,2); next; } { printf("%i\t%s\n", group_id, $$1); }' \
				<  analysis.dir/trees_$${section}.trees > $@.tmp_$${section}; \
		fi; \
	done
	@python $(DIR_SCRIPTS_TOOLS)combine_tables.py \
		--no-titles \
		--keep-empty \
		$(GROUPS_SECTIONS:%=$@.tmp_%) > $@
	@rm -f $@.tmp*
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Load group trees into table
#######################################################################################
summary.dir/groups.trees.load: summary.dir/groups.trees
	$(PRELOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_GROUPS_TREES);" > /dev/null
	@grep -v -e "#" -e "^name" < $< |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_GROUPS_TREES) FROM STDIN WITH NULL AS 'na'" > $@ 
	@$(PSQL_CONNECTION) "ANALYSE $(PARAM_TABLE_NAME_GROUPS_TREES)" >> $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_GROUPS_TREES): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_GROUPS_TREES);' -t `"  >> $(LOG)
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Summary targets
#######################################################################################
clean-subdir:
	rm -rf *.output *.ctl *.dir *.log *.map *.phylip *.tree

clean:
	$(PRELOG)
	@rm -rf data.{run,dir,prepare,finish} all.exons all.map_id2pos
	$(EPILOG)

#######################################################################################
include $(DIR_SCRIPTS_GENEPREDICTION)/makefiles/Makefile.common

