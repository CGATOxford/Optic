################################################################################
#   Gene prediction pipeline 
#
#   $Id: Makefile.compare 1831 2008-05-08 11:59:26Z andreas $
#
#   Copyright (C) 2004 Andreas Heger
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License
#   as published by the Free Software Foundation; either version 2
#   of the License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#################################################################################
SHELL=/bin/bash --login

INPUT_PEPTIDES?=peptides.fasta
INPUT_GENOMES?=$(wildcard genome*.fasta)

LOG=log

################################################
## Section parameters: start
################################################
## project name
PARAM_PROJECT_NAME?=dog_vs_human_all2
################################################
## directories
## directory where gene prediction scripts can be found
DIR_SCRIPTS_GENEPREDICTION?=/net/cpp-group/andreas/src/test/gpipe/
## directory where various helper scripts can be found
DIR_SCRIPTS_TOOLS?=/net/cpp-group/scripts/tools/
## shared directory, path for submit host
DIR_TMP_SHARED_LOCAL?=/net/cpp-group/andreas/tmp/$(PARAM_PROJECT_NAME)/
## shared directory, path for cluster node
DIR_TMP_SHARED_REMOTE?=/net/cpp-group/andreas/tmp/$(PARAM_PROJECT_NAME)/

################################################
## Cluster parameters
## queue to submit to
PARAM_QUEUE?=bc1.q,bc2.q

################################################
## Database connection parameters
## database
PARAM_PSQL_DATABASE?=andreas
## host
PARAM_PSQL_HOST?=fgu202
## user
PARAM_PSQL_USER?=andreas
## schema
PARAM_PSQL_SCHEMA?=$(PARAM_PROJECT_NAME)
## predictions table
PARAM_TABLE_NAME_PREDICTIONS?=$(PARAM_PSQL_SCHEMA).predictions
## summary table
PARAM_TABLE_NAME_QUERIES?=$(PARAM_PSQL_SCHEMA).queries
## exons table
PARAM_TABLE_NAME_EXONS?=$(PARAM_PSQL_SCHEMA).exons
## summary of exon structures
PARAM_TABLE_NAME_EXONS_SUMMARY?=$(PARAM_PSQL_SCHEMA).exons_summary
## predicted genic regions
PARAM_TABLE_NAME_REGIONS?=$(PARAM_PSQL_SCHEMA).regions
## kaks values for predictions
PARAM_TABLE_NAME_KAKS?=$(PARAM_PSQL_SCHEMA).kaks
## quality indices for predictions
PARAM_TABLE_NAME_QUALITY?=$(PARAM_PSQL_SCHEMA).quality
## quality indices for predictions
PARAM_TABLE_NAME_GENES?=$(PARAM_PSQL_SCHEMA).genes
## predictions table
PARAM_TABLE_NAME_SELECTED_PREDICTIONS?=$(PARAM_PSQL_SCHEMA).selected_predictions
## overview table
PARAM_TABLE_NAME_OVERVIEW?=$(PARAM_PSQL_SCHEMA).overview

## schema
PARAM_REFERENCE_PSQL_SCHEMA?=dog_vs_human_ref2
## predictions table
PARAM_REFERENCE_TABLE_NAME_PREDICTIONS?=$(PARAM_REFERENCE_PSQL_SCHEMA).overview
## summary table
PARAM_REFERENCE_TABLE_NAME_QUERIES?=$(PARAM_REFERENCE_PSQL_SCHEMA).queries
## exons table
PARAM_REFERENCE_TABLE_NAME_EXONS?=$(PARAM_REFERENCE_PSQL_SCHEMA).exons
## summary of exon structures
PARAM_REFERENCE_TABLE_NAME_EXONS_SUMMARY?=$(PARAM_REFERENCE_PSQL_SCHEMA).exons_summary
## predicted genic regions
PARAM_REFERENCE_TABLE_NAME_REGIONS?=$(PARAM_REFERENCE_PSQL_SCHEMA).regions
## kaks values for predictions
PARAM_REFERENCE_TABLE_NAME_KAKS?=$(PARAM_REFERENCE_PSQL_SCHEMA).kaks
## quality indices for predictions
PARAM_REFERENCE_TABLE_NAME_QUALITY?=$(PARAM_REFERENCE_PSQL_SCHEMA).quality
## quality indices for predictions
PARAM_REFERENCE_TABLE_NAME_GENES?=$(PARAM_REFERENCE_PSQL_SCHEMA).genes
## overview table
PARAM_REFERENCE_TABLE_NAME_OVERVIEW?=$(PARAM_REFERENCE_PSQL_SCHEMA).overview


## quality indices for predictions
PARAM_TABLE_NAME_ASSIGNMENTS_PREFIX?=$(PARAM_PSQL_SCHEMA).cg3_assignments
PARAM_TABLE_NAME_ASSIGNMENTS?=$(PARAM_TABLE_NAME_ASSIGNMENTS_PREFIX)_ref_vs_target
PARAM_TABLE_NAME_ASSIGNMENTS_REF2TARGET?=$(PARAM_TABLE_NAME_ASSIGNMENTS_PREFIX)_ref_2_target
PARAM_TABLE_NAME_ASSIGNMENTS_TARGET2REF?=$(PARAM_TABLE_NAME_ASSIGNMENTS_PREFIX)_target_2_ref

PARAM_ASSIGNMENTS_MIN_COVERAGE_REFERENCE=80
PARAM_ASSIGNMENTS_MIN_COVERAGE_TARGET=80

PARAM_BEST_MIN_SCORE=80

PARAM_QUALITY_SELECTED?=('CG', 'UG', 'DP', 'PP', 'SP')

## minimum score for high scoring segments
PARAM_MIN_HIGHSCORE?=200

PARAM_FULL_MIN_COVERAGE=90
PARAM_FULL_MIN_PIDE=90
PARAM_FULL_MIN_EVALUE=-100

################################################
# Section parameters: end
################################################


################################################
################################################
################################################
################################################
################################################
################################################

################################################
## Database connectivity
## ENSEMBL
ENSEMBL_CMD_MYSQL?=mysql -h$(PARAM_ENSEMBL_HOST) -u$(PARAM_ENSEMBL_USER)
## Postgres
CONNECTION=psql -h $(PARAM_PSQL_HOST) -d $(PARAM_PSQL_DATABASE) $(PARAM_PSQL_USER) -c
CMD_TABLE_PREFIX=`echo $* | perl -p -e "s/\./_/g"`


TABLES_ASSIGNMENTS=$(PARAM_TABLE_NAME_ASSIGNMENTS)

TARGETS_TABLES=$(TABLES_ASSIGNMENTS:%=%.assignments) \
	$(TABLES_ASSIGNMENTS:%=%.load) \
	$(TABLES_ASSIGNMENTS:%=%.set_best) \


VIEWS=$(TABLES_ASSIGNMENTS:%=%_ref) $(TABLES_ASSIGNMENTS:%=%_target) $(TABLES_ASSIGNMENTS:%=%_both)

TARGETS_VIEWS=$(VIEWS:%=%.create_view)

include $(DIR_SCRIPTS_GENEPREDICTION)/makefiles/Makefile.plot

TARGETS_IMAGES=$(TABLES_ASSIGNMENTS:%=%_length.png) \
		$(TABLES_ASSIGNMENTS:%=%_genomelength.png) \
		$(TABLES_ASSIGNMENTS:%=%_exondifference.png)

TARGETS_COUNTS= $(VIEWS:%=%.counts_assignments) \
		$(VIEWS:%=%.counts_genome_sbjct_length) \
		$(VIEWS:%=%.counts_sbjct_length) \
		$(VIEWS:%=%.counts_exons) \
		$(VIEWS:%=%.counts_extensions) 

COUNTS=counts

images: $(TARGETS_IMAGES)

tables: $(TARGETS_TABLES)

views: $(TARGETS_VIEWS)

counts: counts_overview counts_overlap \
	$(TARGETS_COUNTS)

counts2: $(VIEWS:%=%.counts_extensions) 


all: create_tables tables views counts

########################################################
## predictions without any overlap and quality status CG
target_cg_extra.list:
	$(CONNECTION) \
	"SELECT tp.prediction_id, tp.query_token, tp.sbjct_token, tp.sbjct_strand, \
	tp.sbjct_genome_from, tp.sbjct_genome_to, \
	tp.query_coverage, tp.pidentity, tp.nintrons + 1 \
	FROM \
	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp \
	LEFT JOIN $(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp ON \
	(rp.sbjct_token = tp.sbjct_token AND rp.sbjct_strand = tp.sbjct_strand AND \
	(OVERLAP( rp.sbjct_genome_from, rp.sbjct_genome_to, tp.sbjct_genome_from, tp.sbjct_genome_to) > 0)) \
	WHERE  \
	rp.query_token IS NULL \
	AND tp.class='CG' \
	ORDER BY tp.sbjct_token, tp.sbjct_strand, tp.sbjct_genome_from " \
	-t -A -F"	" > $@

########################################################
## predictions without any overlap and quality status CG
## and more than one exon
target_cg_me_extra.list:
	$(CONNECTION) \
	"SELECT tp.prediction_id, tp.query_token, tp.sbjct_token, tp.sbjct_strand, \
	tp.sbjct_genome_from, tp.sbjct_genome_to, \
	tp.query_coverage, tp.pidentity, tp.nintrons + 1 \
	FROM \
	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp \
	LEFT JOIN $(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp ON \
	(rp.sbjct_token = tp.sbjct_token AND rp.sbjct_strand = tp.sbjct_strand AND \
	(OVERLAP( rp.sbjct_genome_from, rp.sbjct_genome_to, tp.sbjct_genome_from, tp.sbjct_genome_to) > 0)) \
	WHERE  \
	rp.query_token IS NULL AND \
	tp.class='CG' AND \
	tp.nintrons > 0 \
	ORDER BY tp.sbjct_token, tp.sbjct_strand, tp.sbjct_genome_from " \
	-t -A -F"	" > $@

########################################################
## Compile a list of putative sequencing errors.
## Multi-exonic predictions with one frame-shift/stop-codon
## are often due to sequencing errors
target_dp_sequencing_errors.list:
	$(CONNECTION) \
	"SELECT tp.prediction_id, tp.query_token, tp.sbjct_token, tp.sbjct_strand, tp.sbjct_genome_from, tp.sbjct_genome_to, \
	tp.query_coverage, tp.pidentity, tp.nintrons + 1 \
	FROM \
	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp \
	LEFT JOIN $(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp ON \
	(rp.sbjct_token = tp.sbjct_token AND rp.sbjct_strand = tp.sbjct_strand AND \
	(OVERLAP( rp.sbjct_genome_from, rp.sbjct_genome_to, tp.sbjct_genome_from, tp.sbjct_genome_to) > 0)) \
	WHERE  \
	tp.nintrons > 0 \
	AND tp.nframeshifts + tp.nstopcodons = 1 \
	AND rp.query_token IS NULL \
	AND tp.class='DP' \
	ORDER BY tp.sbjct_token, tp.sbjct_strand, tp.sbjct_genome_from " \
	-t -A -F"	" > $@

## Compile a list of predictions converted to genes by ensemble, but
## pseudogenes for us.
## Multi-exonic predictions with one frame-shift/stop-codon
## are often due to sequencing errors
target_dp_conversions.list:
	$(CONNECTION) \
	"SELECT DISTINCT ON (tp.prediction_id) \
	tp.prediction_id, tp.query_token, tp.sbjct_token, tp.sbjct_strand, tp.sbjct_genome_from, tp.sbjct_genome_to, \
	tp.query_coverage, tp.pidentity, tp.nintrons + 1, tp.nstopcodons, tp.nframeshifts \
	FROM \
	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp \
	LEFT JOIN $(PARAM_TABLE_NAME_QUALITY) AS tq ON (tp.prediction_id = tq.prediction_id) \
	LEFT JOIN $(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp ON \
	(rp.sbjct_token = tp.sbjct_token AND rp.sbjct_strand = tp.sbjct_strand AND \
	 (OVERLAP( rp.sbjct_genome_from, rp.sbjct_genome_to, tq.sbjct_genome_from, tq.sbjct_genome_to) > 0)) \
	LEFT JOIN $(PARAM_TABLE_NAME_PREDICTIONS) AS tp2 ON \
	(tp2.sbjct_token = tp.sbjct_token AND tp2.sbjct_strand = tp.sbjct_strand) \
	LEFT JOIN $(PARAM_TABLE_NAME_QUALITY) AS tq2 ON \
	(tp2.prediction_id = tq2.prediction_id AND \
	 tq2.class IN ('CG','UG') AND  \
	 (OVERLAP( tp.sbjct_genome_from, tp.sbjct_genome_to, tq2.sbjct_genome_from, tq2.sbjct_genome_to) > 0)) \
	WHERE  \
	tp.nintrons > 0 \
	AND tp.nframeshifts + tp.nstopcodons = 1 \
	AND rp.query_token IS NOT NULL \
	AND tq.class='DP' \
	AND tq2.prediction_id IS NULL \
	ORDER BY tp.prediction_id, tp.sbjct_token, tp.sbjct_strand, tq.sbjct_genome_from " \
	-t -A -F"	" > $@

target_dpall_sequencing_errors.list:
	$(CONNECTION) \
	"SELECT tp.prediction_id, tp.query_token, tp.sbjct_token, tp.sbjct_strand, tp.sbjct_genome_from, tp.sbjct_genome_to, \
	tp.query_coverage, tp.pidentity, tp.nintrons + 1 \
	FROM \
	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp \
	LEFT JOIN $(PARAM_TABLE_NAME_QUALITY) AS tq ON (tp.prediction_id = tq.prediction_id) \
	LEFT JOIN $(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp ON \
	(rp.sbjct_token = tp.sbjct_token AND rp.sbjct_strand = tp.sbjct_strand AND \
	(OVERLAP( rp.sbjct_genome_from, rp.sbjct_genome_to, tq.sbjct_genome_from, tq.sbjct_genome_to) > 0)) \
	WHERE  \
	tp.nintrons > 0 \
	AND tp.nframeshifts + tp.nstopcodons >= 1 \
	AND rp.query_token IS NULL \
	AND class='DP' \
	ORDER BY tp.sbjct_token, tp.sbjct_strand, tq.sbjct_genome_from " \
	-t -A -F"	" > $@

target_sequencing_errors.list:
	$(CONNECTION) \
	"SELECT tp.prediction_id, tp.query_token, tp.sbjct_token, tp.sbjct_strand, tp.sbjct_genome_from, tp.sbjct_genome_to, \
	tp.query_coverage, tp.pidentity, tp.nintrons + 1, tq.class, tp.nframeshifts, tp.nstopcodons \
	FROM \
	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp \
	LEFT JOIN $(PARAM_TABLE_NAME_QUALITY) AS tq ON (tp.prediction_id = tq.prediction_id) \
	LEFT JOIN $(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp ON \
	(rp.sbjct_token = tp.sbjct_token AND rp.sbjct_strand = tp.sbjct_strand AND \
	(OVERLAP( rp.sbjct_genome_from, rp.sbjct_genome_to, tq.sbjct_genome_from, tq.sbjct_genome_to) > 0)) \
	WHERE  \
	tp.nintrons > 0 \
	AND tp.nframeshifts + tp.nstopcodons > 1 \
	AND rp.query_token IS NULL \
	AND tp.query_coverage > 80  \
	ORDER BY tp.sbjct_token, tp.sbjct_strand, tq.sbjct_genome_from " \
	-t -A -F"	" > $@

target_extra.list:
	$(CONNECTION) \
	"SELECT tp.prediction_id, tp.query_token, tp.sbjct_token, tp.sbjct_strand, tp.sbjct_genome_from, tp.sbjct_genome_to, \
	tp.query_coverage, tp.pidentity, tp.nintrons + 1 \
	FROM \
	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp \
	LEFT JOIN $(PARAM_TABLE_NAME_QUALITY) AS tq ON (tp.prediction_id = tq.prediction_id) \
	LEFT JOIN $(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp ON \
	(rp.sbjct_token = tp.sbjct_token AND rp.sbjct_strand = tp.sbjct_strand AND \
	(OVERLAP( rp.sbjct_genome_from, rp.sbjct_genome_to, tq.sbjct_genome_from, tq.sbjct_genome_to) > 0)) \
	WHERE  \
	rp.query_token IS NULL \
	AND class IN ('CG', 'UG', 'CF', 'DP', 'PP', 'SP') \
	ORDER BY tp.sbjct_token, tp.sbjct_strand, tq.sbjct_genome_from " \
	-t -A -F"	" > $@

## convert list of extra predictions to genes
%.genes: %.list
	cut -f 1 $*.list > $@_tmp
	python $(DIR_SCRIPTS_GENEPREDICTION)gpipe/predictions2genes.py \
	--filter-predictions=$@_tmp \
	--table-predictions=$(PARAM_TABLE_NAME_PREDICTIONS) > $@
	rm -f $@_tmp

########################################################
## missed predictions
reference_extra.list:
	$(CONNECTION) \
	"SELECT rp.prediction_id, rp.query_token, rp.sbjct_token, rp.sbjct_strand, rp.sbjct_genome_from, rp.sbjct_genome_to, \
	rp.query_coverage, rp.pidentity, rp.nintrons + 1 \
	FROM \
	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) AS rp \
	LEFT JOIN $(PARAM_TABLE_NAME_PREDICTIONS) as tp ON \
	(rp.sbjct_token = tp.sbjct_token AND rp.sbjct_strand = tp.sbjct_strand AND \
	    (rp.sbjct_genome_from BETWEEN tp.sbjct_genome_from AND tp.sbjct_genome_to OR \
	     rp.sbjct_genome_to   BETWEEN tp.sbjct_genome_from AND tp.sbjct_genome_to OR \
	    (rp.sbjct_genome_from < tp.sbjct_genome_from AND rp.sbjct_genome_to > tp.sbjct_genome_to ))) \
	WHERE  \
	tp.query_token IS NULL \
	ORDER BY rp.sbjct_token, rp.sbjct_strand, rp.sbjct_genome_from " \
	-t -A -F"	" > $@


########################################################
## compare exons (previously: cds.compare)
exons%.compare: reference/export_exons%.gff1 target/export_exons%.gff1
	sort -k1,1 -k7,7 -k4,4n < target/export_exons$*.gff1 |\
	python $(DIR_SCRIPTS_GENEPREDICTION)combine_gff.py --write-full > $@.tmp_t
	sort -k1,1 -k7,7 -k4,4n < reference/export_exons$*.gff1 |\
	python $(DIR_SCRIPTS_GENEPREDICTION)combine_gff.py --write-full > $@.tmp_r
	python $(DIR_SCRIPTS_GENEPREDICTION)diff_gff.py --write-full --write-equivalent $@.tmp_t $@.tmp_r > $@
	rm -f $@.tmp_t $@.tmp_r

########################################################
## compare step3
## make uniq by match, because overlaps have note been removed yet.
step3.compare.%.counts:
	grep -v "#" $*/step3.predictions |\
	cut -f 2,3,4,23,24 |\
	sort |\
	uniq |\
	cut -f 1,2,3 |\
	uniq -c |\
	awk '{printf("%s\t%s\t%s\t%i\n", $$2, $$3, $$4, $$1);}' > $@

## high scoring counts
step3.compare.%.hs_counts:
	awk '!/^#/ && $$6 > $(PARAM_MIN_HIGHSCORE)' < $*/step3.predictions |\
	cut -f 2,3,4,23,24 |\
	sort |\
	awk '{ if ( (l != $$1) && \
		((la <= $$4 && lb >= $$5) ||\
		    (la <= $$4 && lb >= $$4) ||\
		    (la >= $$4 && lb <= $$5) ||\
		    (la <= $$5 && lb >= $$5) ) ) \
		{ next; } print; la=$$4; lb=$$5; l=$$1; }' |\
	cut -f 1,2,3 |\
	uniq -c |\
	awk '{printf("%s\t%s\t%s\t%i\n", $$2, $$3, $$4, $$1);}' > $@

step3.compare.queries: step3.compare.target.counts step3.compare.reference.counts 
	python $(DIR_SCRIPTS_TOOLS)combine_tables.py \
	<(cut -f 1,4 step3.compare.target.counts | sort |\
	  awk '{ if ($$1!=l) { if (l) { printf("%s\t%i\n",l,a); } a=0;} l=$$1; a+=$$2; } \
		END { printf("%s\t%i\n",l,a); }') \
	<(cut -f 1,4 step3.compare.reference.counts | sort |\
	  awk '{ if ($$1!=l) { if (l) { printf("%s\t%i\n",l,a); } a=0;} l=$$1; a+=$$2; } \
		END { printf("%s\t%i\n",l,a); }') > $@

## only take high-scoring queries
step3.compare.hs_queries: step3.compare.target.hs_counts step3.compare.reference.hs_counts 
	python $(DIR_SCRIPTS_TOOLS)combine_tables.py \
	<(cut -f 1,4 step3.compare.target.hs_counts | sort |\
	  awk '{ if ($$1!=l) { if (l) { printf("%s\t%i\n",l,a); } a=0;} l=$$1; a+=$$2; } \
		END { printf("%s\t%i\n",l,a); }') \
	<(cut -f 1,4 step3.compare.reference.hs_counts | sort |\
	  awk '{ if ($$1!=l) { if (l) { printf("%s\t%i\n",l,a); } a=0;} l=$$1; a+=$$2; } \
		END { printf("%s\t%i\n",l,a); }') > $@

step3.compare.%.summary: step3.compare.%
	awk '$$2 ~ /na/ || $$3 ~ /na/ \
		{ if ($$2 == "na") { lna+=1; }; \
		  if ($$3 == "na") { rna+=1; }; \
		  next; \
		} \
	     { \
		npairs++; \
		if ($$2>$$3) {dl+=1; } else { if ($$3>$$2) {dr+=1} else { ds+=1} }; \
	     } \
	      END { printf("pairs=%i, same=%i, more left=%i, more right=%i, na left=%i, na right=%i\n", npairs, ds, dl, dr, lna, rna); }' \
	< step3.compare.$*

step3.compare.contigs:
	python $(DIR_SCRIPTS_TOOLS)combine_tables.py \
	<(cut -f 2,4 step3.compare.target.counts | sort |\
	  awk '{ if ($$1!=l) { if (l) { printf("%s\t%i\n",l,a); } a=0;} l=$$1; a+=$$2; } \
		END { printf("%s\t%i\n",l,a); }') \
	<(cut -f 2,4 step3.compare.reference.counts | sort |\
	  awk '{ if ($$1!=l) { if (l) { printf("%s\t%i\n",l,a); } a=0;} l=$$1; a+=$$2; } \
		END { printf("%s\t%i\n",l,a); }') > $@


step3.compare: step3.compare.target.counts step3.compare.reference.counts \
	step3.compare.queries

########################################################
## missed exons
reference_extra_exons.list:
	$(CONNECTION) \
	"SELECT rp.prediction_id, rp.query_token, \
	rp.sbjct_token, rp.sbjct_strand, \
	re.genome_exon_from, re.genome_exon_to, \
	rp.query_coverage, rp.pidentity, rp.nintrons + 1 \
	FROM \
	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) AS rp \
	INNER JOIN $(PARAM_REFERENCE_TABLE_NAME_EXONS) AS re ON \
	(re.prediction_id = rp.prediction_id) \
	INNER JOIN $(PARAM_TABLE_NAME_PREDICTIONS) as tp ON \
	(rp.sbjct_token = tp.sbjct_token AND rp.sbjct_strand = tp.sbjct_strand) \
	LEFT JOIN $(PARAM_TABLE_NAME_EXONS) AS te ON \
	( (te.prediction_id = tp.prediction_id ) AND \
	    (re.genome_exon_from BETWEEN te.genome_exon_from AND te.genome_exon_to OR \
	     re.genome_exon_to   BETWEEN te.genome_exon_from AND te.genome_exon_to OR \
	    (re.genome_exon_from < te.genome_exon_from AND re.genome_exon_to > te.genome_exon_to ))) \
	WHERE  \
	te.prediction_id IS NULL \
	ORDER BY rp.sbjct_token, rp.sbjct_strand, re.genome_exon_from " \
	-t -A -F"	" > $@


########################################################
## compare length of peptides
%_length.data:
	echo -e "target\treference" > $@
	$(CONNECTION) \
	"SELECT tp.sbjct_to - tp.sbjct_from + 1, rp.sbjct_to - rp.sbjct_from + 1 \
	FROM \
	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
	$* AS a \
	WHERE  \
	a.prediction_id1 = rp.prediction_id AND \
	a.prediction_id2 = tp.prediction_id AND \
	a.is_best_per_gene = TRUE" \
	-t -A -F"	" >> $@

%_genomelength.data:
	echo -e "target\treference" > $@
	$(CONNECTION) \
	"SELECT tp.sbjct_genome_to - tp.sbjct_genome_from , rp.sbjct_genome_to - rp.sbjct_genome_from  \
	FROM \
	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
	$(PARAM_TABLE_NAME_SELECTED_PREDICTIONS) AS tp, \
	$* AS a \
	WHERE  \
	a.prediction_id1 = rp.prediction_id AND \
	a.prediction_id2 = tp.prediction_id AND \
	a.is_best_per_gene = TRUE" \
	-t -A -F"	" >> $@

%_exondifference.data:
	echo -e "difference\tcounts" > $@
	$(CONNECTION) \
	"SELECT tp.nintrons - rp.nintrons, COUNT(*) \
	FROM \
	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
	$(PARAM_TABLE_NAME_QUALITY) AS tq, \
	$* AS a \
	WHERE  \
	a.prediction_id1 = rp.prediction_id AND \
	a.prediction_id2 = tp.prediction_id AND \
	a.is_best_per_gene = TRUE AND \
	tq.prediction_id = tp.prediction_id \
	GROUP BY tp.nintrons - rp.nintrons" \
	-t -A -F"	" >> $@

%.wiki:
	perl -p -e "s/\t/ | /g" < $* |\
	awk '/\|/ {printf("| %s |\n", $$0); next} \
	     /^\#/ {printf("\n---+++ %s\n", $$0); next} \
	     {print}' \
	> $@
########################################################
## counts
counts_overview:
	echo "# Overview: ">> $(COUNTS)
	echo -e "set\tsource\ttokens\tpredictions\tgenes" >> $(COUNTS)
	echo -e -n "reference\t$(PARAM_REFERENCE_PSQL_SCHEMA)\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(distinct p.query_token), COUNT(p.prediction_id), COUNT(DISTINCT p.gene_id) \
	FROM \
	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) AS p" \
	-t -A -F"	" >> $(COUNTS)
	echo -e -n "target\t$(PARAM_PSQL_SCHEMA)\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(distinct p.query_token), COUNT(p.prediction_id), COUNT(DISTINCT p.gene_id) \
	FROM \
	$(PARAM_TABLE_NAME_SELECTED_PREDICTIONS) AS p" \
	-t -A -F"	" >> $(COUNTS)

counts_overlap:
	echo "# Overlap:" >> $(COUNTS)
	echo -e "category\tpredictions\tgenes" >> $(COUNTS)
	echo -ne "ref hit by target\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(distinct rp.prediction_id), count(distinct rp.gene_id) \
	FROM \
	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp \
	LEFT JOIN $(PARAM_TABLE_NAME_SELECTED_PREDICTIONS) AS tp \
	ON (rp.sbjct_token = tp.sbjct_token AND rp.sbjct_strand = tp.sbjct_strand AND \
	OVERLAP( rp.sbjct_genome_from, rp.sbjct_genome_to, tp.sbjct_genome_from, tp.sbjct_genome_to) > 0) \
	WHERE  \
	tp.prediction_id IS NOT NULL; "\
	-t -A -F"	" >> $(COUNTS)
	echo -ne "target hit by ref\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(distinct tp.prediction_id), count(distinct tp.gene_id) \
	FROM \
	$(PARAM_TABLE_NAME_SELECTED_PREDICTIONS) as tp \
	LEFT JOIN $(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) AS rp \
	ON (rp.sbjct_token = tp.sbjct_token AND rp.sbjct_strand = tp.sbjct_strand AND \
	OVERLAP( rp.sbjct_genome_from, rp.sbjct_genome_to, tp.sbjct_genome_from, tp.sbjct_genome_to) > 0) \
	WHERE  \
	rp.prediction_id IS NOT NULL; "\
	-t -A -F"	" >> $(COUNTS)
	echo -ne "ref without target\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(distinct rp.prediction_id), count(distinct rp.gene_id) \
	FROM \
	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp \
	LEFT JOIN $(PARAM_TABLE_NAME_SELECTED_PREDICTIONS) AS tp \
	ON (rp.sbjct_token = tp.sbjct_token AND rp.sbjct_strand = tp.sbjct_strand AND \
	OVERLAP( rp.sbjct_genome_from, rp.sbjct_genome_to, tp.sbjct_genome_from, tp.sbjct_genome_to) > 0) \
	WHERE  \
	tp.prediction_id IS NULL; "\
	-t -A -F"	" >> $(COUNTS)
	echo -ne "target without ref\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(distinct tp.prediction_id), count(distinct tp.gene_id) \
	FROM \
	$(PARAM_TABLE_NAME_SELECTED_PREDICTIONS) as tp \
	LEFT JOIN $(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) AS rp \
	ON (rp.sbjct_token = tp.sbjct_token AND rp.sbjct_strand = tp.sbjct_strand AND \
	OVERLAP( rp.sbjct_genome_from, rp.sbjct_genome_to, tp.sbjct_genome_from, tp.sbjct_genome_to) > 0) \
	WHERE  \
	rp.prediction_id IS NULL; "\
	-t -A -F"	" >> $(COUNTS)

%.counts_assignments:
	echo "# Assignments for $*:" >> $(COUNTS)
	echo -e "category\tassignments" >> $(COUNTS)
	echo -ne "total\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(*) FROM $* AS a" \
	-t -A -F"	" >> $(COUNTS)
	echo -e "\tpredictions\tgenes" >> $(COUNTS)
	echo -ne "ref\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(distinct a.prediction_id1), count(distinct g.gene_id) \
	FROM $* AS a, \
	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) AS g\
	WHERE a.prediction_id1 = g.prediction_id" \
	-t -A -F"	" >> $(COUNTS)
	echo -ne "target\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(distinct a.prediction_id2), count(distinct g.gene_id) \
	FROM $* AS a, \
	$(PARAM_TABLE_NAME_SELECTED_PREDICTIONS) AS g\
	WHERE a.prediction_id2 = g.prediction_id" \
	-t -A -F"	" >> $(COUNTS)
	echo -ne "identical\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(*) \
	FROM $* AS a \
	WHERE a.pidentity = 100 AND \
	a.query_from = a.sbjct_from AND a.query_to = a.sbjct_to" \
	-t -A -F"	" >> $(COUNTS)

%.counts_genome_sbjct_length:
	echo "# Length of predicted genomic region for $*:" >> $(COUNTS)
	echo -e "category\tpredictions\taverage\tmin\tmax" >> $(COUNTS)
	echo -ne "ref = target\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(*), \
	ROUND(AVG(tp.sbjct_genome_to - tp.sbjct_genome_from - (rp.sbjct_genome_to - rp.sbjct_genome_from) ),1), \
	MIN(tp.sbjct_genome_to - tp.sbjct_genome_from - (rp.sbjct_genome_to - rp.sbjct_genome_from)), \
	MAX(tp.sbjct_genome_to - tp.sbjct_genome_from - (rp.sbjct_genome_to - rp.sbjct_genome_from)) \
	FROM \
	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
	$* AS a \
	WHERE  \
	a.prediction_id1 = rp.prediction_id AND \
	a.prediction_id2 = tp.prediction_id AND \
	tp.prediction_id = tp.prediction_id AND \
	tp.sbjct_genome_to - tp.sbjct_genome_from =  rp.sbjct_genome_to - rp.sbjct_genome_from  " \
	-t -A -F"	" >> $(COUNTS)
	echo -ne "target > ref\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(*), \
	ROUND(AVG(tp.sbjct_genome_to - tp.sbjct_genome_from - (rp.sbjct_genome_to - rp.sbjct_genome_from) ),1), \
	MIN(tp.sbjct_genome_to - tp.sbjct_genome_from - (rp.sbjct_genome_to - rp.sbjct_genome_from)), \
	MAX(tp.sbjct_genome_to - tp.sbjct_genome_from - (rp.sbjct_genome_to - rp.sbjct_genome_from)) \
	FROM \
	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
	$* AS a \
	WHERE  \
	a.prediction_id1 = rp.prediction_id AND \
	a.prediction_id2 = tp.prediction_id AND \
	tp.prediction_id = tp.prediction_id AND \
	tp.sbjct_genome_to - tp.sbjct_genome_from >  rp.sbjct_genome_to - rp.sbjct_genome_from " \
	-t -A -F"	" >> $(COUNTS)
	echo -ne "ref > target\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(*), \
	-ROUND(AVG(tp.sbjct_genome_to - tp.sbjct_genome_from - (rp.sbjct_genome_to - rp.sbjct_genome_from)),1), \
	-MAX(tp.sbjct_genome_to - tp.sbjct_genome_from - (rp.sbjct_genome_to - rp.sbjct_genome_from)), \
	-MIN(tp.sbjct_genome_to - tp.sbjct_genome_from - (rp.sbjct_genome_to - rp.sbjct_genome_from)) \
	FROM \
	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
	$* AS a \
	WHERE  \
	a.prediction_id1 = rp.prediction_id AND \
	a.prediction_id2 = tp.prediction_id AND \
	tp.prediction_id = tp.prediction_id AND \
	tp.sbjct_genome_to - tp.sbjct_genome_from <  rp.sbjct_genome_to - rp.sbjct_genome_from " \
	-t -A -F"	" >> $(COUNTS)

%.counts_sbjct_length:
	echo "# Length of predicted peptide for $*:" >> $(COUNTS)
	echo -e "category\tpredictions\tmin\tmax\tavg" >> $(COUNTS)
	echo -ne "ref = target\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(*), \
	MIN(tp.sbjct_to - tp.sbjct_from - (rp.sbjct_to - rp.sbjct_from)), \
	MAX(tp.sbjct_to - tp.sbjct_from - (rp.sbjct_to - rp.sbjct_from)), \
	ROUND(AVG(tp.sbjct_to - tp.sbjct_from - (rp.sbjct_to - rp.sbjct_from)),1) \
	FROM \
	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
	$* AS a \
	WHERE  \
	a.prediction_id1 = rp.prediction_id AND \
	a.prediction_id2 = tp.prediction_id AND \
	tp.sbjct_to - tp.sbjct_from =  rp.sbjct_to - rp.sbjct_from  " \
	-t -A -F"	" >> $(COUNTS)
	echo -ne "target > ref\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(*), \
	MIN(tp.sbjct_to - tp.sbjct_from - (rp.sbjct_to - rp.sbjct_from)), \
	MAX(tp.sbjct_to - tp.sbjct_from - (rp.sbjct_to - rp.sbjct_from)),\
	ROUND(AVG(tp.sbjct_to - tp.sbjct_from - (rp.sbjct_to - rp.sbjct_from)),1) \
	FROM \
	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
	$* AS a \
	WHERE  \
	a.prediction_id1 = rp.prediction_id AND \
	a.prediction_id2 = tp.prediction_id AND \
	tp.sbjct_to - tp.sbjct_from >  rp.sbjct_to - rp.sbjct_from " \
	-t -A -F"	" >> $(COUNTS)
	echo -ne "ref > target\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(*), \
	-MAX(tp.sbjct_to - tp.sbjct_from - (rp.sbjct_to - rp.sbjct_from)), \
	-MIN(tp.sbjct_to - tp.sbjct_from - (rp.sbjct_to - rp.sbjct_from)), \
	-ROUND(AVG(tp.sbjct_to - tp.sbjct_from - (rp.sbjct_to - rp.sbjct_from)),1) \
	FROM \
	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
	$* AS a \
	WHERE  \
	a.prediction_id1 = rp.prediction_id AND \
	a.prediction_id2 = tp.prediction_id AND \
	tp.sbjct_to - tp.sbjct_from <  rp.sbjct_to - rp.sbjct_from " \
	-t -A -F"	" >> $(COUNTS)

## count difference in number of introns
%.counts_exons:
	echo "# Number of exons for $*:" >> $(COUNTS)
	echo -e "category\tpredictions\tmin\tmax\tavg" >> $(COUNTS)
	echo -ne "ref = target\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(*), \
	MIN(tp.nintrons - rp.nintrons), \
	MAX(tp.nintrons - rp.nintrons), \
	ROUND(AVG(tp.nintrons - rp.nintrons),1) \
	FROM \
	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
	$* AS a \
	WHERE  \
	a.prediction_id1 = rp.prediction_id AND \
	a.prediction_id2 = tp.prediction_id AND \
	tp.nintrons - rp.nintrons = 0 " \
	-t -A -F"	" >> $(COUNTS)
	echo -ne "target > ref\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(*), \
	MIN(tp.nintrons - rp.nintrons), \
	MAX(tp.nintrons - rp.nintrons),\
	ROUND(AVG(tp.nintrons - rp.nintrons),1) \
	FROM \
	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
	$* AS a \
	WHERE  \
	a.prediction_id1 = rp.prediction_id AND \
	a.prediction_id2 = tp.prediction_id AND \
	tp.nintrons - rp.nintrons > 0" \
	-t -A -F"	" >> $(COUNTS)
	echo -ne "ref > target\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(*), \
	-MAX(tp.nintrons - rp.nintrons), \
	-MIN(tp.nintrons - rp.nintrons), \
	-ROUND(AVG(tp.nintrons - rp.nintrons),1) \
	FROM \
	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
	$* AS a \
	WHERE  \
	a.prediction_id1 = rp.prediction_id AND \
	a.prediction_id2 = tp.prediction_id AND \
	tp.nintrons - rp.nintrons < 0" \
	-t -A -F"	" >> $(COUNTS)

%.counts_extensions:
	echo "# Extension of predicted peptide for $*:" >> $(COUNTS)
	echo -e "category\tpredictions\tmin\tmax\tavg" >> $(COUNTS)
	echo -ne "ref = target\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(*), \
	0, 0, 0 \
	FROM \
	$* AS a \
	WHERE  \
	query_from = sbjct_from AND query_to = sbjct_to" \
	-t -A -F"	" >> $(COUNTS)
	echo -ne "N: target > ref\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(*), \
	MIN(sbjct_from-1), \
	MAX(sbjct_from-1), \
	ROUND(AVG(sbjct_from-1),1) \
	FROM $* AS a \
	WHERE query_to = query_length AND sbjct_to = sbjct_length AND \
	query_from = 1 AND sbjct_from > 1" \
	-t -A -F"	" >> $(COUNTS)
	echo -ne "N: ref > target\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(*), \
	MIN(query_from-1), \
	MAX(query_from-1), \
	ROUND(AVG(query_from-1),1) \
	FROM $* AS a \
	WHERE query_to = query_length AND sbjct_to = sbjct_length AND \
	query_from > 1 AND sbjct_from = 1" \
	-t -A -F"	" >> $(COUNTS)
	echo -ne "C: target > ref\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(*), \
	MIN(sbjct_length - sbjct_to), \
	MAX(sbjct_length - sbjct_to), \
	ROUND(AVG(sbjct_length-sbjct_to),1) \
	FROM $* AS a \
	WHERE query_from = 1 AND sbjct_from = 1 AND \
	query_to = query_length AND sbjct_to < sbjct_length " \
	-t -A -F"	" >> $(COUNTS)
	echo -ne "C: ref > target\t" >> $(COUNTS)
	$(CONNECTION) \
	"SELECT COUNT(*), \
	MIN(query_length - query_to), \
	MAX(query_length - query_to), \
	ROUND(AVG(query_length - query_to),1) \
	FROM $* AS a \
	WHERE query_from = 1 AND sbjct_from = 1 AND \
	query_to < query_length AND sbjct_to = sbjct_length " \
	-t -A -F"	" >> $(COUNTS)

########################################################
## correlation between prediction lengths
%.fasta: %.list
	rm -f $@
	for line in `cut -f 1 $*.list | xargs | perl -p -e 's/ /,/g'`; do \
		$(CONNECTION) \
		"SELECT '>' || prediction_id || ' ' || gene_id || ' ' || query_token || ' ' || sbjct_token || ' ' || sbjct_strand || ' ' || export_sbjct_genome_from || ' ' || export_sbjct_genome_to || ' ' || query_coverage || ' ' || pidentity || ' ' || nintrons+1 || ' ' ||  '\n' || sequence FROM $(PARAM_TABLE_NAME_PREDICTIONS) \
		WHERE prediction_id IN ( $$line )" \
		-t -A -F"	" >> $@; \
	done

########################################################
## get gff file for list of predictions
%.gff: %.list
	python $(DIR_SCRIPTS_GENEPREDICTION)gpipe/get_genes.py \
	--format=gff-seq \
	--schema=$(PARAM_PSQL_SCHEMA) \
	--filter-prediction=$*.list \
	--from-file > $@

########################################################
## get full length descriptions from blast output
%.full: %.blast
	awk '{ if ( $$11 >= $(PARAM_FULL_MIN_PIDE) && \
	($$5-$$4+1)*100/$$12 >= $(PARAM_FULL_MIN_COVERAGE) && \
	($$8-$$7+1)*100/$$13 >= $(PARAM_FULL_MIN_COVERAGE) ) { print; } }' < $*.blast > $*.full

%_notfull.list: %.full %.list
	cut -f 1 $*.full | awk '{printf("^%s[^0-9a-zA-Z]\n", $$1);}'  > $@_tmp
	grep -v -f $@_tmp $*.list > $@
	rm -f $@_tmp

########################################################
## creating views
%_ref.create_view: %.set_best
	-$(CONNECTION) "DROP VIEW $*_ref"
	$(CONNECTION) \
	"CREATE VIEW $*_ref AS \
	SELECT * FROM $* AS a \
	WHERE a.is_best_per_gene1 = TRUE;"

%_target.create_view: %.set_best
	-$(CONNECTION) "DROP VIEW $*_target"
	$(CONNECTION) \
	"CREATE VIEW $*_target AS \
	SELECT * FROM $* AS a \
	WHERE a.is_best_per_gene2 = TRUE;"

%_both.create_view: %.set_best
	-$(CONNECTION) "DROP VIEW $*_both"
	$(CONNECTION) \
	"CREATE VIEW $*_both AS \
	SELECT * FROM $* AS a \
	WHERE a.is_best_per_gene1 = TRUE AND a.is_best_per_gene2 = TRUE;"

########################################################
## table definitions
create_tables: $(PARAM_TABLE_NAME_ASSIGNMENTS).create_table_assignments \
	$(PARAM_TABLE_NAME_ASSIGNMENTS_REF2TARGET).create_table_assignments \
	$(PARAM_TABLE_NAME_ASSIGNMENTS_TARGET2REF).create_table_assignments \
	$(PARAM_TABLE_NAME_SELECTED_PREDICTIONS).create_table_selected_predictions

%.create_table_selected_predictions:
	-$(CONNECTION) "DROP VIEW $(PARAM_TABLE_NAME_SELECTED_PREDICTIONS)"
	$(CONNECTION) \
	"CREATE VIEW $(PARAM_TABLE_NAME_SELECTED_PREDICTIONS) AS \
	SELECT p.* \
	FROM $(PARAM_TABLE_NAME_PREDICTIONS) AS p \
	WHERE p.class IN $(PARAM_QUALITY_SELECTED);"

%.create_table_assignments:
	-$(CONNECTION) "DROP TABLE $* CASCADE";
	$(CONNECTION) \
	"CREATE TABLE $* ( \
	assignment_id SERIAL, \
	prediction_id1 INTEGER, \
	prediction_id2 INTEGER, \
	is_best_per_gene1 BOOLEAN, \
	is_best_per_gene2 BOOLEAN, \
	aa_overlap INTEGER, \
	aa_coverage_min FLOAT, \
	aa_coverage_max FLOAT, \
	na_coverage FLOAT, \
	na_coverage1 FLOAT, \
	na_coverage2 FLOAT, \
	diff_exons INTEGER, \
	diff_sbjct_genome_from INTEGER, \
	diff_sbjct_genome_to INTEGER, \
	score FLOAT, \
	query_from INTEGER, \
	query_to INTEGER, \
	query_ali TEXT, \
	sbjct_from INTEGER, \
	sbjct_to INTEGER, \
	sbjct_ali TEXT, \
	pidentity FLOAT, \
	psimilarity FLOAT, \
	ngaps INTEGER, \
	query_length INTEGER, \
	sbjct_length INTEGER \
	);"
	$(CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_assignment_id ON $* (assignment_id)"; 
	$(CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_prediction_id1 ON $* (prediction_id1)"; 
	$(CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_prediction_id2 ON $* (prediction_id2)";

$(PARAM_TABLE_NAME_ASSIGNMENTS).assignments:
	$(CMD_REMOTE_SUBMIT) python $(DIR_SCRIPTS_GENEPREDICTION)gpipe/compare_predictions.py \
	--table-reference=$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) \
	--table-target=$(PARAM_TABLE_NAME_PREDICTIONS) \
	< /dev/null > $@

$(PARAM_TABLE_NAME_ASSIGNMENTS_REF2TARGET).assignments:
	$(CMD_REMOTE_SUBMIT) python $(DIR_SCRIPTS_GENEPREDICTION)gpipe/compare_predictions.py \
	--table-reference=$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) \
	--table-target=$(PARAM_TABLE_NAME_PREDICTIONS) \
	< /dev/null > $@


$(PARAM_TABLE_NAME_ASSIGNMENTS_TARGET2REF).assignments:
	$(CMD_REMOTE_SUBMIT) python $(DIR_SCRIPTS_GENEPREDICTION)gpipe/compare_predictions.py \
	--table-reference=$(PARAM_TABLE_NAME_PREDICTIONS) \
	--table-target=$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) \
	< /dev/null > $@

%.load: %.assignments
	$(CONNECTION) "DELETE FROM $*;" > $@
	grep -v "#" $*.assignments |\
	$(CONNECTION) "COPY $* FROM STDIN WITH NULL AS 'na'" >> $@ 
	echo "loaded into $*: `$(CONNECTION) 'SELECT COUNT(*) FROM $*;' -t `"  >> $(LOG)

## set best predictions
## best predictions are those according to highest alignment score
%.set_best: %.load
	-$(CONNECTION) "DROP TABLE $*_tmp; "
	-$(CONNECTION) "DROP INDEX $(CMD_TABLE_PREFIX)_tmp_index; "
	$(CONNECTION) \
	"UPDATE $* SET is_best_per_gene1 = FALSE, is_best_per_gene2 = FALSE;" >> $@
	$(CONNECTION) \
	"CREATE TABLE $*_tmp ( \
	       prediction_id INTEGER, \
	       score FLOAT);"
	$(CONNECTION) \
	"CREATE INDEX $(CMD_TABLE_PREFIX)_tmp_index ON $*_tmp (prediction_id); "
	$(CONNECTION) \
	"INSERT INTO $*_tmp \
	SELECT prediction_id1, MAX(score) \
	FROM $* AS a GROUP BY a.prediction_id1 \
	HAVING MAX(score) >= $(PARAM_BEST_MIN_SCORE);" > $@
	$(CONNECTION) \
	"UPDATE $* \
	SET is_best_per_gene1 = TRUE \
	WHERE assignment_id IN ( \
	       SELECT a.assignment_id \
		      FROM $* AS a, $*_tmp AS t \
	       WHERE \
	       a.prediction_id1 = t.prediction_id AND \
	       a.score = t.score);" >> $@
	$(CONNECTION) "DELETE FROM $*_tmp" >> $@
	$(CONNECTION) \
	"INSERT INTO $*_tmp \
	SELECT prediction_id2, MAX(score) \
	FROM $* AS a GROUP BY a.prediction_id2 \
	HAVING MAX(score) >= $(PARAM_BEST_MIN_SCORE);" >> $@
	$(CONNECTION) \
	"UPDATE $* \
	SET is_best_per_gene2 = TRUE \
	WHERE assignment_id IN ( \
	       SELECT a.assignment_id \
		      FROM $* AS a, $*_tmp AS t \
	       WHERE \
	       a.prediction_id2 = t.prediction_id AND \
	       a.score = t.score);" >> $@
	$(CONNECTION) "DELETE FROM $*_tmp" >> $@
	-$(CONNECTION) "DROP INDEX $(CMD_TABLE_PREFIX)_tmp_index;"
	-$(CONNECTION) "DROP TABLE $*_tmp "

# %.set_best: %.set_coverage
# 	-$(CONNECTION) "DROP TABLE $*_tmp; "
# 	-$(CONNECTION) "DROP INDEX $(CMD_TABLE_PREFIX)_tmp_index; "
# 	$(CONNECTION) \
# 	"CREATE TABLE $*_tmp ( \
# 	       gene_id INTEGER, \
# 	       combined_coverage FLOAT);"
# 	$(CONNECTION) \
# 	"CREATE INDEX $(CMD_TABLE_PREFIX)_tmp_index ON $*_tmp (gene_id); "
# 	$(CONNECTION) \
# 	"INSERT INTO $*_tmp \
# 	SELECT gene_id, MAX(combined_coverage) \
# 	FROM \
# 		$(PARAM_REFERENCE_TABLE_NAME_GENES) AS g, \
# 		$* AS c \
# 	WHERE c.prediction_id1 = g.prediction_id \
# 	GROUP BY g.gene_id;" > $@
# 	$(CONNECTION) \
# 	"UPDATE $* SET is_best_per_gene = FALSE;" >> $@
# 	$(CONNECTION) \
# 	"UPDATE $* \
# 	SET is_best_per_gene = TRUE \
# 	WHERE prediction_id1 IN ( \
# 	       SELECT c.prediction_id1 \
# 		      FROM \
# 		      $* AS c, \
# 		      $(PARAM_REFERENCE_TABLE_NAME_GENES) AS g, \
# 		      $*_tmp AS t \
# 	       WHERE \
# 	       c.prediction_id1 = g.prediction_id AND \
# 	       g.gene_id = t.gene_id AND \
# 	       c.combined_coverage = t.combined_coverage);" >> $@
# 	-$(CONNECTION) "DROP INDEX $(CMD_TABLE_PREFIX)_tmp_index;"
# 	-$(CONNECTION) "DROP TABLE $*_tmp "


# %.set_coverage: %.fill
# 	$(CONNECTION) \
# 	"UPDATE $* \
# 	SET \
# 	combined_coverage = \
# 	( \
# 	  SELECT \
# 	  COVERAGE( rp.sbjct_genome_from, rp.sbjct_genome_to, tq.sbjct_genome_from, tq.sbjct_genome_to) \
# 	   FROM \
# 	   $(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) AS rp, \
# 	   $(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
# 	   $(PARAM_TABLE_NAME_QUALITY) AS tq \
# 	   WHERE rp.prediction_id = prediction_id1 \
# 	     AND tp.prediction_id = prediction_id2 \
# 	     AND tq.prediction_id = tp.prediction_id \
# 	), \
# 	coverage1 = \
# 	( \
# 	  SELECT \
# 	   COVERAGE_QUERY( rp.sbjct_genome_from, rp.sbjct_genome_to, tq.sbjct_genome_from, tq.sbjct_genome_to) \
# 	   FROM \
# 	   $(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) AS rp, \
# 	   $(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
# 	   $(PARAM_TABLE_NAME_QUALITY) AS tq \
# 	   WHERE rp.prediction_id = prediction_id1 \
# 	     AND tp.prediction_id = prediction_id2 \
# 	     AND tq.prediction_id = tp.prediction_id \
# 	), \
# 	coverage2 = \
# 	( \
# 	  SELECT \
# 	   COVERAGE_SBJCT( rp.sbjct_genome_from, rp.sbjct_genome_to, tq.sbjct_genome_from, tq.sbjct_genome_to) \
# 	   FROM \
# 	   $(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) AS rp, \
# 	   $(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
# 	   $(PARAM_TABLE_NAME_QUALITY) AS tq \
# 	   WHERE rp.prediction_id = prediction_id1 \
# 	     AND tp.prediction_id = prediction_id2 \
# 	     AND tq.prediction_id = tp.prediction_id \
# 	);" > $@

# %.set_location: %.set_coverage
# 	$(CONNECTION) \
# 	"UPDATE $* SET same_location = FALSE;"
# 	$(CONNECTION) \
# 	"UPDATE $* \
# 	SET same_location = TRUE \
# 	WHERE assignment_id IN ( \
# 	       SELECT assignment_id \
# 		      FROM \
# 		      $* AS a, \
# 		      $(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) AS rp, \
# 		      $(PARAM_TABLE_NAME_PREDICTIONS) AS tp \
# 	       WHERE \
# 	       a.prediction_id1 = rp.prediction_id AND \
# 	       a.prediction_id2 = tp.prediction_id AND \
# 	       rp.sbjct_token  = tp.sbjct_token AND \
# 	       rp.sbjct_strand = tp.sbjct_strand AND \
# 	       abs(rp.sbjct_genome_from-tp.sbjct_genome_from) < 10  AND \
# 	       abs(rp.sbjct_genome_to-tp.sbjct_genome_to) < 10 ); " > $@


# %.set_nexons: %.set_coverage
# 	$(CONNECTION) \
# 	"UPDATE $* SET same_nexons = FALSE;"
# 	$(CONNECTION) \
# 	"UPDATE $* \
# 	SET same_nexons = TRUE \
# 	WHERE assignment_id IN ( \
# 	       SELECT assignment_id \
# 		      FROM \
# 		      $* AS a, \
# 		      $(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) AS rp, \
# 		      $(PARAM_TABLE_NAME_PREDICTIONS) AS tp \
# 	       WHERE \
# 	       a.prediction_id1 = rp.prediction_id AND \
# 	       a.prediction_id2 = tp.prediction_id AND \
# 	       rp.nintrons = tp.nintrons); " > $@


# $(PARAM_TABLE_NAME_ASSIGNMENTS).fill:
# 	$(CONNECTION) \
# 	"INSERT INTO $(PARAM_TABLE_NAME_ASSIGNMENTS) \
# 	(prediction_id1, prediction_id2) \
# 	SELECT rp.prediction_id, \
# 	( \
# 		SELECT tp.prediction_id \
# 	        FROM \
# 			$(PARAM_TABLE_NAME_SELECTED_PREDICTIONS) as tp \
# 		WHERE \
# 			rp.sbjct_token = tp.sbjct_token AND \
# 			rp.sbjct_strand = tp.sbjct_strand AND \
# 			COVERAGE_QUERY( rp.sbjct_genome_from, rp.sbjct_genome_to,\
# 			tp.sbjct_genome_from, tp.sbjct_genome_to) > $(PARAM_ASSIGNMENTS_MIN_COVERAGE_REFERENCE) AND \
# 			COVERAGE_SBJCT( rp.sbjct_genome_from, rp.sbjct_genome_to,\
# 			tp.sbjct_genome_from, tp.sbjct_genome_to) > $(PARAM_ASSIGNMENTS_MIN_COVERAGE_TARGET) \
# 		ORDER BY COVERAGE( rp.sbjct_genome_from, rp.sbjct_genome_to, tp.sbjct_genome_from, tp.sbjct_genome_to) DESC \
# 		LIMIT 1 \
# 	) \
# 	FROM \
# 	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) AS rp;" > $@

# $(PARAM_TABLE_NAME_ASSIGNMENTS_REF2TARGET).fill:
# 	$(CONNECTION) \
# 	"INSERT INTO $(PARAM_TABLE_NAME_ASSIGNMENTS_REF2TARGET) \
# 	(prediction_id1, prediction_id2) \
# 	SELECT rp.prediction_id, \
# 	( \
# 		SELECT tp.prediction_id \
# 	        FROM \
# 			$(PARAM_TABLE_NAME_SELECTED_PREDICTIONS) as tp \
# 		WHERE \
# 			rp.sbjct_token = tp.sbjct_token AND \
# 			rp.sbjct_strand = tp.sbjct_strand AND \
# 			COVERAGE_QUERY( rp.sbjct_genome_from, rp.sbjct_genome_to,\
# 			tp.sbjct_genome_from, tp.sbjct_genome_to) > 0 AND \
# 			COVERAGE_SBJCT( rp.sbjct_genome_from, rp.sbjct_genome_to,\
# 			tp.sbjct_genome_from, tp.sbjct_genome_to) > 0 \
# 		ORDER BY COVERAGE( rp.sbjct_genome_from, rp.sbjct_genome_to, tp.sbjct_genome_from, tp.sbjct_genome_to) DESC \
# 		LIMIT 1 \
# 	) \
# 	FROM \
# 	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) AS rp;" > $@

# $(PARAM_TABLE_NAME_ASSIGNMENTS_TARGET2REF).fill:
# 	$(CONNECTION) \
# 	"INSERT INTO $(PARAM_TABLE_NAME_ASSIGNMENTS_TARGET2REF) \
# 	(prediction_id2, prediction_id1) \
# 	SELECT tp.prediction_id, \
# 	( \
# 		SELECT rp.prediction_id \
# 	        FROM \
# 			$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp \
# 		WHERE \
# 			tp.sbjct_token = rp.sbjct_token AND \
# 			tp.sbjct_strand = rp.sbjct_strand AND \
# 			COVERAGE_QUERY( tp.sbjct_genome_from, tp.sbjct_genome_to,\
# 			rp.sbjct_genome_from, rp.sbjct_genome_to) > 0 AND \
# 			COVERAGE_SBJCT( tp.sbjct_genome_from, tp.sbjct_genome_to,\
# 			rp.sbjct_genome_from, rp.sbjct_genome_to) > 0 \
# 		ORDER BY COVERAGE( tp.sbjct_genome_from, tp.sbjct_genome_to, rp.sbjct_genome_from, rp.sbjct_genome_to) DESC \
# 		LIMIT 1 \
# 	) \
# 	FROM \
# 	$(PARAM_TABLE_NAME_SELECTED_PREDICTIONS) AS tp;" > $@

# %.counts_genome_sbjct_length:
# 	echo "# Length of predicted genomic region for $*:" >> $(COUNTS)
# 	echo -e "category\tpredictions\taverage\tmin\tmax" >> $(COUNTS)
# 	echo -ne "ref = target\t" >> $(COUNTS)
# 	$(CONNECTION) \
# 	"SELECT COUNT(*), \
# 	ROUND(AVG(tq.sbjct_genome_to - tq.sbjct_genome_from - (rp.sbjct_genome_to - rp.sbjct_genome_from) ),1), \
# 	MIN(tq.sbjct_genome_to - tq.sbjct_genome_from - (rp.sbjct_genome_to - rp.sbjct_genome_from)), \
# 	MAX(tq.sbjct_genome_to - tq.sbjct_genome_from - (rp.sbjct_genome_to - rp.sbjct_genome_from)) \
# 	FROM \
# 	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
# 	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
# 	$(PARAM_TABLE_NAME_QUALITY) AS tq, \
# 	$* AS a \
# 	WHERE  \
# 	a.prediction_id1 = rp.prediction_id AND \
# 	a.prediction_id2 = tp.prediction_id AND \
# 	a.is_best_per_gene = TRUE AND \
# 	tq.prediction_id = tp.prediction_id AND \
# 	tq.sbjct_genome_to - tq.sbjct_genome_from + 1 =  rp.sbjct_genome_to - rp.sbjct_genome_from + 1 " \
# 	-t -A -F"	" >> $(COUNTS)
# 	echo -ne "target > ref\t" >> $(COUNTS)
# 	$(CONNECTION) \
# 	"SELECT COUNT(*), \
# 	ROUND(AVG(tq.sbjct_genome_to - tq.sbjct_genome_from - (rp.sbjct_genome_to - rp.sbjct_genome_from) ),1), \
# 	MIN(tq.sbjct_genome_to - tq.sbjct_genome_from - (rp.sbjct_genome_to - rp.sbjct_genome_from)), \
# 	MAX(tq.sbjct_genome_to - tq.sbjct_genome_from - (rp.sbjct_genome_to - rp.sbjct_genome_from)) \
# 	FROM \
# 	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
# 	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
# 	$(PARAM_TABLE_NAME_QUALITY) AS tq, \
# 	$* AS a \
# 	WHERE  \
# 	a.prediction_id1 = rp.prediction_id AND \
# 	a.prediction_id2 = tp.prediction_id AND \
# 	a.is_best_per_gene = TRUE AND \
# 	tq.prediction_id = tp.prediction_id AND \
# 	tq.sbjct_genome_to - tq.sbjct_genome_from + 1 >  rp.sbjct_genome_to - rp.sbjct_genome_from + 1 " \
# 	-t -A -F"	" >> $(COUNTS)
# 	echo -ne "ref > target\t" >> $(COUNTS)
# 	$(CONNECTION) \
# 	"SELECT COUNT(*), \
# 	-ROUND(AVG(tq.sbjct_genome_to - tq.sbjct_genome_from - (rp.sbjct_genome_to - rp.sbjct_genome_from)),1), \
# 	-MAX(tq.sbjct_genome_to - tq.sbjct_genome_from - (rp.sbjct_genome_to - rp.sbjct_genome_from)), \
# 	-MIN(tq.sbjct_genome_to - tq.sbjct_genome_from - (rp.sbjct_genome_to - rp.sbjct_genome_from)) \
# 	FROM \
# 	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
# 	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
# 	$(PARAM_TABLE_NAME_QUALITY) AS tq, \
# 	$* AS a \
# 	WHERE  \
# 	a.prediction_id1 = rp.prediction_id AND \
# 	a.prediction_id2 = tp.prediction_id AND \
# 	a.is_best_per_gene = TRUE AND \
# 	tq.prediction_id = tp.prediction_id AND \
# 	tq.sbjct_genome_to - tq.sbjct_genome_from + 1 <  rp.sbjct_genome_to - rp.sbjct_genome_from + 1 " \
# 	-t -A -F"	" >> $(COUNTS)

# %.counts_sbjct_length:
# 	echo "# Length of predicted peptide for $*:" >> $(COUNTS)
# 	echo -e "category\tpredictions\tmin\tmax\tavg" >> $(COUNTS)
# 	echo -ne "ref = target\t" >> $(COUNTS)
# 	$(CONNECTION) \
# 	"SELECT COUNT(*), \
# 	MIN(tp.sbjct_to - tp.sbjct_from - (rp.sbjct_to - rp.sbjct_from)), \
# 	MAX(tp.sbjct_to - tp.sbjct_from - (rp.sbjct_to - rp.sbjct_from)), \
# 	ROUND(AVG(tp.sbjct_to - tp.sbjct_from - (rp.sbjct_to - rp.sbjct_from)),1) \
# 	FROM \
# 	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
# 	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
# 	$* AS a \
# 	WHERE  \
# 	a.prediction_id1 = rp.prediction_id AND \
# 	a.prediction_id2 = tp.prediction_id AND \
# 	a.is_best_per_gene = TRUE AND \
# 	tp.sbjct_to - tp.sbjct_from + 1 =  rp.sbjct_to - rp.sbjct_from + 1 " \
# 	-t -A -F"	" >> $(COUNTS)
# 	echo -ne "target > ref\t" >> $(COUNTS)
# 	$(CONNECTION) \
# 	"SELECT COUNT(*), \
# 	MIN(tp.sbjct_to - tp.sbjct_from - (rp.sbjct_to - rp.sbjct_from)), \
# 	MAX(tp.sbjct_to - tp.sbjct_from - (rp.sbjct_to - rp.sbjct_from)),\
# 	ROUND(AVG(tp.sbjct_to - tp.sbjct_from - (rp.sbjct_to - rp.sbjct_from)),1) \
# 	FROM \
# 	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
# 	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
# 	$* AS a \
# 	WHERE  \
# 	a.prediction_id1 = rp.prediction_id AND \
# 	a.prediction_id2 = tp.prediction_id AND \
# 	a.is_best_per_gene = TRUE AND \
# 	tp.sbjct_to - tp.sbjct_from + 1 >  rp.sbjct_to - rp.sbjct_from + 1 " \
# 	-t -A -F"	" >> $(COUNTS)
# 	echo -ne "ref > target\t" >> $(COUNTS)
# 	$(CONNECTION) \
# 	"SELECT COUNT(*), \
# 	-MAX(tp.sbjct_to - tp.sbjct_from - (rp.sbjct_to - rp.sbjct_from)), \
# 	-MIN(tp.sbjct_to - tp.sbjct_from - (rp.sbjct_to - rp.sbjct_from)), \
# 	-ROUND(AVG(tp.sbjct_to - tp.sbjct_from - (rp.sbjct_to - rp.sbjct_from)),1) \
# 	FROM \
# 	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
# 	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
# 	$(PARAM_TABLE_NAME_ASSIGNMENTS) AS a \
# 	WHERE  \
# 	a.prediction_id1 = rp.prediction_id AND \
# 	a.prediction_id2 = tp.prediction_id AND \
# 	a.is_best_per_gene = TRUE AND \
# 	tp.sbjct_to - tp.sbjct_from + 1 <  rp.sbjct_to - rp.sbjct_from + 1 " \
# 	-t -A -F"	" >> $(COUNTS)

# ## count difference in number of introns
# %.counts_exons:
# 	echo "# Number of exons for $*:" >> $(COUNTS)
# 	echo -e "category\tpredictions\tmin\tmax\tavg" >> $(COUNTS)
# 	echo -ne "ref = target\t" >> $(COUNTS)
# 	$(CONNECTION) \
# 	"SELECT COUNT(*), \
# 	MIN(tp.nintrons - rp.nintrons), \
# 	MAX(tp.nintrons - rp.nintrons), \
# 	ROUND(AVG(tp.nintrons - rp.nintrons),1) \
# 	FROM \
# 	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
# 	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
# 	$* AS a \
# 	WHERE  \
# 	a.prediction_id1 = rp.prediction_id AND \
# 	a.prediction_id2 = tp.prediction_id AND \
# 	a.is_best_per_gene = TRUE AND \
# 	tp.nintrons - rp.nintrons = 0 " \
# 	-t -A -F"	" >> $(COUNTS)
# 	echo -ne "target > ref\t" >> $(COUNTS)
# 	$(CONNECTION) \
# 	"SELECT COUNT(*), \
# 	MIN(tp.nintrons - rp.nintrons), \
# 	MAX(tp.nintrons - rp.nintrons),\
# 	ROUND(AVG(tp.nintrons - rp.nintrons),1) \
# 	FROM \
# 	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
# 	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
# 	$* AS a \
# 	WHERE  \
# 	a.prediction_id1 = rp.prediction_id AND \
# 	a.prediction_id2 = tp.prediction_id AND \
# 	a.is_best_per_gene = TRUE AND \
# 	tp.nintrons - rp.nintrons > 0" \
# 	-t -A -F"	" >> $(COUNTS)
# 	echo -ne "ref > target\t" >> $(COUNTS)
# 	$(CONNECTION) \
# 	"SELECT COUNT(*), \
# 	-MAX(tp.nintrons - rp.nintrons), \
# 	-MIN(tp.nintrons - rp.nintrons), \
# 	-ROUND(AVG(tp.nintrons - rp.nintrons),1) \
# 	FROM \
# 	$(PARAM_REFERENCE_TABLE_NAME_PREDICTIONS) as rp, \
# 	$(PARAM_TABLE_NAME_PREDICTIONS) AS tp, \
# 	$* AS a \
# 	WHERE  \
# 	a.prediction_id1 = rp.prediction_id AND \
# 	a.prediction_id2 = tp.prediction_id AND \
# 	a.is_best_per_gene = TRUE AND \
# 	tp.nintrons - rp.nintrons < 0" \
# 	-t -A -F"	" >> $(COUNTS)

include $(DIR_SCRIPTS_GENEPREDICTION)/makefiles/Makefile.common
