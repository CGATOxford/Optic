################################################################################
#   Gene prediction pipeline 
#
#   $Id: Makefile.compare_transcripts 2861 2010-02-23 17:36:32Z andreas $
#
#   Copyright (C) 2004 Andreas Heger
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License
#   as published by the Free Software Foundation; either version 2
#   of the License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#################################################################################
##
## Makefile to compare transcripts sets.
##
## PREAMBL: This makefile is still under development. Thus use with care. Also it 
## is not efficient as it could be.
## 
## This pipeline takes one more transcript sets and annotates them. The
## annotations are stored in an sqlite database in this directory $(PARAM_DATABASE).
## The pipeline then computes diagnostic plots and tables.
##
## Assumptions: the transcript sets are on the same genome ($(PARAM_GENOME)).
##  		the transcripts are non-overlapping.
##              
## The Makefile falls into three parts. The first part builds the primary sql tables
## and ends in the suffix "build". Possible targets are
##      full-build rates-build compare-build ...
##
## In the second step the pipeline imports the tables into the database. The import is
## dependent on the data computed in step 1. Thus if the underlying data changed, a
## new import will be triggered.
##
## These targets end in "import":
##      full-import rates-import compare-import
##
## In the third step, some plots and tables are computed dervived from the
##    primary sql tables. Targets in this section are
##      full-analysis rates-analysis compare-analysis
##
## The analysis section is semi-indepented from the previous two steps. The global
## target 'analysis' will check if 'build' and 'import' are up-to-date, but individual plots
## and tables have no dependencies.
##
## Usage instructions. 
## 
##    Create a new directory and enter it:
##        mkdir pipeline; cd pipeline
##
##    Checkout the code:
##         svn co svn://fgu204/andreas/gpipe/trunk src
##
##    The makefile is initialized by running
##        python src/gpipe/setup.py -m compare_transcripts -d . > setup.log
##
##    Create various input files. These files can be either physically
##	present or simply linked into the directory. See the Input section.
##
##    Run:
##
##	To do all, type
##        make all
##
##      Or do it stepwise
##        make build; make import; make analysis
##
##      Or work interactively.
##	  make build; make import; make exons_all.table
##
## Input: the pipeline inspects the files present and perform computations
##    with the data that is given
##
## Input (required): 
##
##   %.gtf: gtf files with (experimental) transcripts. The % denotes the
##	track name, for example heart.gtf, kidney.gtf, sample1.gtf, ...
##
##   genome.fasta, genome.idx: an indexed genome. See index_fasta.py.
##      
##   ensembl.gtf: a gtf file with a reference sequence set (required):
##        (default, can be changed in $(PARAM_MASTER_SET_GENES) )
##
##   annotations.gff: a gff file with annotated genomic regions. See 
##       $(PARAM_GENOME_REGIONS). Use gtf2gff.py to create this file.
##   
##   repeats.gff: gff file with repeats in genome. These are masked
##	for coding potential predictions. See $(PARAM_FILE_REPATS).
##
## Input (optional):
##
##   The pipeline includes additional information if it is present.
##
##   %.coverage: table with coverage information for a track. The output 
##	is from blat2assembly.py
##	
##   %.polyA: information about polyA tails. The output is from 
##      blat2assembly.py
##
##   repeats_gc.gff: gff formatted file of ancesctral repeats.
##          The score field contains the rate (see Makefile.ancestral_repeats)
##	    See $(PARAM_FILE_REPATS_RATES.
##
##   repeats_rates.gff: gff formatted file of ancesctral repeats.
##          The score field contains the G+C content (see Makefile.ancestral_repeats)
##	    See $(PARAM_FILE_REPATS_GC).
##
##   alignment.psl: psl formatted file with genomic alignments
##	between this species in query and another at appropriate evolutionary 
##	distance in target. See $(PARAM_FILE_ALIGNMENTS).
##      
##   annotations.go: GO annotations for genes in the reference set. Example format is
##	cell_location   ENSPPYG00000000676      GO:0016020      membrane        NA
##	See PARAM_FILENAME_GO?=$(PARAM_DIR_DATA)pa_mapped.goslim
##
##    territories.gff: gene territories. GTF formatted file, an example entry would be
##	chr1    protein_coding  exon    3979975 4199559 .       -       .       transcript_id "ENSPPYG00000000050"; gene_id "ENSPPYG00000000050";#
##	See $(PARAM_FILENAME_TERRITORIES)
##
##    $(PARAM_CPC_UNIREF): uniref database to use for coding potential predictions.
##
## Output:
##
##   This script will compute various plots and statistics based on
##
##   1. Annotations: transcript sets are annotated with a known gene set
##         and classfied as known, unknown, ambiguous. These are then sub-divided
##         as: known= pc: protein coding
##                    utr: utr transcript
##                    pseudo: pseudogene
##                    npc: non-protein coding
##      requires: a gff file that classifies genomic regions ($(PARAM_GENOMES_REGIONS))
##
##   2 Overlaps: the transcript sets are compared to $(PARAM_MASTER_SET_GENES) in
##      detail giving the overlap between the reference gene set and the experimental
##      sets.
##
##   3. Coverages: the statistical coverage of a transcript is correlated with
##         annotations and rates.
##
##   4. Rates: compute exonic, intronic and ancestral repeat rates
##       These targets require extra variables to be set:
##       1. a gtf file with repeat rates
##   
##   ...
##
##
## Dependencies:
##
##    checkout from svn: 
##          andreas/pythonlibs/trunk -> set $(DIR_SCRIPTS_TOOLS)
##          andreas/tools/trunk -> add to PYTHONPATH
##    install alignlib (http://sourceforge.net/) (best: install from repository) 
##    others: numpy, bx.python
##
##    various aliases.
##    sun grid engine. You would need to modif CMD_REMOTE_SUBMIT and farm.py in tools to
##    deal with other job submission systems.
##
##
################################################
## Section parameters: start
################################################
## project name
PARAM_PROJECT_NAME?=compare_transcripts

## directory with additional data. This variable
## is often used to abbreviate paths further down.
PARAM_DIR_DATA?=

## Files required by this project

## Required files

## indexed genome of the species under investigation. By default,
## the pipeline looks for the files genome.fasta and genome.idx
## in the working directory.
PARAM_FILENAME_GENOME?=genome

## genome annotation. By default, the pipeline looks for the file
## :file:`annotations.gff` in the working directory.
PARAM_GENOME_REGIONS?=annotations.gff

## Optional files

## file with pairwise genome alignments between rate species and this
## species (in psl format)
PARAM_FILE_ALIGNMENTS?=

## gff file with rates in ancestral repeats
PARAM_FILE_REPEATS_RATES?=

## gff file with GC content in ancestral repeats
PARAM_FILE_REPEATS_GC?=

## gff file with repeats in genome - used for masking
PARAM_FILE_REPEATS?=

## location of indexed genome file: genome for computing rates
PARAM_FILENAME_GENOME_RATES?=

## filename with gene territories (for association of transcript with genes in the reference set)
PARAM_FILENAME_TERRITORIES?=

## filename with GO assignments on the reference genome. 
## This file should be a tab-separated file giving gene_id go_id go_description
## for gene_id from :term:`PARAM_MASTER_SET_GENES`
PARAM_FILENAME_GO?=

## filename with GOSLIM assignments on the reference genome.
## This file should be a tab-separated file giving gene_id go_id go_description
## for gene_id from :term:`PARAM_MASTER_SET_GENES`
PARAM_FILENAME_GOSLIM?=

## sample this number of repeats to estimate the baseline
PARAM_NUM_REPEATS?=100000

## options for computing rates of transcripts. 
## Do not set --mask-lowercase if you are looking at repeats!
PARAM_PSL2TABLE_OPTIONS?=--mask-lowercase 

## database to use
PARAM_DATABASE?=csvdb

########################################################
## name of UCSC assembly for viewing
PARAM_VIEW_UCSC_ASSEMBLY?=

## set to compute views on
PARAM_VIEW_SET?=

## extra options to the gff2view.py command
PARAM_VIEW_OPTIONS?=

########################################################
## uniref database to use for CPC
PARAM_CPC_UNIREF?=/net/cpp-group/tools/cpc-0.9/data/uniref50/prot_db

########################################################
########################################################
########################################################
## maximum distance of ancestral repeats to be considered 
## in the neighbourhood of a transcript
PARAM_PROXIMAL_DISTANCE?=20000

################################################
## set of all transcripts
PARAM_SET_MERGED?=merged

## master set of all protein coding transcripts
PARAM_MASTER_SET_GENES?=ensembl

################################################
## derived sets - excluded from some analyses
PARAM_DERIVED_SETS?=

################################################
## control tracks - excluded from some analyses
PARAM_CONTROL_SETS?=

################################################
## sets to be ignored
PARAM_IGNORE_SETS?=

################################################
## sets to use for computing merged data
PARAM_SETS_TO_MERGE?=$(DATA_SAMPLES_WITHOUT_MASTER:%=%.gtf)

################################################
## filter for correlation
##
## require at least three matches for high confidence transcripts
PARAM_CORRELATION_MIN_MATCHES?=3

## minimum number of aligned bases in transcripts to accept a
## rate
PARAM_CORRELATION_MIN_ALIGNED?=100

## maximum estimated rate for a rate to be accepted
PARAM_CORRELATION_MAX_RATE?=5

## minimum number of repeats necessary for kikar
PARAM_CORRELATION_MIN_REPEATS?=10

################################################
## minimum length of transcripts to use for coding
## potential prediction
PARAM_CODING_MIN_LENGTH?=100

## maximum length of transcripts to use for coding
## potential prediction
PARAM_CODING_MAX_LENGTH?=200000

################################################
## minimum number of reads for high quality transcripts
PARAM_MIN_READS?=3

## minimum statistical coverage for high quality transcripts
PARAM_MIN_COVERAGE?=3

## table to use to calculate coverage of genes
PARAM_TABLE_NAME_COVERAGE_REFERENCE?=$(PARAM_MASTER_SET_GENES)
PARAM_TABLE_NAME_COVERAGE_DATA?=full

################################################
## filter for plots
##
## maximum rate to plot
PARAM_PLOT_MAX_RATE?=1

## general plot options
PARAM_PLOT_OPTIONS?=--as-lines

## minimum kikar to plot
PARAM_PLOT_MIN_KSKA=0.01

## maximum kikar to plot 
PARAM_PLOT_MAX_KSKA=100

## bin size for rate histograms
PARAM_PLOT_RATE_BIN?=0.005

## bin size for ki/kar histograms
PARAM_PLOT_KSKA_BIN?=0.05

## minimum number of repeats necessary for kikar
PARAM_PLOT_KSKA_MIN_REPEATS?=10

## minimum number of aligned for kikar
PARAM_PLOT_KSKA_MIN_ALIGNED?=100

## maximum rate to consider
PARAM_PLOT_KSKA_MAX_RATE?=1

## plot only if at least x data points
PARAM_PLOT_MIN_VALUES?=50

########################################################
## categories to stratify data by
## known: all known transcripts
## pc: protein coding genes
## unknown: unknown genes
## all: all genes
PARAM_CATEGORIES?=all known pc unknown ambiguous

################################################################
## if given, then some stats are computed for gene_id in this table
PARAM_TABLE_SELECTED?=

################################################################
################################################################
################################################################
## Parameters to select a trusted set

## minimum statistical coverage
PARAM_MIN_MEAN_COVERAGE?=2.0
## minimum absence/presence in sets
PARAM_MIN_SETS?=2
################################################################

################################################
## max number of parallel jobs on head node
PARAM_PARALLEL?=10

################################################
## annotator options
## location of annotator
PARAM_DIR_ANNOTATOR?=/home/gerton/Progs/Annotator/lib/

## number of iterations in annotator
PARAM_ANNOTATOR_ITERATIONS?=10000

## workspace for annotator. Currently implemented are:
##
## 1. genome.workspace = full genome
## 2. intergenic.workspace =  only intergenic segments
##
## all chromosomes containing "random" are ignored
## in all workspaces
PARAM_ANNOTATOR_WORKSPACE?=genome.workspace

## False discovery rate for collection annotator
## results
PARAM_ANNOTATOR_FDR?=0.05

################################################
# Section parameters: end
################################################

CLUSTER_OPTIONS=--cluster-priority=$(PARAM_PRIORITY) --cluster-queue=$(PARAM_QUEUE)

########################################################
########################################################
########################################################
## variables collecting the input data
########################################################
INPUT=$(filter-out $(PARAM_SET_MERGED).gtf,$(wildcard *.gtf))
INPUT_COVERAGES=$(wildcard *.coverage)
INPUT_POLYA=$(wildcard *.polyA)
INPUT_READSTATS=$(wildcard *.readstats)
INPUT_READINFO=$(wildcard *.readinfo)
INPUT_READMAP=$(wildcard *.readmap)
INPUT_READGTF=$(wildcard *.readgtf)

########################################################
########################################################
########################################################
## variables describing derived data
########################################################
## All data sets
DATA=$(filter-out $(PARAM_IGNORE_SETS), $(INPUT:%.gtf=%) )
DATA_READSTATS=$(filter-out $(PARAM_IGNORE_SETS), $(INPUT_READSTATS:%.readstats=% ) )
DATA_READMAP=$(filter-out $(PARAM_IGNORE_SETS), $(INPUT_READMAP:%.readmap=% ) )
DATA_READINFO=$(filter-out $(PARAM_IGNORE_SETS), $(INPUT_READINFO:%.readinfo=% ) )
DATA_COVERAGES=$(filter-out $(PARAM_IGNORE_SETS), $(INPUT_COVERAGES:%.coverage=%) )
DATA_READGTF=$(filter-out $(PARAM_IGNORE_SETS), $(INPUT_READGTF:%.readgtf=%) )

## Data sets excluding various subsets
DATA_RATES=$(DATA)
DATA_SAMPLES=$(filter-out $(PARAM_CONTROL_SETS) $(PARAM_MASTER_SET_GENES), $(DATA) )
DATA_SAMPLES_WITHOUT_MASTER=$(filter-out $(PARAM_MASTER_SET_GENES) $(PARAM_SET_MERGED) %.gz%, $(DATA_SAMPLES) )
DATA_NOT_MASTER:=$(filter-out $(PARAM_SET_MERGED) $(PARAM_CONTROL_SETS) $(PARAM_DERIVED_SETS), $(DATA))
DATA_NOT_REFERENCE:=$(filter-out $(PARAM_MASTER_SET_GENES) $(PARAM_CONTROL_SETS) $(PARAM_DERIVED_SETS), $(DATA))

########################################################
## Targets to build
ANNOTATIONS=$(DATA:%=%.annotation)
SEGMENTS=$(DATA:%=%.segments) 
RATES=$(DATA_RATES:%=%.rates.gz)
REPEATS=$(DATA_RATES:%=%.repeats)
REPEATS_RATES=$(DATA_RATES:%=%.repeats_rates.gz)
REPEATS_GC=$(DATA_RATES:%=%.repeats_gc.gz)
INTRONS_RATES=$(DATA_RATES:%=%.introns_rates.gz)
CODING=$(DATA_SAMPLES_WITHOUT_MASTER:%=%.coding)
DISTANCES=$(DATA:%=%.distances)
OVERRUNS=$(DATA:%=%.overrun)

########################################################
OPTION_INDEX=--index=gene_id

########################################################
########################################################
########################################################
## Primary targets
########################################################
all: build import

build: 
	$(PRELOG)
	$(MAKE) -k -j $(PARAM_PARALLEL) full-build
	$(EPILOG)

import: build full-import

analysis: build import
	$(PRELOG)
	$(MAKE) -k -j $(PARAM_PARALLEL) full-analysis
	$(EPILOG)

########################################################
## compute overlap with repeats
ifneq ($(PARAM_FILE_REPEATS),)
repeats-build: $(REPEATS)
repeats-import: $(REPEATS:%.repeats=%_repeats.import)
repeats-analysis: $(PARAM_CATEGORIES:%=repeats_%.png) 
else
repeats-build: 
repeats-import:
repeats-analysis:
endif

########################################################
## coding potential prediction require a protein database
ifneq ($(PARAM_CPC_UNIREF),)
coding-build: $(CODING)
coding-import: $(CODING:%.coding=%_coding.import)
coding-analysis: coding_classes.table \
			$(PARAM_CATEGORIES:%=coding_%.png) \
			coding_length.table
else
coding-build: 
coding-import:
coding-analysis: 
endif

########################################################
## compute GO annotator results if a GO file is given
ifneq ($(PARAM_FILENAME_GO),)
goannotator-build: $(DATA:%=%\:all_gogenes.annotators) $(DATA:%=%\:all_goterritories.annotators)
goannotator-import: goterritories_annotators.import
goannotator-analyis: go_results_genes.svg go_results_territories.svg
else
goannotator-build: 
goannotator-import: 
goannotator-analyis: 
endif

########################################################
## compute GO gene list results if a GO file is given
ifneq ($(PARAM_FILENAME_TERRITORIES),)
territories-build: $(DATA:%=%.territories) $(PARAM_SET_MERGED).territories
territories-import: territories.import $(DATA:%=%_territories.import) $(PARAM_SET_MERGED)_territories.import
golist-build: 
golist-import: 
golist-analyis: 
else
territories-build: 
territories-import: 
golist-build: 
golist-import: 
golist-analyis: 
endif

########################################################
## compute rates for transcripts and introns within transcripts
ifneq ($(PARAM_FILE_ALIGNMENTS),)
rates-build: $(RATES) 
rates-import: $(RATES:%.rates.gz=%_rates.import) 
rates-analysis: $(PARAM_CATEGORIES:%=ks_%.png) \
	$(PARAM_CATEGORIES:%=aligned_%.png) \
	rates_correlation.table
introns-rates-build: $(INTRONS_RATES)
introns-rates-import: $(INTRONS_RATES:%.introns_rates.gz=%_introns_rates.import)
introns-rates-analysis: $(PARAM_CATEGORIES:%=ki_%.png) \
	$(PARAM_CATEGORIES:%=kski_%.png) \
	rates_correlation.table
else
rates-build:
rates-import:
rates-analysis:
introns-rates-build:
introns-rates-import:
introns-rates-analysis:
endif

########################################################
ifneq ($(PARAM_FILE_REPEATS_RATES),)
## compute rates for repeats and normalize rates with these
repeats-rates-build: $(REPEATS_RATES) 
repeats-rates-import: \
	$(REPEATS:%.repeats=%_repeats.import) \
	$(REPEATS_RATES:%.repeats_rates.gz=%_repeats_rates.import) 
repeats-rates-analysis: $(PARAM_CATEGORIES:%=ka_%.png) \
	$(PARAM_CATEGORIES:%=kska_%.png) \
	rates_correlation.table
else
repeats-rates-build:
repeats-rates-import:
repeats-rates-analysis:
endif

########################################################
ifneq ($(PARAM_FILE_REPEATS_GC),)
## get GC of repeats
repeats-gc-build: $(REPEATS_GC) 
repeats-gc-import: $(REPEATS_GC:%.repeats_gc.gz=%_repeats_gc.import) 
repeats-gc-analysis: 
else
repeats-gc-build:
repeats-gc-import:
repeats-gc-analysis:
endif

########################################################
ifneq ($(INPUT_POLYA),)
polyA-analysis: polyA.table $(PARAM_CATEGORIES:%=polyA_%.png) 
else
polyA-analysis: 
endif

########################################################
ifneq ($(DATA_READSTATS),)
readstats-import: $(DATA_READSTATS:%=%_readstats.import) $(DATA_READMAP:%=%_readmap.import)
readstats-analysis: readstats.table
else
readstats-import: 
readstats-import: 
endif

########################################################
ifneq ($(DATA_READINFO),)
readinfo-import: $(DATA_READINFO:%=%_readinfo.import) 
readinfo-analysis:
else
readinfo-import: 
readinfo-import: 
endif

########################################################
ifneq ($(DATA_READGTF),)
READCOVERAGE_PAIRS=$(shell x=$(PARAM_MASTER_SET_GENES); for y in $(DATA_READGTF); do if [ $${x} != $${y} ]; then echo $${x}_vs_$${y}; fi; done)
readcoverage-build: $(READCOVERAGE_PAIRS:%=%.readcoverage) 
readcoverage-import: $(READCOVERAGE_PAIRS:%=%_readcoverage.import) 
else
readcoverage-build:
readcoverage-import:
endif

########################################################
ifneq ($(PARAM_SET_MERGED),)
master-overlap: $(PARAM_CATEGORIES:%=master_overlap_%.table) \
		$(PARAM_CATEGORIES:%=master_overlap_%.stats) \
		$(PARAM_CATEGORIES:%=master_compare_%.table) 
else
master-overlap:
endif

########################################################
ifneq ($(PARAM_TABLE_SELECTED),)
selection-analysis:	$(PARAM_CATEGORIES:%=selection_kska_%.png) \
			$(PARAM_CATEGORIES:%=selection_length_%.png) \
			selection_classes.table
else
selection-analysis:
endif

########################################################
ifneq ($(PARAM_MASTER_SET_GENES),)
CATEGORIES_WITHOUT_UNKNOWN=$(filter-out unknown ambiguous, $(PARAM_CATEGORIES))
reference-overlap: $(CATEGORIES_WITHOUT_UNKNOWN:%=reference_overlap_%.table) \
		$(CATEGORIES_WITHOUT_UNKNOWN:%=reference_overlap_%.stats) \
		$(CATEGORIES_WITHOUT_UNKNOWN:%=reference_compare_%.table)
else
reference-overlap:
endif

########################################################
overruns-analysis: overruns.table overruns_length.png

########################################################
prepare: $(PARAM_SET_MERGED).gtf repeats.gtf introns.gtf \
	gtf-import

########################################################
merged-gtf-build: $(DATA_COVERAGES:%=%.merged_gtf)

########################################################
## primary data computation target
full-build:  compare-build features-build rates-build introns-rates-build repeats-rates-build repeats-gc-build repeats-build territories-build readcoverage-build
full-import: compare-import features-import rates-import introns-rates-import repeats-rates-import repeats-gc-import repeats-import polyA-import territories-import readstats-import readinfo-import readmap-import readcoverage-import
full-analysis: evol.import compare-analysis features-analysis rates-analysis repeats-rates-analysis introns-rates-analysis master-overlap repeats-gc-analysis repeats-analysis polyA-analysis overrun-analysis \
		reference-overlap

## compare targets: annotation of transcript sets
compare-build:  annotations-build diffs-build distances-build segments-build overruns-build readcoverage-build
compare-import: annotations-import diffs-import coverages-import polyA-import distances-import segments-import overruns-import overlaps-build overlaps-import readcoverage-import
compare-analysis: classes tables lengths coverage reference-coverage splice polyA-analysis overruns-analysis \
			reference-overlap

## build features for transcript sets
features-build:  coding-build 
features-import: coding-import 
features-analysis: coding-analysis

################################################################
################################################################
################################################################
## Secondary data computation targets
################################################################
annotations-build: $(ANNOTATIONS)
segments-build: $(SEGMENTS)
distances-build: $(DISTANCES)
overruns-build: $(OVERRUNS)

################################################################
################################################################
################################################################
## Secondary analysis targets
################################################################
## stats about annotations
classes: classes.table classes_all.png classes_known.png classes_unknown.png

## stats about splice site
splice: splice_all.table splice_filtered.table

## stats about gene coverage of the reference gene set
reference-coverage: reference_coverage.table reference_coverage.stats \
	reference_coverage_percent.png reference_coverage_ntranscripts.png \
	reference_coverage_correlation.png reference_coverage.png \
	reference_coverage_vs_coverage.plot

## stats on coverage
coverage: coverage_correlation.table \
	coverage_per_class.table \
	coverage_per_class

## table sizes
tables: sizes.table 

## plot of lengths
lengths: $(PARAM_CATEGORIES:%=lengths_%.png) 

.PHONY: plots analysis clean-analysis 

clean-analysis:
	@rm -f *.png*
	@rm -f *.table
	@rm -f coverage_per_class

MASTER_SETS=$(PARAM_SET_MERGED) $(PARAM_MASTER_SET_GENES)

########################################################
########################################################
########################################################

########################################################
########################################################
########################################################
## diffs between sets
########################################################
DIFFSPAIRS=$(shell for x in $(MASTER_SETS); do for y in ${DATA}; do if [ $${x} != $${y} ]; then echo $${x}_vs_$${y}; fi; done; done)
diffs-build: $(DIFFSPAIRS:%=%.diff)
diffs-import: $(DIFFSPAIRS:%=%_diff.import)

########################################################
########################################################
########################################################
## overlaps between sets. These are computed after an
## initial import phase as these rely on annotations
########################################################
overlaps-build: $(PARAM_CATEGORIES:%=overlaps_%.table)
overlaps-import: $(PARAM_CATEGORIES:%=overlaps_%_table.import)

########################################################
########################################################
## Targets for control sets
########################################################
########################################################
########################################################
## build filename with random selection of ancestral repeats
########################################################
ifneq ($(PARAM_FILE_REPEATS_RATES),)
repeats.gtf: $(PARAM_FILE_REPEATS_RATES)
	$(PRELOG)
	@awk -v OFS="\t" '{$$9=sprintf ("gene_id \"%06i\"; transcript_id \"%06i\";", ++a, a); print;}'  < $< |\
	perl $(DIR_SCRIPTS_TOOLS)randomize_lines.pl |\
	head -n $(PARAM_NUM_REPEATS) |\
	sort -k1,1 -k4,4n > $@
	$(EPILOG)
else
repeats.gtf:
endif

########################################################
########################################################
########################################################
## build filename with random selection of fragments
########################################################
random.gtf: 
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)fasta2gff.py \
		--genome=$(PARAM_FILENAME_GENOME) \
		--as-gtf \
		--sample-size=$(PARAM_NUM_REPEATS) \
		--fragment-size=1000 \
		--log=$@.log |\
	sort -k1,1 -k4,4n > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## build filename with random selection of ancestral repeats
## that include artificial introns
########################################################
ifneq ($(PARAM_FILE_REPEATS_RATES),)
introns.gtf: $(PARAM_FILE_REPEATS_RATES)
	$(PRELOG)
	@sort -k1,1 -k 4,4n < $< |\
	python $(DIR_SCRIPTS_GENEPREDICTION)gff2gff.py --join=100,10000,2,5 --log=$@.log |\
	python $(DIR_SCRIPTS_GENEPREDICTION)gtf2gtf.py --filter=gene --sample-size=$(PARAM_NUM_REPEATS) --log=$@.log |\
	gff_sort pos > $@
	$(EPILOG)
else
introns.gtf:
endif

########################################################
########################################################
########################################################
## Targets for data tracks
## load data from a map_transcripts track
## for example
## make ../../gmap.add-tracks
########################################################
%.add-tracks:
	$(PRELOG)
	for fn in $*/*.gtf; do \
		prefix=$${fn%.gtf}; \
		track=$${prefix#$*/}; \
		$(CMD_LOG2) "adding $${track}" ;\
		if test -e $${prefix}.gtf; then ln -s $${prefix}.gtf $${track}.gtf ; fi; \
		if test -e $${prefix}.transcripts.coverage; then ln -s $${prefix}.transcripts.coverage $${track}.coverage; fi; \
		if test -e $${prefix}.transcripts.polyA; then ln -s $${prefix}.transcripts.polyA $${track}.polyA; fi; \
		if test -e $${prefix}.transcripts; then ln -s $${prefix}.transcripts $${track}.readmap; fi; \
		if test -e $${prefix}.filterstats; then ln -s $${prefix}.filterstats $${track}.readstats; fi; \
		if test -e $${prefix}.readstats; then ln -s $${prefix}.readstats $${track}.readinfo; fi; \
		if test -e $${prefix}_filter.gtf; then ln -s $${prefix}_filter.gtf $${track}.readgtf ; fi; \
	done
	$(EPILOG)

########################################################
########################################################
########################################################
## imports into sql database
########################################################
annotations-import: $(ANNOTATIONS:%.annotation=%_annotation.import)
segments-import: $(SEGMENTS:%.segments=%_segments.import)
gtf-import: $(DATA:%=%_gtf.import) merged_gtf.import
distances-import: $(DISTANCES:%.distances=%_distances.import)
overruns-import: $(OVERRUNS:%.overrun=%_overrun.import)
coverages-import: $(INPUT_COVERAGES:%.coverage=%_coverage.import) $(PARAM_SET_MERGED)_derivedcoverage.import
polyA-import: $(INPUT_POLYA:%.polyA=%_polyA.import)
readstats-import: $(DATA_READSTATS:%=%_readstats.import)
readinfo-import: $(DATA_READINFO:%=%_readinfo.import)
readmap-import: $(DATA_READMAP:%=%_readmap.import)

########################################################
## Tables to check
TABLES=_annotation _rates _introns_rates _repeats_rates _repeats_gc _coverage _evol

########################################################
########################################################
########################################################
## various functions
########################################################
COMBINE_PLOTS=python $(DIR_SCRIPTS_TOOLS)combine_tables.py --sort-keys=numeric $@.tmp_hist_* |\
	python $(DIR_SCRIPTS_TOOLS)plot_histogram.py --legend-location="center right" --log=$@.log --hardcopy=$@ $(PLOT_OPTIONS) $(PARAM_PLOT_OPTIONS); \
	python $(DIR_SCRIPTS_TOOLS)combine_tables.py --sort-keys=numeric $@.tmp_cumul_* |\
	python $(DIR_SCRIPTS_TOOLS)plot_histogram.py  --legend-location="center right" --log=$@.log --hardcopy=cumul_$@ $(PLOT_OPTIONS) $(PARAM_PLOT_OPTIONS); \
	python $(DIR_SCRIPTS_TOOLS)combine_tables.py --merge $@.tmp_data_* |\
	python $(DIR_SCRIPTS_TOOLS)r_table2scatter.py --allow-empty --plot=boxplot --log=$@.log --columns=all-but-first --hardcopy=box_$@ $(PLOT_OPTIONS_R) ; \
	rm -f $@.tmp_hist_* $@.tmp_cumul_* $@.tmp_data_* $@.tmp_stats_* 

COMBINE_TABLES=python $(DIR_SCRIPTS_TOOLS)combine_tables.py $@.tmp_tab_* > $@; \
	rm -f $@.tmp*

COMBINE_TABLES2=python $(DIR_SCRIPTS_TOOLS)combine_tables.py $@.tmp_tab_* > $@.table; \
	rm -f $@.tmp_tab_*

COMBINE_HISTS=python $(DIR_SCRIPTS_TOOLS)combine_tables.py $@.tmp_hist_* > $@.hist

########################################################
########################################################
########################################################
## merge all experimental datasets
########################################################
merged.gtf: $(PARAM_SETS_TO_MERGE)
	$(PRELOG)
	@cat $^ |\
	python $(DIR_SCRIPTS_GENEPREDICTION)gff2blat.py --log=$@.log --is-gtf --allow-duplicates |\
	python $(DIR_SCRIPTS_GENEPREDICTION)blat2blat.py --log=$@.log --method=rename-query --unique --output-filename-map=$@.id2new |\
	sort -k 14,14 -k16,16n |\
	$(CMD_FARM) \
		--split-at-column=14 \
		--output-header \
		$(CLUSTER_OPTIONS) \
		--renumber="M%06i" \
		--renumber-column=":id" \
		--log=$@.log \
		--subdirs \
		--max-files=60 \
	"python $(DIR_SCRIPTS_GENEPREDICTION)blat2assembly.py \
		--method=locus \
		--threshold-merge-distance=0 \
		--threshold-merge-overlap=1 \
		--staggered=all \
		--log=$@.log \
		--genome=genome \
		--output-filename-pattern=%DIR%$@.%s" \
	> $@.new2locus
	@python $(DIR_SCRIPTS_GENEPREDICTION)blat2gff.py \
		--log=$@.log \
		--as-gtf \
	< $@.locus.psl > $@
	$(EPILOG)

%_combined.gtf: %.gtf
	$(PRELOG)
	@cat $^ |\
	python $(DIR_SCRIPTS_GENEPREDICTION)
	python $(DIR_SCRIPTS_GENEPREDICTION)gff2blat.py --log=$@.log --is-gtf --allow-duplicates |\
	python $(DIR_SCRIPTS_GENEPREDICTION)blat2blat.py --log=$@.log --method=rename-query --unique --output-filename-map=$@.id2new |\
	sort -k 14,14 -k 16,16n |\
	$(CMD_FARM) \
		--split-at-column=14 \
		--output-header \
		$(CLUSTER_OPTIONS) \
		--renumber="M%06i" \
		--renumber-column=":id" \
		--log=$@.log \
		--subdirs \
		--max-files=60 \
	"python $(DIR_SCRIPTS_GENEPREDICTION)blat2assembly.py \
		--method=locus \
		--threshold-merge-distance=0 \
		--threshold-merge-overlap=1 \
		--staggered=all \
		--log=$@.log \
		--genome=genome \
		--output-filename-pattern=%DIR%$@.%s" \
	> $@.new2locus
	@python $(DIR_SCRIPTS_GENEPREDICTION)blat2gff.py \
		--log=$@.log \
		--as-gtf \
	< $@.locus.psl > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## build coverage information for merged transcrcipts
## merge nmatches and statistical coverage.
########################################################
$(PARAM_SET_MERGED).derivedcoverage: $(PARAM_SET_MERGED).gtf $(INPUT_COVERAGES:%.coverage=%_coverage.import)
	$(PRELOG)
	@for d in $(DATA_COVERAGES); do \
		s3v csvdb "SELECT gene_id1, SUM(nmatches), SUM(ncovered * mean), a.exons_sum  \
			FROM $${d}_coverage as c, merged_vs_$${d}_ovl AS m, $${d}_annotation AS a \
			WHERE c.gene_id = m.gene_id2 AND a.gene_id = c.gene_id GROUP by m.gene_id1, a.exons_sum"; \
	done | sort |\
	awk 'BEGIN {printf("gene_id\tnmatches\tmean\tncovered\n");} \
	{if ($$1 != l) {if(len > 0) {  printf("%s\t%i\t%f\t%i\n", l,nmatches,cov/len,len); } cov=0;nmatches=0;l=$$1;len=$$4}; nmatches+=$$2; cov+=$$3} \
	END { if (len>0) { printf("%s\t%f\t%f\n", l,nmatches,cov/len,len); }}' > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## import derived coverage
## Note: The table create is called 'coverage'
########################################################
%_derivedcoverage.import: %.derivedcoverage
	$(PRELOG)
	@grep -v "\bna\b" < $< | csv2db.py --map gene_id:str -b sqlite $(OPTION_INDEX) --table=$*_coverage > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## import gtf coordinates
########################################################
%_gtf.import: %.gtf
	$(PRELOG)
	@python	$(DIR_SCRIPTS_GENEPREDICTION)gtf2tsv.py < $< |\
	csv2db.py --map contig:str --map gene_id:str --map transcript_id:str \
		-b sqlite --index=gene_id --index=transcript_id --table=$*_gtf > $@	
	$(EPILOG)

########################################################
########################################################
########################################################
## annotate transcripts by location (intergenic, intronic, ...)
########################################################
%.annotation: %.gtf
	$(PRELOG)
	@$(DIR_SCRIPTS_GENEPREDICTION)gff_sort gene < $< |\
	$(CMD_FARM) --split-at-column=1 --output-header --log=$@.log --max-files=60 \
	"python /home/andreas/gpipe/gtf2table.py \
		--counter=position \
		--counter=classifier \
		--section=exons \
		--section=introns \
		--counter=length \
		--counter=splice \
		--counter=composition-na \
		--counter=splice-comparison \
		--log=$@.log \
		--filename-gff=$(PARAM_GENOME_REGIONS) \
		--genome-file=$(PARAM_FILENAME_GENOME)" > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## import annotation
########################################################
%_annotation.import: %.annotation
	$(PRELOG)
	@csv2db.py --map gene_id:str -b sqlite $(OPTION_INDEX) --table=$*_annotation < $< > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## annotate transcripts by location (intergenic, intronic, ...)
########################################################
%.overrun: %.gtf
	$(PRELOG)
	@$(DIR_SCRIPTS_GENEPREDICTION)gff_sort gene < $< |\
	$(CMD_FARM) --split-at-column=1 --output-header --log=$@.log --max-files=60 \
	"python /home/andreas/gpipe/gtf2table.py \
		--counter=overrun \
		--log=$@.log \
		--filename-gff=$(PARAM_GENOME_REGIONS) " > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## import annotation
########################################################
%_overrun.import: %.overrun
	$(PRELOG)
	@csv2db.py --map gene_id:str -b sqlite $(OPTION_INDEX) --table=$*_overrun < $< > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## compute coding potential for sequences. Do both directions
## as transcription direction is not known
########################################################
%.coding: %.norepeats.fa
	$(PRELOG)
	@rm -rf $@.*
	@$(DIR_SCRIPTS_TOOLS)cpc.sh $< $@.forward.table $@.tmp.dir $@.forward.evidence $(PARAM_CPC_UNIREF) > $@.log
	@python $(DIR_SCRIPTS_TOOLS)fasta2fasta.py \
		--method=reverse-complement --log=$@.log < $< > $@.tmp.reverse.fasta
	@$(DIR_SCRIPTS_TOOLS)cpc.sh $@.tmp.reverse.fasta $@.reverse.table $@.tmp.dir $@.reverse.evidence $(PARAM_CPC_UNIREF) >> $@.log
	@printf "gene_id\tlength\tf_iscoding\tf_value\tf_orfstart\tf_orfend\tf_orfval1\tf_orfval2\tf_orf\tr_iscoding\tr_value\tr_orfstart\tr_orfend\tr_orfval1\tr_orfval2\tr_orf\n" > $@
	@ct -v 0 $@.forward.table $@.forward.evidence.orf $@.reverse.table $@.reverse.evidence.orf |\
	cut -f 1,2,3,4,6,7,8,9,10,12,13,15- >> $@
	@gzip $@*.homo*
	@rm -rf $@.tmp*
	$(EPILOG)

%_coding.import: %.coding
	$(PRELOG)
	@csv_cut gene_id f_iscoding r_iscoding < $< |\
	awk '/^gene_id/ {printf("gene_id\tis_coding\n" ); next; } \
		$$2 == "coding" || $$3 == "coding" { printf("%s\t1\n", $$1); next; } \
		{ printf("%s\t0\n", $$1) }' |\
	csv2db.py --allow-empty --map gene_id:str -b sqlite $(OPTION_INDEX) --table=$*_coding > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## filter the alignment for rate computation to exclude
## all exons.
########################################################
alignment_filtered.psl: $(PARAM_FILE_ALIGNMENTS) $(PARAM_MASTER_SET_GENES).gtf
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) \
	python $(DIR_SCRIPTS_GENEPREDICTION)blat2blat.py \
		--method=filter-remove \
		--filter-query=$(PARAM_MASTER_SET_GENES).gtf  \
		--log=$@.log \
	< $< > $@
	$(EPILOG)

%.stats: %.psl
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) \
	python $(DIR_SCRIPTS_GENEPREDICTION)psl2stats.py \
		--log=$@.log \
	< $< > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## annotate transcripts by territories
########################################################
%.territories: %.gtf $(PARAM_FILENAME_TERRITORIES)
	$(PRELOG)
	@cat $< |\
	$(CMD_FARM) --split-at-column=1 --output-header --log=$@.log --max-files=60 \
	"python $(DIR_SCRIPTS_GENEPREDICTION)gtf2table.py \
		--counter=territories \
		--log=$@.log \
		--filename-gff=$(PARAM_FILENAME_TERRITORIES) \
		--genome-file=$(PARAM_FILENAME_GENOME)" > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## import territory definitionns
########################################################
territories.import: $(PARAM_FILENAME_TERRITORIES)
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)gtf2tsv.py \
	< $< |\
	csv2db.py --map contig:str --map gene_id:str --map transcript_id:str \
		-b sqlite --index=gene_id --index=transcript_id --table=territories > $@	
	$(EPILOG)

########################################################
########################################################
########################################################
## import territories
##   deconvolute entries
########################################################
%_territories.import: %.territories
	$(PRELOG)
	@awk '/gene_id/ {print; next; } \
		{ split($$6,a,":"); for (x in a) \
		{ printf("%s\t%s\t%s\t%s\t%s\t%s\n", $$1,$$2,$$3,$$4,$$5,a[x]); } }' \
	< $< |\
	csv2db.py --map gene_id:str -b sqlite $(OPTION_INDEX) --index=territories --table=$*_territories \
	> $@
	$(EPILOG)

########################################################
########################################################
########################################################
## compute distance to closest gene
########################################################
%.distances: %.gtf $(PARAM_MASTER_SET_GENES).gtf
	$(PRELOG)
	@cat $< |\
	$(CMD_FARM) --split-at-column=1 --output-header --log=$@.log --max-files=60 \
	"python $(DIR_SCRIPTS_GENEPREDICTION)gtf2table.py \
		--counter=distance-genes \
		--log=$@.log \
		--filename-gff=$(PARAM_MASTER_SET_GENES).gtf " > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## import distances
########################################################
%_distances.import: %.distances
	$(PRELOG)
	@csv2db.py --map gene_id:str -b sqlite $(OPTION_INDEX) --index=closest_id --table=$*_distances < $< > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## annotate overlap of transcripts with repeats
########################################################
%.repeats: %.gtf $(PARAM_FILE_REPEATS)
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) python $(DIR_SCRIPTS_GENEPREDICTION)gtf2table.py \
		--log=$@.log \
		--counter=overlap \
		--filename-gff=$(PARAM_FILE_REPEATS) \
		< $< > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## import repeat overlap statistics
########################################################
%_repeats.import: %.repeats
	$(PRELOG)
	@csv2db.py --map gene_id:str -b sqlite $(OPTION_INDEX) --table=$*_repeats < $< > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## extract sequences for transcripts in ucsc format
########################################################
%.fa: %.gtf
	$(PRELOG)
	@$(DIR_SCRIPTS_GENEPREDICTION)gff_sort gene < $< |\
	python $(DIR_SCRIPTS_GENEPREDICTION)gff2fasta.py \
		--is-gtf \
		--genome-file=$(PARAM_FILENAME_GENOME) \
		--log=$@.log \
	> $@
	$(EPILOG)

########################################################
########################################################
########################################################
## extract sequences for transcripts in ucsc format, but
## remove sequences overlapping repeats
########################################################
%.norepeats.fa: %.gtf
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) \
	"$(DIR_SCRIPTS_GENEPREDICTION)gff_sort gene < $< |\
	python $(DIR_SCRIPTS_GENEPREDICTION)gff2fasta.py \
		--is-gtf \
		--genome-file=$(PARAM_FILENAME_GENOME) \
		--remove-masked-regions \
		--filename-masks=$(PARAM_FILE_REPEATS) \
		--min-length=$(PARAM_CODING_MIN_LENGTH) \
		--max-length=$(PARAM_CODING_MAX_LENGTH) \
		--log=$@.log \
	> $@"
	$(EPILOG)


########################################################
########################################################
########################################################
## extract sequences for transcripts and index them
########################################################
%.fasta: %.gtf
	$(PRELOG)
	@rm -f $*.{fasta,idx}
	@$(DIR_SCRIPTS_GENEPREDICTION)gff_sort gene < $< |\
	python $(DIR_SCRIPTS_GENEPREDICTION)gff2fasta.py \
		--is-gtf \
		--genome-file=$(PARAM_FILENAME_GENOME) \
		--log=$@.log |\
	python $(DIR_SCRIPTS_TOOLS)index_fasta.py $* - > $@.log
	$(EPILOG)

########################################################
########################################################
########################################################
## compute rates in a gtf file - this applies only for
## transcripts mapped onto the reference genome (here: human)
##
## Sequences from the transcripts are mapped onto the rate genome (here: mouse)
## Softmasked sequence will be ignored. The longest contiguous block is selected
## ignoring matches to other parts of the genome.
########################################################
%.rates.gz: %.gtf %.fasta
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) \
	"$(DIR_SCRIPTS_GENEPREDICTION)gff_sort gene < $< |\
	python $(DIR_SCRIPTS_GENEPREDICTION)gff2blat.py --is-gtf --log=$@.log --genome-file=$(PARAM_FILENAME_GENOME) > $@.tmp.psl" < /dev/null
	@$(CMD_REMOTE_SUBMIT) \
	pslMap $@.tmp.psl $(PARAM_FILE_ALIGNMENTS) $@.tmp_aligned.psl < /dev/null
	@$(CMD_REMOTE_SUBMIT) \
	"sort -k10,10 -k14,14 -k9,9 -k12,12n < $@.tmp_aligned.psl |\
	python $(DIR_SCRIPTS_GENEPREDICTION)blat2blat.py --method=merge --log=$@.log |\
	python $(DIR_SCRIPTS_GENEPREDICTION)blat2blat.py --method=select-query --select=most-nmatches --log=$@.log |\
	python $(DIR_SCRIPTS_GENEPREDICTION)blat2blat.py --method=add-sequence --filename-target=$(PARAM_FILENAME_GENOME_RATES) --filename-queries=$* > $@.tmp_filtered.pslx "
	@cat $@.tmp_filtered.pslx | farm.py --split-at-lines=10000 --output-header $(CLUSTER_OPTIONS) --log=$@.log \
		"python $(DIR_SCRIPTS_GENEPREDICTION)psl2table.py $(PSL2TABLE_OPTIONS) --method=counts --method=baseml --baseml-model=REV" |\
	gzip > $@
	@rm -f $@.tmp*
	$(EPILOG)

########################################################
########################################################
########################################################
## import rates for each transcript
## Filters:
##    select the longest stretch for each transcript
########################################################
%_rates.import: %.rates.gz
	$(PRELOG)
	@gunzip < $< |\
	csv_cut --large --remove qStarts tStarts blockSizes qSequence tSequence --log=$@ |\
	csort -k:qName: -k:aligned:rn |\
	perl -p -e "s/qName/gene_id/" |\
	awk '{if (l==$$10) {next;} l = $$10; print; }' |\
	csv2db.py --map gene_id:str -b sqlite $(OPTION_INDEX) --table=$*_rates > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## Compute intron rates from a gtf file - this applies only for
## transcripts mapped onto the reference genome (here: human)
##
## Sequences from the transcripts are mapped onto the rate genome (here: mouse)
##
## Softmasked sequence will be ignored. 
##
## 1. get extent of genes: $@.tmp_genes
## 2. get introns: $@.tmp_introns.gtf and $@.tmp_introns.psl
## 3. map introns from source to target genome, merge and filter such that only
##    introns within the full extend of the gene remain: $@.tmp_aligned.psl
## 4. add sequence: $@.tmp_aligned.pslx
## 5. compute rates
##
## Note that introns are the regions between exons. If exons are
## shortened due to alignment problems the rates will not be accurate.
##
## 10 residues are removed from either end of an intron and only introns
## of an individual length of 100 are retained. The intronic rate is
## computed for the concatenated introns, though.
########################################################
%.introns_rates.gz: %.gtf alignment_filtered.psl
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) \
	"$(DIR_SCRIPTS_GENEPREDICTION)gff_sort gene < $< |\
	 python $(DIR_SCRIPTS_GENEPREDICTION)gtf2gtf.py --exons2introns --intron-min-length=100 --intron-border=10 --log=$@.log < $< |\
	 python $(DIR_SCRIPTS_GENEPREDICTION)gtf2gtf.py --set-transcript-to-gene --log=$@.log |\
	 perl -p -e 's/intron/exon/' > $@.tmp_introns.xgtf"  < /dev/null; \
	$(CMD_REMOTE_SUBMIT) \
	"python $(DIR_SCRIPTS_GENEPREDICTION)gff2fasta.py --is-gtf --genome-file=$(PARAM_FILENAME_GENOME) --log=$@.log < $@.tmp_introns.xgtf |\
		python $(DIR_SCRIPTS_TOOLS)index_fasta.py --log=$@.log $@.tmp -"  < /dev/null; \
	$(CMD_REMOTE_SUBMIT) \
	"python $(DIR_SCRIPTS_GENEPREDICTION)gff2blat.py --is-gtf --log=$@.log --genome-file=$(PARAM_FILENAME_GENOME) < $@.tmp_introns.xgtf > $@.tmp_introns.psl"  < /dev/null; \
	$(CMD_REMOTE_SUBMIT) \
	pslMap $@.tmp_introns.psl alignment_filtered.psl $@.tmp_aligned.psl < /dev/null >& $@.log; \
	$(CMD_REMOTE_SUBMIT) \
	"sort -k10,10 -k14,14 -k9,9 -k12,12n < $@.tmp_aligned.psl | \
	 python $(DIR_SCRIPTS_GENEPREDICTION)blat2blat.py --method=merge --log=$@.log |\
	 python $(DIR_SCRIPTS_GENEPREDICTION)blat2blat.py --method=select-query --select=most-nmatches --log=$@.log |\
	 python $(DIR_SCRIPTS_GENEPREDICTION)blat2blat.py --method=add-sequence --filename-target=$(PARAM_FILENAME_GENOME_RATES) --filename-queries=$@.tmp > $@.tmp_filtered.pslx "\
	< /dev/null ;\
	cat $@.tmp_filtered.pslx | farm.py --split-at-lines=10000 --output-header $(CLUSTER_OPTIONS) --log=$@.log \
		"python $(DIR_SCRIPTS_GENEPREDICTION)psl2table.py $(PSL2TABLE_OPTIONS) --method=counts --method=baseml --baseml-model=REV" |\
	gzip > $@
	@rm -f $@.tmp*
	$(EPILOG)


########################################################
########################################################
########################################################
## import rates for each transcript
## Filters:
##    select the longest stretch for each transcript
########################################################
%_introns_rates.import: %.introns_rates.gz
	$(PRELOG)
	@gunzip < $< |\
	csv_cut --large --remove qStarts tStarts blockSizes qSequence tSequence --log=$@ |\
	csort -k:qName: -k:aligned:rn |\
	perl -p -e "s/qName/gene_id/" |\
	awk '{if (l==$$10) {next;} l = $$10; print; }' |\
	csv2db.py --allow-empty --map gene_id:str -b sqlite $(OPTION_INDEX) --table=$*_introns_rates > $@
	$(EPILOG)

########################################################
########################################################
########################################################
##
## Table with filtering options for rates
##  
########################################################
rates.table:
	$(PRELOG)
	@for d in $(DATA_RATES); do \
		$(CMD_LOG2) "processing $${d}"; \
		printf "filter\t%s\n" $${d} > $@.tmp_tab_$${d}; \
		printf "total\t%i\n" `s3v $(PARAM_DATABASE) "SELECT COUNT(*) FROM $${d}_rates"` >> $@.tmp_tab_$${d}; \
		printf "aligned >= $(PARAM_PLOT_KSKA_MIN_ALIGNED)\t%i\n" `s3v $(PARAM_DATABASE) "SELECT COUNT(*) FROM $${d}_rates WHERE aligned >= $(PARAM_PLOT_KSKA_MIN_ALIGNED)"` >> $@.tmp_tab_$${d}; \
		printf "ks >= 0\t%i\n" `s3v $(PARAM_DATABASE) "SELECT COUNT(*) FROM $${d}_rates WHERE distance >= 0"` >> $@.tmp_tab_$${d}; \
		printf "ks <= $(PARAM_PLOT_KSKA_MAX_RATE)\t%i\n" `s3v $(PARAM_DATABASE) "SELECT COUNT(*) FROM $${d}_rates WHERE distance <= $(PARAM_PLOT_KSKA_MAX_RATE)"` >> $@.tmp_tab_$${d}; \
		printf "converged\t%i\n" `s3v $(PARAM_DATABASE) "SELECT COUNT(*) FROM $${d}_rates WHERE converged"` >> $@.tmp_tab_$${d}; \
		printf "repeats\t%i\n" `s3v $(PARAM_DATABASE) "SELECT COUNT(*) FROM $${d}_rates AS a, $${d}_repeats_rates AS b WHERE a.gene_id = b.gene_id"` >> $@.tmp_tab_$${d}; \
		printf "ka >= 0\t%i\n" `s3v $(PARAM_DATABASE) "SELECT COUNT(*) FROM $${d}_rates AS a, $${d}_repeats_rates AS b WHERE a.gene_id = b.gene_id AND b.exons_mean >= 0"` >> $@.tmp_tab_$${d}; \
		printf "ka <= $(PARAM_PLOT_KSKA_MAX_RATE)\t%i\n" `s3v $(PARAM_DATABASE) "SELECT COUNT(*) FROM $${d}_rates AS a, $${d}_repeats_rates AS b WHERE a.gene_id = b.gene_id AND distance <= $(PARAM_PLOT_KSKA_MAX_RATE)"` \
			>> $@.tmp_tab_$${d}; \
		printf "nrepeats >= $(PARAM_PLOT_KSKA_MIN_REPEATS)\t%i\n" `s3v $(PARAM_DATABASE) "SELECT COUNT(*) FROM $${d}_rates AS a, $${d}_repeats_rates AS b WHERE a.gene_id = b.gene_id AND b.exons_sum >= $(PARAM_PLOT_KSKA_MIN_REPEATS)"` \
			>> $@.tmp_tab_$${d}; \
		printf "all filters\t%i\n" `s3v $(PARAM_DATABASE) "SELECT COUNT(*) FROM $${d}_rates AS a, $${d}_repeats_rates AS b WHERE \
					a.gene_id = b.gene_id AND \
					a.distance > 0 AND \
					a.distance <= $(PARAM_PLOT_KSKA_MAX_RATE) AND \
					b.exons_mean > 0 AND \
					b.exons_mean <= $(PARAM_PLOT_KSKA_MAX_RATE) AND \
					b.exons_sum >= $(PARAM_PLOT_KSKA_MIN_REPEATS) AND \
					a.converged AND \
					a.aligned >= $(PARAM_PLOT_KSKA_MIN_ALIGNED)"` >> $@.tmp_tab_$${d}; \
	done; \
	$(COMBINE_TABLES)
	$(EPILOG)


########################################################
########################################################
########################################################
## compute overlap with coding/non-coding in various classes and sets
########################################################
coding_classes.table:
	$(PRELOG)
	@for class in $(PARAM_CATEGORIES); do \
		$(CMD_LOG2) "processing $${class}"; \
		if [[ "$${class}" == "all" ]]; then where="1"; else where="is_$${class}"; fi; \
		for d in $(DATA); do \
			s3v $(PARAM_DATABASE) "SELECT '$${class}', '$${d}', SUM(co.is_coding), SUM(1-co.is_coding) \
				FROM $${d}_annotation AS an, $${d}_coding AS co \
				WHERE an.gene_id = co.gene_id AND $${where}"; \
		done; \
	done |\
	awk 'BEGIN{ printf("class\tset\ttotal\tcoding\tnoncoding\tpcoding\tpnoncoding\n"); }\
		NF == 4 { total=$$3+$$4; \
			printf("%s\t%s\t%i\t%i\t%i\t%5.2f\t%5.2f\n", \
			$$1,$$2,total,$$3,$$4,$$3*100/total,$$4*100/total); }' > $@
	$(EPILOG)

coding_all.png: PLOT_OPTIONS=--title="Transcripts with/without coding potential in all transcripts"
coding_pc.png: PLOT_OPTIONS=--title="Transcripts with/without coding potential in protein coding transcripts"
coding_known.png: PLOT_OPTIONS=--title="Transcripts with/without coding potential in known transcripts"
coding_unknown.png: PLOT_OPTIONS=--title="Transcripts with/without coding potential in unknown transcripts"

coding_%.png: coding_classes.table
	$(PRELOG)
	@csv_cut class set coding noncoding < $< | grep -e "^$*" -e "set" |\
	csv_cut set coding noncoding | t2t --transpose | t2r --plot=bar-stacked --legend=1 -v 0 --labels="set,counts" $(PLOT_OPTIONS) --hardcopy=$@
	@csv_cut class set pcoding pnoncoding < $< | grep -e "^$*" -e "set" |\
	csv_cut set pcoding pnoncoding | t2t --transpose | t2r --plot=bar-stacked --legend=1 -v 0 --labels="set,percent" $(PLOT_OPTIONS) --hardcopy=relative_$@
	$(EPILOG)

########################################################
########################################################
########################################################
## compute chi-square test for prediction of coding potential
## 
########################################################
coding_%.tests:
	$(PRELOG)
	@rm -f $@.tmp
	@for d1 in $(DATA_SAMPLES); do \
		for d2 in $(DATA_SAMPLES); do \
			if [[ "$${d1}" < "$${d2}" ]]; then \
				printf ">$${d1}-$${d2}\n" >> $@.tmp; \
				printf "matrix\tcoding\tnoncoding\n" >> $@.tmp; \
				printf "%s\t%i\t%i\n" $${d1} \
				`s3v $(PARAM_DATABASE) "SELECT COUNT(NULLIF(is_coding,1)), COUNT(NULLIF(is_coding,0)) FROM $${d1}_annotation AS d, $${d1}_coding AS c WHERE c.gene_id = d.gene_id AND d.is_$*"` >> $@.tmp; \
				printf "%s\t%i\t%i\n" $${d2} \
				`s3v $(PARAM_DATABASE) "SELECT COUNT(NULLIF(is_coding,1)), COUNT(NULLIF(is_coding,0)) FROM $${d2}_annotation AS d, $${d2}_coding AS c WHERE c.gene_id = d.gene_id AND d.is_$*"` >> $@.tmp; \
			fi; \
		done; \
	done
	@python $(DIR_SCRIPTS_TOOLS)matrix2stats.py --method=chi-squared < $@.tmp > $@
	@rm -f $@.tmp
	$(EPILOG)

########################################################
########################################################
########################################################
## compute length distributions for pc/unknown transcripts
## of coding and non-coding transcripts for each dataset
########################################################
coding_length.table: PLOT_OPTIONS=--logscale=x --title="Distribution of transcript length" --xtitle="length / nucleotides" --legend-location="center right" --log=$@.log --normalize --as-lines
coding_length.table:
	$(PRELOG)
	@rm -f $@_tmp*
	@for d in $(DATA); do \
		$(CMD_LOG2) "processing $${d}"; \
		for class in $(PARAM_CATEGORIES); do \
			if [[ "$${class}" == "all" ]]; then where="1"; else where="is_$${class}"; fi; \
			s3 $(PARAM_DATABASE) "SELECT exons_sum AS '$${class}_coding' FROM $${d}_coding as a, $${d}_annotation as e WHERE a.gene_id = e.gene_id AND $${where} AND is_coding" | d2h --min-data=50 > $@_tmp.$${class}_coding; \
			s3 $(PARAM_DATABASE) "SELECT exons_sum AS '$${class}_noncoding' FROM $${d}_coding as a, $${d}_annotation as e WHERE a.gene_id = e.gene_id AND $${where} AND not is_coding" | d2h --min-data=50 > $@_tmp.$${class}_noncoding; \
		done; \
		ct --sort-keys=numeric $@_tmp.* > $@.$${d}.table; \
		h2p --hardcopy=$@.$${d}.png $(PLOT_OPTIONS) --ytitle="relative frequency" < $@.$${d}.table; \
		h2p --cumulate --hardcopy=cumul_$@.$${d}.png $(PLOT_OPTIONS) --ytitle="cumulative frequency" < $@.$${d}.table ; \
		rm -f $@_tmp.*; \
	done
	@touch $@
	$(EPILOG)

########################################################
########################################################
########################################################
## length distribution of transcripts
########################################################
LENGTHS2HIST=d2h --min-value=0 --bin-size=10 --headers=$${d} --normalize --min-data=$(PARAM_PLOT_MIN_VALUES) --log=$@.log > $@.tmp_hist_$${d}
LENGTHS2HISTC=d2h --min-value=0 --bin-size=10 --headers=$${d} --normalize --min-data=$(PARAM_PLOT_MIN_VALUES) --cumulative --log=$@.log > $@.tmp_cumul_$${d}
LENGTHS2STATS=d2s --log=$@.log > $@.tmp_tab_$${d}
LENGTHS_SELECT=if [[ "$*" == "all" ]]; then where="1"; else where="is_$*"; fi; \
		s3 $(PARAM_DATABASE) "select exons_sum AS $${d} from $${d}_annotation as b WHERE $${where}" 

lengths_%.png: PLOT_OPTIONS=--logscale=x --title="Distribution of transcript lengths in $* transcripts" --xtitle="trancript length / bases" 
lengths_%.png: PLOT_OPTIONS_R=--logscale=y --title="Distribution of transcript lengths in $* transcripts" 

lengths_%.png: 
	$(PRELOG)
	@for d in $(DATA); do \
		$(LENGTHS_SELECT) > $@.tmp_data_$${d}; cat $@.tmp_data_$${d} | $(LENGTHS2HIST); cat $@.tmp_data_$${d} | $(LENGTHS2HISTC); cat $@.tmp_data_$${d} | $(LENGTHS2STATS); \
	done; \
	$(COMBINE_HISTS); $(COMBINE_TABLES2); $(COMBINE_PLOTS)
	$(EPILOG)


########################################################
########################################################
########################################################
## length distribution of overruns
########################################################
overruns_length.png: PLOT_OPTIONS=--logscale=x --title="Distribution of the length of intron overruns" --xtitle="length / bases" 
overruns_length.png: PLOT_OPTIONS_R=--logscale=y --title="Distribution of the length of intron overruns" 

overruns_length.png: 
	$(PRELOG)
	@for d in $(DATA); do \
		s3 $(PARAM_DATABASE) "select nover_intronic AS $${d} from $${d}_annotation as b WHERE is_known AND nover_intronic > 0" > $@.tmp_data_$${d}; \
		cat $@.tmp_data_$${d} | d2h --min-data=10 --min-value=0 --bin-size=1 --headers=$${d} --normalize --min-data=$(PARAM_PLOT_MIN_VALUES) --log=$@.log > $@.tmp_hist_$${d}; \
		cat $@.tmp_data_$${d} | d2h --min-data=10 --min-value=0 --bin-size=1 --headers=$${d} --normalize --min-data=$(PARAM_PLOT_MIN_VALUES) --reverse-cumulative --log=$@.log > $@.tmp_cumul_$${d}; \
		cat $@.tmp_data_$${d} | d2s --log=$@.log > $@.tmp_tab_$${d}; \
	done; \
	$(COMBINE_HISTS); $(COMBINE_TABLES2); $(COMBINE_PLOTS)
	$(EPILOG)

########################################################
########################################################
########################################################
## number of overruns in transcripts
########################################################
overruns_length.png: PLOT_OPTIONS=--logscale=x --title="Distribution of the length of intron overruns" --xtitle="length / bases" 

overruns.table: 
	$(PRELOG)
	@printf "set\ttotal\tall\t>5\n" > $@
	@for d in $(DATA); do \
		s3v $(PARAM_DATABASE) "select '$${d}', count(*), count(NULLIF( nover_intronic, 0)), count(NULLIF( MAX(nover_intronic,5), 5)) from $${d}_annotation as b WHERE is_known" >> $@; \
	done
	@csv_cut set all ">5" < $@ | t2t --transpose | t2r --plot=bar-besides --columns=all-but-first --hardcopy=$@.png --legend=1 --labels="set,percent" --options="cex.names=1.0" --log=$@.log 
	@csv_cut set total all ">5" < $@ |\
	t2t --transpose |\
	t2t -m normalize-by-max -m multiply-by-value -p 100 --columns=all-but-first --format="%6.4f" | grep -v "total" |\
	t2r --plot=bar-besides --columns=all-but-first --hardcopy=relative_$@.png --legend=1 --labels="set,percent" --options="cex.names=1.0" --log=$@.log 
	$(EPILOG)

########################################################
########################################################
########################################################
## Distribution of rates
########################################################
KS2HIST=d2h --min-data=10 --min-value=0 --bin-size=$(PARAM_PLOT_RATE_BIN) --headers=$${d} --normalize --min-data=$(PARAM_PLOT_MIN_VALUES) --log=$@.log > $@.tmp_hist_$${d}
KS2HISTC=d2h --min-data=10 --min-value=0 --bin-size=$(PARAM_PLOT_RATE_BIN) --headers=$${d} --normalize --min-data=$(PARAM_PLOT_MIN_VALUES) --cumulative --log=$@.log > $@.tmp_cumul_$${d}
KS2STATS=d2s --log=$@.log > $@.tmp_tab_$${d}
KS_SELECT=if [[ "$*" == "all" ]]; then where="1"; else where="is_$*"; fi; \
		s3 $(PARAM_DATABASE) "SELECT e.ks AS $${d} \
			 	FROM $${d}_annotation AS a, $${d}_evol AS e \
				WHERE a.gene_id = e.gene_id AND \
					e.ks IS NOT NULL AND e.ks > 0 AND \
					$${where}"

ks_%.png: PLOT_OPTIONS=--xrange=0,$(PARAM_PLOT_MAX_RATE) --title="Distribution of ks rates in $* transcripts" --xtitle="rate"
ks_%.png: PLOT_OPTIONS_R=--yrange=0,$(PARAM_PLOT_MAX_RATE) --title="Distribution of ks rates in $* transcripts"

ks_%.png: evol.import
	$(PRELOG)
	@for d in $(DATA); do \
		$(KS_SELECT) > $@.tmp_data_$${d}; cat $@.tmp_data_$${d} | $(KS2HIST); cat $@.tmp_data_$${d} | $(KS2HISTC); cat $@.tmp_data_$${d} | $(KS2STATS); \
	done; \
	$(COMBINE_HISTS); $(COMBINE_TABLES2); $(COMBINE_PLOTS)
	@rm -f $@.tmp*
	$(EPILOG)

########################################################
########################################################
########################################################
## table with information about exons
########################################################
EXONS2HIST=d2h --min-data=10 --min-value=0 --bin-size=$(PARAM_PLOT_RATE_BIN) --headers=$${d} --normalize --min-data=$(PARAM_PLOT_MIN_VALUES) --log=$@.log > $@.tmp_hist_$${d}
EXONS2HISTC=d2h --min-data=10 --min-value=0 --bin-size=$(PARAM_PLOT_RATE_BIN) --headers=$${d} --normalize --min-data=$(PARAM_PLOT_MIN_VALUES) --cumulative --log=$@.log > $@.tmp_cumul_$${d}
EXONS2STATS=d2s --log=$@.log > $@.tmp_tab_$${d}
EXONS_SELECT=if [[ "$*" == "all" ]]; then where="1"; else where="is_$*"; fi; \
		s3 $(PARAM_DATABASE) "SELECT exons_nval AS $${d} FROM $${d}_annotation AS a WHERE $${where}"


exons_%.png: PLOT_OPTIONS=--title="Distribution of exon number in $* transcripts" --xtitle="exon number"
exons_%.png: PLOT_OPTIONS_R=--title="Distribution of exon number in $* transcripts"

exons_%.png: 
	$(PRELOG)
	@for d in $(DATA); do \
		$(KS_SELECT) > $@.tmp_data_$${d}; cat $@.tmp_data_$${d} | $(KS2HIST); cat $@.tmp_data_$${d} | $(KS2HISTC); cat $@.tmp_data_$${d} | $(KS2STATS); \
	done; \
	$(COMBINE_HISTS); $(COMBINE_TABLES2); $(COMBINE_PLOTS)
	@rm -f $@.tmp*
	$(EPILOG)

########################################################
########################################################
########################################################
## Distribution of ancestral repeat rates
########################################################
KA2HIST=d2h --min-data=10 --min-value=0 --bin-size=$(PARAM_PLOT_RATE_BIN) --headers=$${d} --normalize --min-data=$(PARAM_PLOT_MIN_VALUES) --log=$@.log > $@.tmp_hist_$${d}
KA2HISTC=d2h --min-data=10 --min-value=0 --bin-size=$(PARAM_PLOT_RATE_BIN) --headers=$${d} --normalize --min-data=$(PARAM_PLOT_MIN_VALUES) --cumulative --log=$@.log > $@.tmp_cumul_$${d}
KA2STATS=d2s --log=$@.log > $@.tmp_tab_$${d}
KA_SELECT=if [[ "$*" == "all" ]]; then where="1"; else where="is_$*"; fi; \
		s3 $(PARAM_DATABASE) "SELECT e.ka AS $${d} \
			 	FROM $${d}_annotation AS a, $${d}_evol AS e \
				WHERE a.gene_id = e.gene_id AND \
					e.ka IS NOT NULL AND e.ka > 0 AND \
					$${where}"

ka_%.png: PLOT_OPTIONS=--xrange=0,$(PARAM_PLOT_MAX_RATE) --title="Distribution of AR rates near $* transcripts" --xtitle="rate"
ka_%.png: PLOT_OPTIONS_R=--title="Distribution of AR rates near $* transcripts"

ka_%.png: evol.import
	$(PRELOG)
	@for d in $(DATA); do \
		$(KA_SELECT) > $@.tmp_data_$${d}; cat $@.tmp_data_$${d} | $(KA2HIST); cat $@.tmp_data_$${d} | $(KA2HISTC); cat $@.tmp_data_$${d} | $(KA2STATS); \
	done; \
	$(COMBINE_HISTS); $(COMBINE_TABLES2); $(COMBINE_PLOTS)
	@rm -f $@.tmp*
	$(EPILOG)


########################################################
########################################################
########################################################
## Distribution of intronic rates
########################################################
KI2HIST=d2h --min-data=10 --min-value=0 --bin-size=$(PARAM_PLOT_RATE_BIN) --headers=$${d} --normalize --min-data=$(PARAM_PLOT_MIN_VALUES) --log=$@.log > $@.tmp_hist_$${d}
KI2HISTC=d2h --min-data=10 --min-value=0 --bin-size=$(PARAM_PLOT_RATE_BIN) --headers=$${d} --normalize --min-data=$(PARAM_PLOT_MIN_VALUES) --cumulative --log=$@.log > $@.tmp_cumul_$${d}
KI2STATS=d2s --log=$@.log > $@.tmp_tab_$${d}
KI_SELECT=if [[ "$*" == "all" ]]; then where="1"; else where="is_$*"; fi; \
		s3 $(PARAM_DATABASE) "SELECT e.ki AS $${d} \
			 	FROM $${d}_annotation AS a, $${d}_evol AS e \
				WHERE a.gene_id = e.gene_id AND \
					e.ki IS NOT NULL AND e.ki > 0 AND \
					$${where}"

ki_%.png: PLOT_OPTIONS=--xrange=0,$(PARAM_PLOT_MAX_RATE) --title="Distribution of intronic rates near $* transcripts" --xtitle="rate"
ki_%.png: PLOT_OPTIONS_R=--yrange=0,$(PARAM_PLOT_MAX_RATE) --title="Distribution of intronic rates near $* transcripts" 

ki_%.png: evol.import
	$(PRELOG)
	@for d in $(DATA); do \
		$(KI_SELECT) > $@.tmp_data_$${d}; cat $@.tmp_data_$${d} | $(KI2HIST); cat $@.tmp_data_$${d} | $(KI2HISTC); cat $@.tmp_data_$${d} | $(KI2STATS); \
	done; \
	$(COMBINE_HISTS); $(COMBINE_TABLES2); $(COMBINE_PLOTS)
	@rm -f $@.tmp*
	$(EPILOG)

########################################################
########################################################
########################################################
## Distribution of ks/ka
## Filtering: 
##  minimum of 10 AR repeats
##  at least 100 aligned residues 
##  converged flag is set
##  
########################################################
KSKA2HIST=d2h --min-data=10 --min-value=0 --bin-size=$(PARAM_PLOT_KSKA_BIN) --headers=$${d} --normalize --min-data=$(PARAM_PLOT_MIN_VALUES) --log=$@.log > $@.tmp_hist_$${d}
KSKA2HISTC=d2h --min-data=10 --min-value=0 --bin-size=$(PARAM_PLOT_KSKA_BIN) --headers=$${d} --normalize --min-data=$(PARAM_PLOT_MIN_VALUES) --cumulative --log=$@.log > $@.tmp_cumul_$${d}
KSKA2STATS=d2s --log=$@.log > $@.tmp_tab_$${d}
KSKA_SELECT=if [[ "$*" == "all" ]]; then where="1"; else where="is_$*"; fi; \
		s3 $(PARAM_DATABASE) "SELECT e.kska AS $${d} \
			 	FROM $${d}_annotation AS a, $${d}_evol AS e \
				WHERE a.gene_id = e.gene_id AND \
					e.ks IS NOT NULL AND \
					e.ka IS NOT NULL AND \
					e.ks > 0 AND \
					e.ka > 0 AND \
					$${where}"

kska_%.png: PLOT_OPTIONS=--logscale=x --title="Distribution of kt/kar near $* transcripts" --xtitle="rate" --xrange=$(PARAM_PLOT_MIN_KSKA),$(PARAM_PLOT_MAX_KSKA)
kska_%.png: PLOT_OPTIONS_R=--title="Distribution of kt/kar near $* transcripts" --logscale=y

kska_%.png: evol.import
	$(PRELOG)
	@for d in $(DATA_RATES); do \
		$(CMD_LOG2) "processing $${d}"; \
		$(KSKA_SELECT) > $@.tmp_data_$${d}; cat $@.tmp_data_$${d} | $(KSKA2HIST); cat $@.tmp_data_$${d} | $(KSKA2HISTC); cat $@.tmp_data_$${d} | $(KSKA2STATS); \
	done; \
	$(COMBINE_HISTS); $(COMBINE_TABLES2); $(COMBINE_PLOTS)
	@rm -f $@.tmp*

	$(EPILOG)

########################################################
########################################################
########################################################
## Distribution of ks/ka
## Filtering: 
##  minimum of 10 AR repeats
##  at least 100 aligned residues 
 ##  converged flag is set
##  
########################################################
DISTANCES2HIST=d2h --min-data=10 --min-value=0 --bin-size=1000 --headers=$${d} --normalize --min-data=$(PARAM_PLOT_MIN_VALUES) --log=$@.log > $@.tmp_hist_$${d}
DISTANCES2HISTC=d2h --min-data=10 --min-value=0 --bin-size=1000 --headers=$${d} --normalize --min-data=$(PARAM_PLOT_MIN_VALUES) --cumulative --log=$@.log > $@.tmp_cumul_$${d}
DISTANCES2STATS=d2s --log=$@.log > $@.tmp_tab_$${d}
DISTANCES_SELECT=if [[ "$*" == "all" ]]; then where="1"; else where="is_$*"; fi; \
		s3 $(PARAM_DATABASE) "SELECT d.closest_dist AS $${d} \
			 	FROM $${d}_annotation AS a, $${d}_distances AS d \
				WHERE a.gene_id = d.gene_id AND \
					d.closest_dist > 0 AND \
					$${where}"

distances_%.png: PLOT_OPTIONS=--logscale=x --title="Distribution of distances to closest gene for $* transcripts" --xtitle="distance / bases" 
distances_%.png: PLOT_OPTIONS_R=--title="Distribution of distances to closest gene for $* transcripts" --logscale=y

distances_%.png: evol.import
	$(PRELOG)
	@for d in $(DATA_RATES); do \
		$(CMD_LOG2) "processing $${d}"; \
		$(DISTANCES_SELECT) > $@.tmp_data_$${d}; cat $@.tmp_data_$${d} | $(DISTANCES2HIST); cat $@.tmp_data_$${d} | $(DISTANCES2HISTC); cat $@.tmp_data_$${d} | $(DISTANCES2STATS); \
	done; \
	$(COMBINE_HISTS); $(COMBINE_TABLES2); $(COMBINE_PLOTS)
	@rm -f $@.tmp*
	$(EPILOG)

########################################################
########################################################
########################################################
## Distribution of ks/ki
## Filtering: 
##  minimum of 10 AR repeats
##  at least 100 aligned residues 
##  converged flag is set
##  
########################################################
KSKI2HIST=d2h --min-data=10 --min-value=0 --bin-size=$(PARAM_PLOT_KSKA_BIN) --headers=$${d} --min-data=$(PARAM_PLOT_MIN_VALUES) --normalize --log=$@.log > $@.tmp_hist_$${d}
KSKI2HISTC=d2h --min-data=10 --min-value=0 --bin-size=$(PARAM_PLOT_KSKA_BIN) --headers=$${d} --min-data=$(PARAM_PLOT_MIN_VALUES) --normalize --cumulative --log=$@.log > $@.tmp_cumul_$${d}
KSKI2STATS=d2s --log=$@.log > $@.tmp_tab_$${d}

KSKI_SELECT=if [[ "$*" == "all" ]]; then where="1"; else where="is_$*"; fi; \
		s3 $(PARAM_DATABASE) "SELECT e.kski AS $${d} \
			 	FROM $${d}_annotation AS a, $${d}_evol AS e \
				WHERE a.gene_id = e.gene_id AND \
					e.ks IS NOT NULL AND \
					e.ks > 0 AND \
					e.ki IS NOT NULL AND \
					e.ki > 0 AND \
					$${where}"

kski_%.png: PLOT_OPTIONS=--logscale=x --title="Distribution of ks/ki near $* transcripts" --xtitle="rate" --xrange=$(PARAM_PLOT_MIN_KSKA),$(PARAM_PLOT_MAX_KSKA)
kski_%.png: PLOT_OPTIONS_R=--title="Distribution of ks/ki near $* transcripts" --logscale=y

kski_%.png: evol.import
	$(PRELOG)
	@for d in $(DATA_RATES); do \
		$(CMD_LOG2) "processing $${d}"; \
		$(KSKI_SELECT) > $@.tmp_data_$${d}; cat $@.tmp_data_$${d} | $(KSKI2HIST); cat $@.tmp_data_$${d} | $(KSKI2HISTC); cat $@.tmp_data_$${d} | $(KSKI2STATS); \
	done; \
	$(COMBINE_HISTS); $(COMBINE_TABLES2); $(COMBINE_PLOTS)
	@rm -f $@.tmp*
	$(EPILOG)

########################################################
########################################################
########################################################
## Distribution of aligned number of residues
########################################################
ALIGNED2HIST=d2h --min-data=10 --min-value=0 --bin-size=10 --headers=$${d} --min-data=$(PARAM_PLOT_MIN_VALUES) --normalize --log=$@.log > $@.tmp_hist_$${d}
ALIGNED2HISTC=d2h --min-data=10 --min-value=0 --bin-size=10 --headers=$${d} --min-data=$(PARAM_PLOT_MIN_VALUES) --normalize --cumulative --log=$@.log > $@.tmp_cumul_$${d}
ALIGNED_SELECT=if [[ "$*" == "all" ]]; then where="1"; else where="is_$*"; fi; \
		s3 $(PARAM_DATABASE) "SELECT 100.0 * e.aligned / e.length AS $${d} \
			 	FROM $${d}_annotation AS a, $${d}_evol AS e \
				WHERE a.gene_id = e.gene_id AND e.aligned > 0 AND $${where}"

aligned_%.png: PLOT_OPTIONS=--logscale=x --title="Distribution of alignment coverage in $* transcripts" --xtitle="rate" --legend-location="center"
aligned_%.png: PLOT_OPTIONS_R=--title="Distribution of alignment coverage in $* transcripts" --logscale=y

aligned_%.png: evol.import
	$(PRELOG)
	@for d in $(DATA); do $(ALIGNED_SELECT) > $@.tmp_data_$${d}; cat $@.tmp_data_$${d} | $(ALIGNED2HIST); cat $@.tmp_data_$${d} | $(ALIGNED2HISTC); done; \
	$(COMBINE_HISTS); $(COMBINE_PLOTS)
	$(EPILOG)

########################################################
########################################################
########################################################
## single versus multiple exon transcripts in unknown
## transcripts
########################################################
SINGLEMUL2HIST=d2h --min-data=10 --min-value=0 --bin-size=$(PARAM_PLOT_RATE_BIN) --min-data=$(PARAM_PLOT_MIN_VALUES) --normalize --log=$@.log 
SINGLEMUL2HISTC=d2h --min-data=10 --min-value=0 --bin-size=$(PARAM_PLOT_RATE_BIN) --min-data=$(PARAM_PLOT_MIN_VALUES) --normalize --cumulative --log=$@.log 
SINGLEMUL_SELECT1=s3 $(PARAM_DATABASE) "SELECT r.distance AS $${d}_single FROM $${d}_annotation AS d, $${d}_rates AS r WHERE d.gene_id = r.gene_id AND d.is_unknown AND d.exons_nval = 1"
SINGLEMUL_SELECT2=s3 $(PARAM_DATABASE) "SELECT r.distance AS $${d}_multi FROM $${d}_annotation AS d, $${d}_rates AS r WHERE d.gene_id = r.gene_id AND d.is_unknown AND d.exons_nval > 1"

single_vs_multiple.png: PLOT_OPTIONS=--xrange=0,$(PARAM_PLOT_MAX_RATE) --title="Distribution of ks in single versus multi-exon unknown transcripts in $${d}" --xtitle="rate"
single_vs_multiple.png:
	$(PRELOG)
	@for d in $(DATA); do \
		$(SINGLEMUL_SELECT1) | $(SINGLEMUL2HIST) > $@.tmp_hist_$${d}_1; \
		$(SINGLEMUL_SELECT2) | $(SINGLEMUL2HIST) > $@.tmp_hist_$${d}_2; \
		$(SINGLEMUL_SELECT1) | $(SINGLEMUL2HISTC) > $@.tmp_cumul_$${d}_1; \
		$(SINGLEMUL_SELECT2) | $(SINGLEMUL2HISTC) > $@.tmp_cumul_$${d}_2; \
		ct --sort-keys=numeric $@.tmp_hist_$${d}_* | h2p $(PLOT_OPTIONS) $(PARAM_PLOT_OPTIONS) --legend-location="center right" --log=$@.log --hardcopy=$@_$${d}.png; \
		ct --sort-keys=numeric $@.tmp_cumul_$${d}_* | h2p $(PLOT_OPTIONS) $(PARAM_PLOT_OPTIONS) --legend-location="center right" --log=$@.log --hardcopy=cumul_$@_$${d}.png; \
	done; \
	$(COMBINE_HISTS)
	@rm -f $@.tmp*
	$(EPILOG)

########################################################
########################################################
diff_coverage.png:
	$(PRELOG)
	@for a in $(DATA); do \
		ls $${a}_vs*.diff >& /dev/null; \
		if [ $$? == 1 ]; then continue; fi; \
		for b in $(DATA); do \
			s3 $(PARAM_DATABASE) "select pover1 from $${a}_vs_$${b}" |\
			d2h --min-value=0 --bin-size=1 --headers=$${b} --cumulative --log=$@.log --normalize > $@.tmp_hist_$${a}_$${b}; \
		done; \
		python $(DIR_SCRIPTS_TOOLS)combine_tables.py $@.tmp_hist_$${a}* |\
			python $(DIR_SCRIPTS_TOOLS)plot_histogram.py --title="Coverage of transcripts in $${a}" --log=$@.log --legend-location="center left" --hardcopy=$@_$${a}.png; \
		rm -f $@.tmp_hist_$${a}*; \
	done
	$(EPILOG)


########################################################
########################################################
########################################################
## Overlap with repeats
########################################################
REPEATS_TABLE_FROM=FROM $${d}_repeats AS r, $${d}_annotation AS a WHERE a.gene_id = r.gene_id AND $${where}

repeats.table:
	$(PRELOG)
	@printf "set" > $@; \
	for s in $(PARAM_CATEGORIES); do printf "\t%s_total\t%s_nrepeats\t%s_prepeats\t%s_avgovl" $${s} $${s} $${s} $${s} >> $@; done; \
	printf "\n" >> $@
	@for d in $(DATA); do \
		printf "%s" $${d} >> $@; \
		for section in $(PARAM_CATEGORIES); do \
			if [[ "$${section}" == "all" ]]; then where="1"; else where="is_$${section}"; fi; \
			printf "\t%i\t%i\t%f\t%f" \
			`s3v $(PARAM_DATABASE) "SELECT count(*), count(NULLIF( nover, 0)), 100.0 * count(NULLIF( nover, 0)) / cast( count(*) as float) $(REPEATS_TABLE_FROM)"` \
			`s3v $(PARAM_DATABASE) "SELECT avg(pover1) $(REPEATS_TABLE_FROM) AND nover > 0"` \
			>> $@; \
		done; \
		printf "\n" >> $@; \
	done
	$(EPILOG)

########################################################
########################################################
########################################################
## plot repeats in various subsets
########################################################
repeats_%.png: repeats.table
	$(PRELOG)
	@csv_cut set %^$*_prepeats% %^$*_avgovl% < $< |\
	pe "s/$*_prepeats/with repeat/g; s/$*_avgovl/avgerage coverage/g" |\
	t2t --transpose |\
	t2r --plot=bar-besides --columns=all-but-first --hardcopy=$@ --legend=1 --labels="set,percent" --options="cex.names=1.0" --log=$@.log 
	$(EPILOG)

########################################################
########################################################
########################################################
## polyA tails
########################################################
POLYA_TABLE_FROM=FROM $${d}_polyA AS r, $${d}_annotation AS a WHERE a.gene_id = r.gene_id AND $${where}

polyA.table:
	$(PRELOG)
	@printf "set" > $@; \
	for s in $(PARAM_CATEGORIES); do printf "\t%s_total\t%s_polyA\t%s_nmotif" $${s} $${s} $${s} >> $@; done; \
	printf "\n" >> $@
	@for d in $(INPUT_POLYA:%.polyA=%); do \
		printf "%s" $${d} >> $@; \
		for section in $(PARAM_CATEGORIES); do \
			if [[ "$${section}" == "all" ]]; then where="1"; else where="is_$${section}"; fi; \
			printf "\t%i\t%i\t%i" \
			`s3v $(PARAM_DATABASE) "SELECT count(*) $(POLYA_TABLE_FROM) "` \
			`s3v $(PARAM_DATABASE) "SELECT count(*) $(POLYA_TABLE_FROM) AND tails > 0"` \
			`s3v $(PARAM_DATABASE) "SELECT count(*) $(POLYA_TABLE_FROM) AND nmotifs > 0 AND tails > 0"` \
			>> $@; \
		done; \
		printf "\n" >> $@; \
	done
	$(EPILOG)

########################################################
########################################################
########################################################
## plot polyA tails in various subsets
########################################################
polyA_%.png: polyA.table
	$(PRELOG)
	@csv_cut set %^$*_% < $< |\
	t2t --transpose |\
	t2r --plot=bar-besides --columns=all-but-first --hardcopy=$@ --legend=1 --labels="set,absolute frequency" --options="cex.names=1.0" --log=$@.log 
	@csv_cut set %^$*_% < $< |\
	pe "s/$*_polyA/transcripts with poly tail/g; s/$*_nmotif/polyA tails with polyA motif/g" |\
	t2t --transpose |\
	t2t -m normalize-by-max --columns=all-but-first --format="%6.4f" | grep -v "total" |\
	t2r --plot=bar-besides --columns=all-but-first --hardcopy=relative_$@ --legend=1 --labels="set,relative frequency" --options="cex.names=1.0" --log=$@.log 
	$(EPILOG)

########################################################
########################################################
########################################################
## correlation of rates
## not all transcripts have introns or are associated with
## ancestral repeats, so be aware of biases
########################################################
rates_correlation.table: evol.import
	$(PRELOG)
	@for class in $(PARAM_CATEGORIES); do \
		if [[ "$${class}" == "all" ]]; then where="1"; else where="is_$${class}"; fi; \
		for d in $(DATA); do \
			s3 $(PARAM_DATABASE) "SELECT e.* \
				FROM $${d}_annotation AS a, \
				     $${d}_evol AS e \
				WHERE \
				e.gene_id = a.gene_id AND $${where}" |\
			csv_cut -r gene_id |\
			tawk '{if (!a) {a=NF}; for (x=1;x<=NF;++x) { if ($$x == "") {$$x="na";} } print;}' > $@.tmp; \
			if test -s $@.tmp; then \
				t2r --allow-empty --log=$@ --plot=pairs --stats=pearson --hardcopy=$@.$${d}.$${class}.pairs.png --title="Correlations in $${d}" < $@.tmp > $@.$${d}.$${class}.table; \
				python $(DIR_SCRIPTS_TOOLS)sparse2full.py < $@.$${d}.$${class}.table |\
				m2m --missing=0 --method=correspondence-analysis |\
				m2p --zrange=-1,1 --hardcopy=$@.$${d}.$${class}.correl.png --title="Correlation coefficients for $${d}" --log=$@; \
			fi; \
			rm -f $@.tmp; \
		done; \
	done

########################################################
########################################################
########################################################
## table with transcripts in the various classes
########################################################
classes.table:
	$(PRELOG)
	@s3 $(PARAM_DATABASE) "SELECT 'set' as data, count(*) as total, \
		sum(is_known) as known, sum(is_unknown) as unknown, sum(is_ambiguous) as ambiguous, \
		sum(is_pc) as pc, sum(is_pseudo) as pseudo, sum(is_npc) as npc, sum(is_utr) as utr, \
		sum(is_intronic) as intronic, sum(is_assoc) as assoc, sum(is_intergenic) as intergenic, \
		count(*) - (sum(is_known)+sum(is_unknown)+sum(is_ambiguous)) as unclassified, \
		sum(is_known) - (sum(is_pc)+sum(is_pseudo)+sum(is_npc)+sum(is_utr)) AS unclassified_known, \
		sum(is_unknown) - (sum(is_intronic)+sum(is_intergenic)+sum(is_assoc)) AS unclassified_unknown \
		FROM $(firstword $(DATA))_annotation" \
	< /dev/null | head -n 1 > $@
	@for d in $(DATA); do \
		s3 -noheader $(PARAM_DATABASE) \
		"SELECT '$${d}', count(*), \
			sum(is_known), sum(is_unknown), sum(is_ambiguous), \
			sum( is_pc), sum( is_pseudo), sum( is_npc), sum(is_utr), \
			sum(is_intronic), sum(is_assoc), sum(is_intergenic), \
			count(*) - (sum(is_known)+sum(is_unknown)+sum(is_ambiguous)) as unclassified, \
			sum(is_known) - (sum(is_pc)+sum(is_pseudo)+sum(is_npc)+sum(is_utr)) AS unclassified_known, \
			sum(is_unknown) - (sum(is_intronic)+sum(is_intergenic)+sum(is_assoc)) AS unclassified_unknown \
			FROM $${d}_annotation" < /dev/null >> $@; \
	done
	$(EPILOG)

classes_all.png: FIELDS=known ambiguous unknown unclassified
classes_known.png: FIELDS=pc pseudo npc utr unclassified_known
classes_unknown.png: FIELDS=intronic assoc intergenic unclassified_unknown

classes_%.png: classes.table
	$(PRELOG)
	@csv_cut data $(FIELDS) < $< |\
	pe "s/_\S+//" |\
	t2t --transpose |\
	t2r --allow-empty --plot=bar --hardcopy=$@ --legend=1 --labels="set,size" --options="cex.names=1.0" --log=$@.log 
	@csv_cut data $(FIELDS) < $< |\
	pe "s/_\S+//" |\
	t2t --transpose |\
	m2m --method=normalize-by-column-total |\
	t2r --allow-empty --plot=bar --hardcopy=relative_$@ --legend=1 --labels="set,size" --options="cex.names=1.0" --log=$@.log 
	$(EPILOG)

########################################################
########################################################
########################################################
## compute chi-square difference in proportion of
## unknowns
########################################################
classes_unknown.tests:
	$(PRELOG)
	@rm -f $@.tmp
	@for d1 in $(DATA_SAMPLES); do \
		for d2 in $(DATA_SAMPLES); do \
			if [[ "$${d1}" < "$${d2}" ]]; then \
				printf ">$${d1}-$${d2}\n" >> $@.tmp; \
				printf "matrix\tunknown\tknown\n" >> $@.tmp; \
				printf "%s\t%i\t%i\n" $${d1} \
				`s3v $(PARAM_DATABASE) "SELECT COUNT(NULLIF(is_unknown,1)), COUNT(NULLIF(is_unknown,0)) FROM $${d1}_annotation"` >> $@.tmp; \
				printf "%s\t%i\t%i\n" $${d2} \
				`s3v $(PARAM_DATABASE) "SELECT COUNT(NULLIF(is_unknown,1)), COUNT(NULLIF(is_unknown,0)) FROM $${d2}_annotation"`>> $@.tmp ; \
			fi; \
		done; \
	done
	@python $(DIR_SCRIPTS_TOOLS)matrix2stats.py --method=chi-squared < $@.tmp > $@
	@rm -f $@.tmp
	$(EPILOG)

########################################################
########################################################
########################################################
## table with information about ambiguous transcripts
########################################################
ambiguous.table:
	$(PRELOG)
	@printf "set\tambiguous\tintronic\tintergenic\tflank\tflank+intergenic\n" >> $@
	@for d in $(DATA); do \
		printf "%s\t%i" $${d} `s3v $(PARAM_DATABASE) "SELECT COUNT(*) FROM $${d}_annotation WHERE is_ambiguous" < /dev/null` >> $@; \
		for column in pover1_intronic pover1_intergenic; do \
			printf "\t%i" `s3v $(PARAM_DATABASE) "SELECT COUNT(*) FROM $${d}_annotation WHERE is_ambiguous AND $${column} > 0.5" < /dev/null` >> $@; \
		done; \
		printf "\t%i" `s3v $(PARAM_DATABASE) "SELECT COUNT(*) FROM $${d}_annotation WHERE is_ambiguous AND (pover1_flank + pover1_3flank + pover1_5flank) > 0.5" < /dev/null` >> $@; \
		printf "\t%i" `s3v $(PARAM_DATABASE) "SELECT COUNT(*) FROM $${d}_annotation WHERE is_ambiguous AND (pover1_intergenic + pover1_flank + pover1_3flank + pover1_5flank) > 0.5" < /dev/null` >> $@; \
		printf "\n" >> $@; \
	done
	$(EPILOG)


########################################################
########################################################
########################################################
## table with information about splice motif conservation
########################################################
splice_filtered.table: CMD_SELECT=FROM $${d}_annotation AS a, $${d}_coverage AS c WHERE exons_nval > 1 AND $${where} AND a.gene_id = c.gene_id AND c.mean>=$(PARAM_MIN_COVERAGE) AND c.nmatches >=$(PARAM_MIN_READS)
splice_filtered.table: CMD_DATA=$(DATA_COVERAGES)
splice_filtered.table:SPLICE_HEADER1=ngenes nmotifs nintrons nsplice nfound nperfect npartial
splice_all.table: CMD_SELECT=FROM $${d}_annotation AS a WHERE exons_nval > 1 AND $${where}
splice_all.table: CMD_DATA=$(DATA)
splice_all.table:SPLICE_HEADER1=ngenes nmotifs nintrons nsplice nfound nperfect npartial

SPLICE_HEADER=$(SPLICE_HEADER1:%=%_all) $(SPLICE_HEADER1:%=%_known) $(SPLICE_HEADER1:%=%_pc) $(SPLICE_HEADER1:%=%_unknown) $(SPLICE_HEADER1:%=%_ambiguous)
splice_%.table:
	$(PRELOG)
	@printf "set\t" > $@
	@echo "$(SPLICE_HEADER)" | pe "s/ +/\t/g" >> $@
	@for d in $(CMD_DATA); do \
		printf "%s" $${d} >> $@; \
		for section in $(PARAM_CATEGORIES); do \
			if [[ "$${section}" == "all" ]]; then where="1"; else where="is_$${section}"; fi; \
			printf "\t%i\t%i\t%i\t%i\t%i\t%i\t%i" `s3v $(PARAM_DATABASE) "select count(*) $(CMD_SELECT)"` \
				`s3v $(PARAM_DATABASE) "select sum(U12_AT_AC+U2_GT_AG+U2_nc_GC_AG) $(CMD_SELECT)"` \
				`s3v $(PARAM_DATABASE) "select sum(introns_nval) $(CMD_SELECT)"` \
				`s3v $(PARAM_DATABASE) "select sum(splice_total), sum(splice_found), sum(splice_perfect), sum(splice_partial) $(CMD_SELECT)"` \
				>> $@; \
		done; \
		printf "\n" >> $@; \
	done
	$(EPILOG)

########################################################
########################################################
########################################################
## table with proportions of splice motifs
########################################################
splice_motifs.table: SPLICE_HEADER1=ntotal nU2_GT_AG nU12_AT_AT nU2_nc_GC_AG

splice_motifs.table:
	$(PRELOG)
	@printf "set\t" > $@
	@echo "$(SPLICE_HEADER)" | pe "s/ +/\t/g" >> $@
	@for d in $(DATA); do \
		printf "%s" $${d} >> $@; \
		for section in $(PARAM_CATEGORIES); do \
			if [[ "$${section}" == "all" ]]; then where="1"; else where="is_$${section}"; fi; \
			printf "\t%i\t%i\t%i\t%i" \
				`s3v $(PARAM_DATABASE) "SELECT sum(introns_nval), SUM(U2_GT_AG), SUM(U12_AT_AC), SUM(U2_nc_GC_AG) \
					FROM $${d}_annotation AS a WHERE exons_nval > 1 AND $${where}"` \
				>> $@; \
		done; \
		printf "\n" >> $@; \
	done
	$(EPILOG)

########################################################
########################################################
########################################################
## check table contents
########################################################
sizes.table:
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)check_db.py \
		--database=$(PARAM_DATABASE) \
		--backend=sqlite \
		--method=column-in-tables \
		--column=gene_id \
		--output-filename-pattern=$@.%s.table \
		--regex-head="^([^_]+)_(?!vs)" \
		--regex-tail="_(.+)$$" \
		--exclude="_vs_" \
	> $@
	@for x in counts percents; do \
		m2m --method=correspondence-analysis --log=$@ \
		< $@.$${x}.table |\
		python $(DIR_SCRIPTS_TOOLS)plot_matrix.py \
			--palette=Reds  \
			--reverse-palette \
			--hardcopy=$@.$${x}.png \
		>> $@; \
	done
	$(EPILOG)

########################################################
########################################################
########################################################
## compute distance between transcripts/genes
########################################################
%.segments: %.gtf
	$(PRELOG)
	@s3 $(PARAM_DATABASE) "SELECT * FROM $*_gtf ORDER BY contig, start" |\
	$(CMD_REMOTE_SUBMIT) "\
	python $(DIR_SCRIPTS_GENEPREDICTION)gtf2tsv.py --invert |\
	python $(DIR_SCRIPTS_GENEPREDICTION)gff2histogram.py \
		--method=values \
		--output-filename-pattern="$@.%s" \
		--force \
		--log=$@.log \
	> $@"
	@s3 $(PARAM_DATABASE) "SELECT * FROM $*_gtf ORDER BY gene_id, start" |\
	$(CMD_REMOTE_SUBMIT) "\
	python $(DIR_SCRIPTS_GENEPREDICTION)gtf2tsv.py --invert |\
	python $(DIR_SCRIPTS_GENEPREDICTION)gtf2gtf.py --merge-transcripts |\
	$(DIR_SCRIPTS_GENEPREDICTION)gff_sort pos |\
	python $(DIR_SCRIPTS_GENEPREDICTION)gff2histogram.py \
		--method=values \
		--force \
		--output-filename-pattern="$@_genes.%s" \
		--log=$@.log \
	> $@"
	$(EPILOG)

########################################################
########################################################
########################################################
## compute distance between transcripts/genes
########################################################
%_segments.import: %.segments
	$(PRELOG)
	@csv2db.py --allow-empty -b sqlite --table=$*_segments_distances < $<.distances > $@
	@csv2db.py --allow-empty -b sqlite --table=$*_segments_sizes < $<.sizes > $@
	@csv2db.py --allow-empty -b sqlite --table=$*_segments_overlaps < $<.overlaps > $@
	@csv2db.py --allow-empty -b sqlite --table=$*_segments_genes_distances < $<_genes.distances > $@
	@csv2db.py --allow-empty -b sqlite --table=$*_segments_genes_sizes < $<_genes.sizes > $@
	@csv2db.py --allow-empty -b sqlite --table=$*_segments_genes_overlaps < $<_genes.overlaps > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## merge transcripts and build a new gtf file
## 'novel' and 'ambiguous' transcripts are merged
## together, while 'known' transcripts are merged separately.
########################################################
%.merged_gtf: %.gtf %.coverage
	$(PRELOG)
	@s3 $(PARAM_DATABASE) "SELECT g.* FROM $*_gtf AS g, $*_annotation AS a \
		WHERE a.gene_id = g.gene_id AND NOT a.is_known" |\
	$(CMD_REMOTE_SUBMIT) "\
	python $(DIR_SCRIPTS_GENEPREDICTION)gtf2tsv.py --invert --log=$@.log |\
	python $(DIR_SCRIPTS_GENEPREDICTION)gff2blat.py --log=$@.log --is-gtf --allow-duplicates --no-header |\
	sort -k 14,14 -k 16,16n" > $@.tmp
	@cat $@.tmp |\
	$(CMD_FARM) \
		--split-at-column=14 \
		--output-header \
		$(CLUSTER_OPTIONS) \
		--renumber="U%06i" \
		--renumber-column=":id" \
		--max-files=60 \
		--log=$@.log \
		--subdirs \
	"python $(DIR_SCRIPTS_GENEPREDICTION)blat2assembly.py \
		--method=locus \
		--method=coverage \
		--threshold-merge-distance=10 \
		--threshold-merge-overlap=0 \
		--staggered=all \
		--log=$@.log \
		--genome=genome \
		--input-filename-coverage=$*.coverage \
		--output-filename-pattern=%DIR%$@.unknown.%s" \
	> $@.unknown.new2locus
	@s3 $(PARAM_DATABASE) "SELECT g.* FROM $*_gtf AS g, $*_annotation AS a \
		WHERE a.gene_id = g.gene_id AND a.is_known" |\
	$(CMD_REMOTE_SUBMIT) "\
	python $(DIR_SCRIPTS_GENEPREDICTION)gtf2tsv.py --invert --log=$@.log |\
	python $(DIR_SCRIPTS_GENEPREDICTION)gff2blat.py --log=$@.log --is-gtf --allow-duplicates --no-header |\
	sort -k 14,14 -k 16,16n" > $@.tmp
	@cat $@.tmp |\
	$(CMD_FARM) \
		--split-at-column=14 \
		--output-header \
		$(CLUSTER_OPTIONS) \
		--max-files=60 \
		--renumber="K%06i" \
		--renumber-column=":id" \
		--log=$@.log \
		--subdirs \
	"python $(DIR_SCRIPTS_GENEPREDICTION)blat2assembly.py \
		--method=locus \
		--method=coverage \
		--threshold-merge-distance=10 \
		--threshold-merge-overlap=0 \
		--staggered=all \
		--log=$@.log \
		--genome=genome \
		--input-filename-coverage=$*.coverage \
		--output-filename-pattern=%DIR%$@.known.%s" \
	> $@.known.new2locus
	@pslCat $@.unknown.locus.psl $@.known.locus.psl |\
	python $(DIR_SCRIPTS_GENEPREDICTION)blat2gff.py \
		--log=$@.log \
		--as-gtf> $@
	@cat $@.unknown.coverage $@.known.coverage > $@.coverage
	@rm -f $@.tmp
	$(EPILOG)

########################################################
########################################################
########################################################
## compute ancestral repeat rates for ARs in the vicinity
## of each transcript
########################################################
%.repeats_rates.gz: %.gtf
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) \
	python $(DIR_SCRIPTS_GENEPREDICTION)gtf2table.py \
		--proximal-distance=$(PARAM_PROXIMAL_DISTANCE) \
		--section=exons \
		--counter=proximity-exclusive \
		--filename-gff=$(PARAM_FILE_REPEATS_RATES) \
	< $< | gzip > $@
	$(EPILOG)

%_repeats_rates.import: %.repeats_rates.gz
	$(PRELOG)
	@gunzip < $< |\
	awk '$$4 > 0' |\
	csv_cut --remove exons_lengths exons_values |\
	csv2db.py --map gene_id:str -b sqlite $(OPTION_INDEX) --table=$*_repeats_rates > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## compute ancestral repeat rates for ARs in the vicinity
## of each transcript
########################################################
%.lenrepeats_rates.gz: %.gtf
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) \
	python $(DIR_SCRIPTS_GENEPREDICTION)gtf2table.py \
		--proximal-distance=$(PARAM_PROXIMAL_DISTANCE) \
		--section=exons \
		--counter=proximity-lengthmatched \
		--filename-gff=$(PARAM_FILE_REPEATS_RATES) \
	< $< | gzip > $@
	$(EPILOG)

%_lenrepeats_rates.import: %.lenrepeats_rates.gz
	$(PRELOG)
	@gunzip < $< |\
	awk '$$4 > 0' |\
	csv_cut --remove exons_lengths exons_values |\
	csv2db.py --map gene_id:str -b sqlite $(OPTION_INDEX) --table=$*_lenrepeats_rates > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## compute ancestral repeat gc content for ARs in the vicinity 
## of each transcript
########################################################
%.repeats_gc.gz: %.gtf
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) \
	python $(DIR_SCRIPTS_GENEPREDICTION)gtf2table.py \
		--proximal-distance=$(PARAM_PROXIMAL_DISTANCE) \
		--section=exons \
		--counter=proximity-exclusive \
		--filename-gff=$(PARAM_FILE_REPEATS_GC) \
	< $< | gzip > $@
	$(EPILOG)

%_repeats_gc.import: %.repeats_gc.gz
	$(PRELOG)
	@gunzip < $< |\
	awk '$$4 > 0' |\
	csv_cut --large --remove exons_lengths exons_values |\
	csv2db.py --map gene_id:str -b sqlite $(OPTION_INDEX) --table=$*_repeats_gc > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## compute the difference between two sets
##
## This target computes three differences
## 1. exon overlap %.diff.{diff,overlap,total,genes_ovl,genes_total,genes_uniq1,genes_uniq2}
##    An intronic transcript will no overlap with an exonic transrcipt.
## 2. overlap statistics on each gene in set 1: %.diff
## 3. intron/exon overlap %_genes.diff.{diff,overlap,total,genes_ovl,genes_total,genes_uniq1,genes_uniq2}
##    An intronic transcript will overlap with an exonic transcript.
########################################################
%.diff: $(PARAM_SET_MERGED).gtf
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) python $(DIR_SCRIPTS_GENEPREDICTION)diff_gtf.py \
		--log=$@.log \
		-p --write-equivalent --ignore-strand --output-pattern="$@.%s" \
		`echo $* | pe "s/_vs_.*//"`.gtf \
		`echo $* | pe "s/.*_vs_//"`.gtf \
	< /dev/null > $@.log
	@$(CMD_REMOTE_SUBMIT) "python $(DIR_SCRIPTS_GENEPREDICTION)diff_gtf.py \
		--log=$@.log \
		-p --write-equivalent --ignore-strand --output-pattern="$@_genes.%s" \
		<( python $(DIR_SCRIPTS_GENEPREDICTION)gtf2gtf.py --merge-transcripts --log=$@.log < `echo $* | pe "s/_vs_.*//"`.gtf) \
		<( python $(DIR_SCRIPTS_GENEPREDICTION)gtf2gtf.py --merge-transcripts --log=$@.log < `echo $* | pe "s/.*_vs_//"`.gtf) " \
	< /dev/null > $@.log
	@$(CMD_REMOTE_SUBMIT) python $(DIR_SCRIPTS_GENEPREDICTION)gtf2table.py \
		--log=$@.log \
		--counter=length \
		--counter=overlap-transcripts \
		--counter=coverage \
		--filename-gff=`echo $* | pe "s/.*_vs_//"`.gtf \
		< `echo $* | pe "s/_vs_.*//"`.gtf > $@
	$(EPILOG)

%_diff.import: %.diff
	$(PRELOG)
	@grep -v "\bna\b" < $< |\
	csv_cut --large --remove cov_values |\
	csv2db.py --allow-empty --map gene_id:str -b sqlite $(OPTION_INDEX) --table=$* > $@
	@if test -e $<.genes_ovl; then \
		csv2db.py --map=gene_id1:str --map=gene_id2:str -b sqlite --index=gene_id1 --index=gene_id2 --table=$*_ovl < $<.genes_ovl >> $@; \
	fi
	@if test -e $<_genes.genes_ovl; then \
		csv2db.py --map=gene_id1:str --map=gene_id2:str -b sqlite --index=gene_id1 --index=gene_id2 --table=$*_geneovl < $<_genes.genes_ovl >> $@; \
	fi
	$(EPILOG)

########################################################
########################################################
########################################################
## compute read coverage
##
## This target computes the read coverage of a set with
## reads. This permits more accurate counting.
########################################################
%.readcoverage: $(PARAM_SET_MERGED).gtf
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) python $(DIR_SCRIPTS_GENEPREDICTION)gtf2table.py \
		--log=$@.log \
		--counter=length \
		--counter=overlap-transcripts \
		--counter=coverage \
		--filename-gff=`echo $* | pe "s/.*_vs_//"`.readgtf \
		< `echo $* | pe "s/_vs_.*//"`.gtf > $@
	$(EPILOG)

%_readcoverage.import: %.readcoverage
	$(PRELOG)
	@grep -v "\bna\b" < $< |\
	csv_cut --large --remove cov_values |\
	csv2db.py --map gene_id:str -b sqlite $(OPTION_INDEX) --table=$*_readcoverage > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## compute the overlap between all sets
########################################################
## Note: using $(CMD_REMOTE_SUBMIT) gives "s3: command not found"
## I am thus uncommenting it:
overlaps_%.table: CMD_REMOTE_SUBMIT=eval 
overlaps_%.table: $(wildcard *.gtf) $(ANNOTATIONS:%.annotation=%_annotation.import) 
	$(PRELOG)
	@if [[ "$*" == "all" ]]; then where="1"; else where="is_$*"; fi; \
	if test -e $@; then mv -f $@ $@.old; extra_options="--update=$@.old"; fi; \
	$(CMD_REMOTE_SUBMIT) \
	"for d in $(DATA) $(PARAM_SET_MERGED); do \
		python $(DIR_SCRIPTS_GENEPREDICTION)gtf2gtf.py \
			--apply=<( s3 $(PARAM_DATABASE) \"SELECT gene_id FROM \$${d}_annotation WHERE \$${where}\" )\
			--log=$@.log \
			--filter=gene \
		< \$${d}.gtf > $@_tmp_\$${d}.xgtf ; \
	done; \
	python $(DIR_SCRIPTS_GENEPREDICTION)gtfs2tsv.py \
		$${extra_options} \
		--pattern-id='$@_tmp_(.*).xgtf' \
		--log=$@.log $@_tmp_*.xgtf > $@"
	@rm -f $@_tmp*
	$(EPILOG)

overlaps_%_table.import: overlaps_%.table
	$(PROG)
	@grep -v "\bna\b" < $< | csv2db.py --map set1:str --map set2:str --index=set1 --index=set2 -b sqlite $(OPTION_INDEX) --table=overlaps_$* > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## import coverage data
########################################################
%_coverage.import: %.coverage
	$(PRELOG)
	@grep -v "\bna\b" < $< | pe "s/^id/gene_id/" | csv2db.py --map gene_id:str -b sqlite $(OPTION_INDEX) --table=$*_coverage > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## import polyA tail data
########################################################
%_polyA.import: %.polyA
	$(PRELOG)
	@grep -v "\bna\b" < $< | pe "s/^id/gene_id/" | csv2db.py --map gene_id:str -b sqlite $(OPTION_INDEX) --table=$*_polyA > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## import readstats data
########################################################
%_readstats.import: %.readstats
	$(PRELOG)
	@grep -v "\bna\b" < $< | pe "s/^qName/read_id/" | csv2db.py --map gene_id:str -b sqlite --index=read_id --table=$*_readstats > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## import read info data
########################################################
%_readinfo.import: %.readinfo
	$(PRELOG)
	@grep -v "\bna\b" < $< | pe "s/^id/read_id/" | csv2db.py --map gene_id:str -b sqlite --index=read_id --table=$*_readinfo > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## import readmap data linking reads to transcripts
########################################################
%_readmap.import: %.readmap
	$(PRELOG)
	@grep -v "\bna\b" < $< | pe "s/^id/gene_id/; s/read/read_id/" | csv2db.py --map gene_id:str -b sqlite $(OPTION_INDEX) --index=read_id --table=$*_readmap > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## build aggregate table for each transcript combining
## all the evolutionary rates
########################################################
evol.import: 
	$(PRELOG)
	@for d in $(DATA); do \
		$(CMD_LOG2) "processing $${d}"; \
		select=""; from=""; join="1"; \
		if test -e $${d}_rates.import; then \
			select="$${select}, a.distance AS ks, a.aligned AS aligned"; \
			from="$${from} LEFT JOIN $${d}_rates AS a ON r.gene_id = a.gene_id AND a.aligned >= $(PARAM_CORRELATION_MIN_ALIGNED) AND a.distance <= $(PARAM_CORRELATION_MAX_RATE)" ;\
			join="$${join}"; \
		fi; \
		if test -e $${d}_coverage.import; then \
			select="$${select}, cov.nmatches AS nreads, cov.mean AS meancoverage"; \
			from="$${from} LEFT JOIN $${d}_coverage AS cov ON r.gene_id = cov.gene_id"; \
			join="$${join}"; \
		fi; \
		if test -e $${d}_repeats_gc.import; then \
			select="$${select}, ar_gc.exons_mean AS repeats_gc"; \
			from="$${from} LEFT JOIN $${d}_repeats_gc AS ar_gc ON r.gene_id = ar_gc.gene_id"; \
			join="$${join}"; \
		fi; \
		if test -e $${d}_repeats_rates.import; then \
			select="$${select}, ar.exons_length AS ar_aligned, ar.exons_median AS ka, a.distance/ar.exons_median AS kska"; \
			from="$${from} LEFT JOIN $${d}_repeats_rates AS ar ON r.gene_id = ar.gene_id AND ar.exons_nval >= $(PARAM_CORRELATION_MIN_REPEATS)";\
			join="$${join}"; \
		fi; \
		if test -e $${d}_introns_rates.import; then \
			select="$${select}, ir.aligned AS ir_aligned, ir.distance AS ki, a.distance/ir.distance AS kski"; \
			from="$${from} LEFT JOIN $${d}_introns_rates AS ir ON r.gene_id = ir.gene_id AND ir.aligned >= $(PARAM_CORRELATION_MIN_ALIGNED)"; \
			join="$${join}"; \
		fi; \
		s3 $(PARAM_DATABASE) "SELECT \
				CAST(r.gene_id AS TEXT) AS gene_id, \
				r.exons_sum as length, \
				r.exons_pGC as pgc \
				$${select} \
			FROM \
			     $${d}_annotation AS r \
			     $${from} \
			WHERE $${join} " > $@_tmp$${d} ; \
		csv2db.py --map gene_id:str -b sqlite $(OPTION_INDEX) --table=$${d}_evol < $@_tmp$${d} >> $@; \
	done
	@rm -f $@_tmp* 
	@python $(DIR_SCRIPTS_TOOLS)check_db.py \
		--database=$(PARAM_DATABASE) \
		--backend=sqlite \
		--method=columns-in-table \
		--regex-head="^(.*)_evol" \
		--table="_evol$$" \
		--output-filename-pattern="$@.%s.table" \
	>> $@
	@for x in counts percents; do \
		m2m --method=correspondence-analysis --log=$@ < $@.$${x}.table |\
		python $(DIR_SCRIPTS_TOOLS)plot_matrix.py \
			--palette=Reds  \
			--reverse-palette \
			--hardcopy=$@.$${x}.png \
		>> $@; \
	done
	$(EPILOG)

########################################################
########################################################
########################################################
## compute statistics of the overlap of individual sets
## with the merged track into a single table
########################################################
MASTER_TABLE_TABLES=$(DATA_NOT_MASTER:%=$(PARAM_SET_MERGED)_vs_%)
MASTER_TABLE_SELECT=`echo $(MASTER_TABLE_TABLES) | xargs -n 1 | perl -e 'while (<>) { chop; print ", $$_.nover AS $$_"; }'`
MASTER_TABLE_FROM=`echo $(MASTER_TABLE_TABLES) | xargs -n 1 | perl -e 'while (<>) { chop; print " LEFT JOIN $$_ ON master.gene_id = $$_.gene_id"; }'`

$(PARAM_SET_MERGED)_overlap.table:
	$(PRELOG)
	@s3 $(PARAM_DATABASE) "SELECT master.gene_id $(MASTER_TABLE_SELECT) FROM $(PARAM_SET_MERGED)_annotation AS master $(MASTER_TABLE_FROM)" > $@.tmp1
	@d2s --rows --flat --ignore-zeros --format="%5.2f" < $@.tmp1 > $@.tmp2
	@ct $@.tmp2 $@.tmp1 > $@
	@rm -f $@.tmp*
	$(EPILOG)

$(PARAM_SET_MERGED)_overlap.import: $(PARAM_SET_MERGED)_overlap.table
	$(PRELOG)
	@sed "s/^row/gene_id/" < $< |\
	csv2db.py -b sqlite --map=gene_id:str --index=gene_id --table=$(PARAM_SET_MERGED)_overlap > $@	
	$(EPILOG)

########################################################
########################################################
########################################################
## coverage statistics per transcripts across all sets
########################################################
master_overlap_%.stats: master_overlap_%.table
	$(PRELOG)
	@cut -f 1,4- < $< | d2s --ignore-zeros --rows --flat --headers=gene_id > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## coverage statistics per transcripts across all sets
########################################################
master_overlap_%_stats.import: master_overlap_%.stats
	$(PRELOG)
	@csv2db.py -b sqlite --map=gene_id:str --index=gene_id --table=master_overlap_$*_stats < $< > $@	
	$(EPILOG)

########################################################
########################################################
########################################################
## plots showing the overlap between the master set
## and individual transcript sets
########################################################
master_compare_%.table:
	$(PRELOG)
	@for d in $(DATA_SAMPLES_WITHOUT_MASTER); do \
		if [[ "$*" == "all" ]]; then where="1"; else where="is_$*"; fi; \
		s3 $(PARAM_DATABASE) "SELECT master.gene_id AS $${d} \
				FROM $(PARAM_SET_MERGED)_annotation AS master, \
				$(PARAM_SET_MERGED)_vs_$${d}_ovl AS over \
				WHERE master.gene_id = over.gene_id1 AND $${where}" > $@.tmp_$${d}; \
	done
	@python $(DIR_SCRIPTS_TOOLS)set_diff.py --log=$@.log --add-percent --with-title $@.tmp_* > $@
	@csv_cut set1 set2 pinter < $@ | python $(DIR_SCRIPTS_TOOLS)sparse2full.py --log=$@.log | m2p --log=$@.log --zrange=0,1 --title="Overlap between sets in $*" --hardcopy=$@_overlap.png
	@csv_cut set1 set2 pcovmax < $@ | python $(DIR_SCRIPTS_TOOLS)sparse2full.py --log=$@.log | m2p --log=$@.log --zrange=0,1 --title="Maxmimum coverage between sets in $*" --hardcopy=$@_coverage.png
	@csv_cut set1 set2 pcovmax < $@ | python $(DIR_SCRIPTS_TOOLS)sparse2full.py --log=$@.log | m2m --method=correspondence-analysis |\
	m2p --log=$@.log --zrange=0,1 --title="Maxmimum coverage between sets in $*" --hardcopy=$@_coverage_sorted.png
	@rm -f $@.tmp*
	$(EPILOG)

########################################################
########################################################
########################################################
## plot showing the number of transcripts selected when
## applying thresholds on statistical coverage and 
## the number of sets a transcript appears
########################################################
master_selection.matrix: master_overlap_all_stats.import
	$(PRELOG)
	@printf "nsets" > $@
	@for ((nsets=2; nsets < 8; ++nsets)); do \
		printf "\t%i" $${nsets} >> $@; \
	done
	@printf "\n" >> $@
	@for (( coverage = 1; coverage < 10; ++coverage)); do \
		printf "%i" $${coverage} >> $@; \
		for ((nsets=2; nsets < 8; ++nsets)); do \
			printf "\t%i" `s3v $(PARAM_DATABASE) "SELECT count(*) FROM master_overlap_all_stats AS s, $(PARAM_SET_MERGED)_coverage AS c \
				where s.gene_id = c.gene_id and (s.nval >= $${nsets} or c.mean >= $${coverage})"` >> $@; \
		done; \
		printf "\n" >> $@; \
	done
	@m2p --labels="sets,coverage" --hardcopy=$@.png -v 0 < $@
	$(EPILOG)

########################################################
########################################################
########################################################
## plot showing the difference in kska after
## applying thresholds on statistical coverage and 
## the number of sets a transcript appears
########################################################
SELECTION_KSKA="SELECT kska FROM $(PARAM_SET_MERGED)_annotation AS a, \
					$(PARAM_SET_MERGED)_evol AS e \
					LEFT JOIN $(PARAM_TABLE_SELECTED) AS s ON s.gene_id = e.gene_id \
					WHERE a.gene_id = e.gene_id AND \
					kska > 0 AND \
					$${select} \
					$(SELECTION_SELECT_OPTIONS)"

SELECTION_KSKA_HIST=d2h --min-value=0 --bin-size=$(PARAM_PLOT_KSKA_BIN) --min-data=$(PARAM_PLOT_MIN_VALUES) --normalize --log=$@.log 
selection_kska_all.png: PLOT_OPTIONS=--logscale=x --title="Distribution of ks/ka near all transcripts - $(PARAM_TABLE_SELECTED)" --xtitle="rate" --xrange=$(PARAM_PLOT_MIN_KSKA),$(PARAM_PLOT_MAX_KSKA)
selection_kska_all.png: SELECTION_SELECT_OPTIONS=

selection_kska_pc.png: PLOT_OPTIONS=--logscale=x --title="Distribution of ks/ka near protein coding transcripts - $(PARAM_TABLE_SELECTED)" --xtitle="rate" --xrange=$(PARAM_PLOT_MIN_KSKA),$(PARAM_PLOT_MAX_KSKA)
selection_kska_pc.png: SELECTION_SELECT_OPTIONS=AND is_pc

selection_kska_unknown.png: PLOT_OPTIONS=--logscale=x --title="Distribution of ks/ka near unknown transcripts - $(PARAM_TABLE_SELECTED)" --xtitle="rate" --xrange=$(PARAM_PLOT_MIN_KSKA),$(PARAM_PLOT_MAX_KSKA)
selection_kska_unknown.png: SELECTION_SELECT_OPTIONS=AND is_unknown

selection_kska_%.png: evol.import
	$(PRELOG)
	@rm -f $@.tmp*
	@select="(s.gene_id IS NOT NULL)"; \
	s3v $(PARAM_DATABASE) $(SELECTION_KSKA) > $@.tmp_data_selected; \
	cat $@.tmp_data_selected | $(SELECTION_KSKA_HIST) --headers="selected" > $@.tmp_hist_selected; \
	cat $@.tmp_data_selected | $(SELECTION_KSKA_HIST) --headers="selected" --cumulative > $@.tmp_cumul_selected; \
	select="(s.gene_id IS NULL)"; \
	s3v $(PARAM_DATABASE) $(SELECTION_KSKA) > $@.tmp_data_removed; \
	cat $@.tmp_data_removed | $(SELECTION_KSKA_HIST) --headers="removed" > $@.tmp_hist_unselected; \
	cat $@.tmp_data_removed	| $(SELECTION_KSKA_HIST) --headers="removed" --cumulative > $@.tmp_cumul_unselected; \
	$(COMBINE_PLOTS)
	$(EPILOG)

########################################################
########################################################
########################################################
## plot showing the difference in length after
## applying thresholds on statistical coverage and 
## the number of sets a transcript appears
########################################################
SELECTION_LENGTH="SELECT a.exons_sum FROM $(PARAM_SET_MERGED)_annotation AS a LEFT JOIN $(PARAM_TABLE_SELECTED) AS s ON s.gene_id = a.gene_id WHERE $${select} $(SELECTION_SELECT_OPTIONS)"

SELECTION_LENGTH_HIST=d2h --min-data=10 --min-value=0 --normalize --log=$@.log 
selection_length_all.png: PLOT_OPTIONS=--logscale=x --title="Distribution of length near all transcripts - $(PARAM_TABLE_SELECTED)" --xtitle="length" 
selection_length_all.png: SELECTION_SELECT_OPTIONS=

selection_length_pc.png: PLOT_OPTIONS=--logscale=x --title="Distribution of length near protein coding transcripts - $(PARAM_TABLE_SELECTED)" --xtitle="length" 
selection_length_pc.png: SELECTION_SELECT_OPTIONS=AND is_pc

selection_length_unknown.png: PLOT_OPTIONS=--logscale=x --title="Distribution of length near unknown transcripts - $(PARAM_TABLE_SELECTED)" --xtitle="length" 
selection_length_unknown.png: SELECTION_SELECT_OPTIONS=AND is_unknown

selection_length_%.png: 
	$(PRELOG)
	@rm -f $@.tmp*
	@select="(s.gene_id IS NOT NULL)"; \
	s3v $(PARAM_DATABASE) $(SELECTION_LENGTH) > $@.tmp_data_selected; \
	cat $@.tmp_data_selected | $(SELECTION_LENGTH_HIST) --headers="selected" > $@.tmp_hist_selected; \
	cat $@.tmp_data_selected | $(SELECTION_LENGTH_HIST) --headers="selected" --cumulative > $@.tmp_cumul_selected; \
	select="(s.gene_id IS NULL)"; \
	s3v $(PARAM_DATABASE) $(SELECTION_LENGTH) > $@.tmp_data_removed; \
	cat $@.tmp_data_removed | $(SELECTION_LENGTH_HIST) --headers="removed" > $@.tmp_hist_unselected; \
	cat $@.tmp_data_removed	| $(SELECTION_LENGTH_HIST) --headers="removed" --cumulative > $@.tmp_cumul_unselected; \
	$(COMBINE_PLOTS)
	$(EPILOG)

########################################################
########################################################
########################################################
## table with transcripts in the various classes
########################################################
SELECTED_CLASSES_SELECT="SELECT '$${header}' AS data, count(*) as total, sum(is_known) as known, sum(is_unknown) as unknown, sum(is_ambiguous) as ambiguous, \
		sum(is_pc) as pc, sum(is_pseudo) as pseudo, sum(is_npc) as npc, sum(is_utr) as utr, \
		sum(is_intronic) as intronic, sum(is_assoc) as assoc, sum(is_intergenic) as intergenic, \
		count(*) - (sum(is_known)+sum(is_unknown)+sum(is_ambiguous)) as unclassified, \
		sum(is_known) - (sum(is_pc)+sum(is_pseudo)+sum(is_npc)+sum(is_utr)) AS unclassified_known, \
		sum(is_unknown)+sum(is_ambiguous) - (sum(is_intronic)+sum(is_intergenic)) AS unclassified_unknown \
		FROM $(PARAM_SET_MERGED)_annotation AS a LEFT JOIN $(PARAM_TABLE_SELECTED) AS s ON a.gene_id = s.gene_id WHERE $${select}"

selection_classes.table:
	$(PRELOG)
	@rm -f $@.tmp*
	@select="(s.gene_id IS NOT NULL)"; header="selected"; \
	s3 $(PARAM_DATABASE) $(SELECTED_CLASSES_SELECT) > $@
	@select="(s.gene_id IS NULL)"; header="removed"; \
	s3v $(PARAM_DATABASE) $(SELECTED_CLASSES_SELECT) >> $@
	@t2r --plot=bar --hardcopy=$@.png --legend=1 --labels="set,size" --options="cex.names=1.0" --log=$@.log < $@
	@m2m --method=normalize-by-column-total < $@ |\
	t2r --plot=bar --hardcopy=relative_$@.png --legend=1 --labels="set,size" --options="cex.names=1.0" --log=$@.log 
	$(EPILOG)

########################################################
########################################################
########################################################
## build a subdirectory with data for high-confidence transcripts
##
## most can be copied and will no be re-computed, but
## the diffs need to be re-computed.
##
########################################################
SELECTED_TABLES=_annotation _coding _introns_rates _repeats _repeats_rates _rates _repeats_gc _coverage _polyA _distances _evol
SELECTED_CMD_GET_SELECTED=s3 $(PARAM_DATABASE) "SELECT DISTINCT gene_id2 FROM $* AS s, $(PARAM_SET_MERGED)_vs_$${x}_ovl AS ovl WHERE s.gene_id = ovl.gene_id1"
%.subset: 
	$(PRELOG)
	@$(MAKE) $@.dir
	@$(CMD_LOG) "copying schema"
	@-s3 $(PARAM_DATABASE) ".schema" | s3 $@.dir/$(PARAM_DATABASE)
	@-ln -s ../genome.fasta $@.dir/genome.fasta
	@-ln -s ../genome.idx $@.dir/genome.idx
	@$(CMD_LOG) "processing datasets $(filter-out $(PARAM_CONTROL_SETS) $(PARAM_SET_MERGED) $(PARAM_MASTER_SET_GENES), $(DATA) )"
	@for x in $(filter-out $(PARAM_CONTROL_SETS) $(PARAM_SET_MERGED) $(PARAM_MASTER_SET_GENES), $(DATA) ); do \
		 $(CMD_LOG2) "processing $${x}" ; \
		for t in $(SELECTED_TABLES); do \
			table=$${x}$${t}; \
			if test -e $${table}.import; then \
				$(CMD_LOG2) "copying table $${table}" ; \
				s3 $(PARAM_DATABASE) "SELECT DISTINCT t.* FROM $${table} AS t, $* AS s, $(PARAM_SET_MERGED)_vs_$${x}_ovl AS ovl  \
					WHERE t.gene_id = ovl.gene_id2 AND s.gene_id = ovl.gene_id1 " |\
				csv2db.py --allow-empty -b sqlite --map=gene_id:str --database=$@.dir/$(PARAM_DATABASE) --index=gene_id --table=$${table} >> $@.log; \
			else \
				$(CMD_LOG2) "copying table $${table} skipped" ; \
			fi; \
		done; \
		fn=$${x}.gtf; \
		if test ! -e $@.dir/$${fn}; then \
			$(CMD_LOG2) "building file $${fn}" ; \
			python $(DIR_SCRIPTS_GENEPREDICTION)gtf2gtf.py \
			--apply=<( $(SELECTED_CMD_GET_SELECTED) )\
			--filter=gene \
			--log=$@.log \
			< $${fn} > $@.dir/$${fn}; \
		else \
			$(CMD_LOG2) "building file $${fn} skipped" ; \
		fi; \
		for table in coverage polyA; do \
			fn=$${x}.$${table}; \
			if test -e $${fn} &&  test ! -e $@.dir/$${fn}; then \
				$(CMD_LOG2) "building file $${fn}" ; \
				python $(DIR_SCRIPTS_TOOLS)filter_tokens.py \
				--apply=<( $(SELECTED_CMD_GET_SELECTED) )\
				--column=1 \
				--log=$@.log \
				< $${fn} > $@.dir/$${fn}; \
			else \
				$(CMD_LOG2) "building file $${fn} skipped" ; \
			fi; \
		done; \
	done
	@$(CMD_LOG) "processing master $(PARAM_SET_MERGED)"
	@for x in $(PARAM_SET_MERGED); do \
		$(CMD_LOG2) "processing $${x}" ; \
		for t in $(SELECTED_TABLES); do \
			table=$${x}$${t}; \
			$(CMD_LOG2) "copying table $${table}" ; \
			s3 $(PARAM_DATABASE) "SELECT DISTINCT t.* FROM $${table} AS t, $* AS s \
				WHERE t.gene_id = s.gene_id" |\
			csv2db.py --allow-empty -b sqlite --map=gene_id:str --database=$@.dir/$(PARAM_DATABASE) --index=gene_id --table=$${table} >> $@.log; \
		done; \
		fn=$${x}.gtf; \
		if test ! -e $@.dir/$${fn}; then \
			$(CMD_LOG2) "building file $${fn}" ; \
			python $(DIR_SCRIPTS_GENEPREDICTION)gtf2gtf.py \
			--apply=<(s3 $(PARAM_DATABASE) "SELECT gene_id FROM $*") \
			--filter=gene \
			--log=$@.log \
			< $${fn} > $@.dir/$${fn}; \
		else \
			$(CMD_LOG2) "building file $${fn} skipped" ; \
		fi; \
		for table in coverage polyA; do \
			fn=$${x}.$${table}; \
			if test -e $${fn} &&  test ! -e $@.dir/$${fn}; then \
				$(CMD_LOG2) "building file $${fn}" ; \
				python $(DIR_SCRIPTS_TOOLS)filter_tokens.py \
				--apply=<( s3 $(PARAM_DATABASE) "SELECT gene_id FROM $*" )\
				--column=1 \
				--log=$@.log \
				< $${fn} > $@.dir/$${fn}; \
			else \
				$(CMD_LOG2) "building file $${fn} skipped" ; \
			fi; \
		done; \
	done
	@$(CMD_LOG) "processing control sets $(PARAM_CONTROL_SETS) and reference gene set $(PARAM_MASTER_SET_GENES)"
	@for x in $(PARAM_CONTROL_SETS) $(PARAM_MASTER_SET_GENES); do \
		$(CMD_LOG2) "processing $${x}" ; \
		for t in $(SELECTED_TABLES); do \
			table=$${x}$${t}; \
			$(CMD_LOG2) "copying table $${table}" ; \
			s3 $(PARAM_DATABASE) "SELECT * FROM $${table} AS t" |\
			csv2db.py --allow-empty -b sqlite --map=gene_id:str --database=$@.dir/$(PARAM_DATABASE) --index=gene_id --table=$${table} >> $@.log; \
		done; \
		cp $${x}.gtf $@.dir/$${x}.gtf; \
		touch -r $${x}.gtf $@.dir/$${x}.gtf; \
	done
	@for fn in alignment_filtered.psl *.workspace go_*.annotations; do \
		$(CMD_LOG2) "linking to $${fn}" ; \
		if test -e $${fn}; then ln -s ../$${fn} $@.dir/$${fn}; fi \
	done
	@if test -e $@.dir; then \
		$(CMD_LOG2) "building difference files"; \
		$(MAKE) -C $@.dir -j $(PARAM_PARALLEL) diffs-build; \
		$(CMD_LOG2) "importing difference files"; \
		$(MAKE) -C $@.dir diffs-import; \
		$(MAKE) -C $@.dir -t import; \
	fi;
	@for fn in evol.import all.annotations; do \
		$(CMD_LOG2) "re-creating $${fn}" ; \
		if test -e $${fn}; then make -C $@.dir $${fn}; fi \
	done
	@if test -e $@.dir; then \
		$(CMD_LOG2) "making analysis"; \
		$(MAKE) -C $@.dir all; \
	fi
	$(EPILOG)

########################################################
########################################################
########################################################
## create in-place subsets from a subset of merged
## The table should be called merged_%
## This command will create tables for each track called 
## track_% corresponding to merged_%.
########################################################
merged_%.create-subsets: 
	$(PRELOG)
	@for d in $(DATA_SAMPLES_WITHOUT_MASTER); do \
		s3 $(PARAM_DATABASE) "DROP TABLE $${d}_$*"; \
		s3 $(PARAM_DATABASE) "CREATE TABLE $${d}_$* (gene_id TEXT)"; \
		s3 $(PARAM_DATABASE) "INSERT INTO $${d}_$* SELECT DISTINCT gene_id2 FROM merged_$* AS a, merged_vs_$${d}_ovl AS b \
			WHERE a.gene_id = b.gene_id1"; \
		$(CMD_LOG2) "created table $${d}_$* with `s3v $(PARAM_DATABASE) \"SELECT COUNT(*) FROM $${d}_$*\" ` entries" ;\
	done
	$(EPILOG)

########################################################
########################################################
########################################################
## coverage and other assembly quality plots
########################################################
coverage_correlation.table:
	$(PRELOG)
	@for d in $(DATA_COVERAGES); do \
		$(CMD_LOG2) "processing $${d}"; \
		s3 $(PARAM_DATABASE) "SELECT c.ncovered as nresidues, c.mean, c.median, c.nmatches \
				FROM $${d}_annotation as a, \
				     $${d}_coverage AS c \
				WHERE a.gene_id = c.gene_id "\
		pe "s/\t\t/\tna\t/" |\
		t2r --log=$@ --plot=pairs --stats=pearson --hardcopy=$@.$${d}.png --title="Correlations of assembly parameters in $${d}" >> $@_$${d}; \
	done
	$(EPILOG)

########################################################
########################################################
########################################################
## coverage of known genes 
##
## The statement returns the 
##   * the ensembl gene and the number residues in it (length)
##   * coverage of ensembl exons by assembled transcripts within a gene (overlap)
##   * the number of assembled transcripts overlapping (ntranscripts)
##   * the maximum residue coverage of any assembled transcript.
##   * the maximum and total number of residues in the assembled transcripts - this can
##     possibly be larger than the ensembl gene.
##
########################################################
reference_coverage.table:
	$(PRELOG)
	@s3 $(PARAM_DATABASE) \
	"SELECT r.gene_id, r.exons_sum as length, ee.pover1 as overlap, max(c.mean) as mean_coverage, max(c.median) as median_coverage, \
		count(*) as ntranscripts, \
		max(c.ncovered) as naligned, max(c.nmatches) as nmatches, sum(c.ncovered) as total_aligned, sum(c.nmatches) as total_matches \
	FROM $(PARAM_TABLE_NAME_COVERAGE_REFERENCE)_vs_$(PARAM_TABLE_NAME_COVERAGE_DATA)_ovl as e, \
			$(PARAM_TABLE_NAME_COVERAGE_REFERENCE)_vs_$(PARAM_TABLE_NAME_COVERAGE_DATA) as ee, \
			$(PARAM_TABLE_NAME_COVERAGE_REFERENCE)_annotation as r, \
			$(PARAM_TABLE_NAME_COVERAGE_DATA)_annotation as a, \
			$(PARAM_TABLE_NAME_COVERAGE_DATA)_coverage as c \
	WHERE r.gene_id = ee.gene_id and a.gene_id = c.gene_id and e.gene_id2 = a.gene_id and ee.gene_id = e.gene_id1 \
	GROUP by ee.gene_id" \
	> $@
	$(EPILOG)

reference_coverage_correlation.png: reference_coverage.table
	$(PRELOG)
	@t2r --allow-empty --plot=pairs --columns=all-but-first --hardcopy=$@ --stats=pearson < $< > $@.log
	$(EPILOG)

########################################################
########################################################
########################################################
## distribution of coverage per gene - plots
########################################################
reference_coverage_percent.png: PLOT_OPTIONS=--title="Distribution of protein coding exon overlap" --xtitle="coverage" --legend-location="center"
reference_coverage_percent.png: SELECT=pover1 AS $${d}
reference_coverage_ntranscripts.png: PLOT_OPTIONS=--title="Distribution of number of transcripts overlapping a gene" --xtitle="ntranscripts" --logscale=x
reference_coverage_ntranscripts.png: SELECT=nover1 AS $${d}

reference_coverage_%.png:
	$(PRELOG)
	@for d in $(DATA_COVERAGES); do \
		s3 $(PARAM_DATABASE) "SELECT $(SELECT) FROM $(PARAM_MASTER_SET_GENES)_vs_$${d} WHERE nover > 0" > $@.tmp_data_$${d}; \
		cat $@.tmp_data_$${d} |\
		d2h --min-value=0 --bin-size=1 --headers=$${d} --normalize  --log=$@.log > $@.tmp_hist_$${d}; \
		cat $@.tmp_data_$${d} |\
		d2h --min-value=0 --bin-size=1 --headers=$${d} --cumulative --normalize  --log=$@.log > $@.tmp_cumul_$${d}; \
	done; \
	$(COMBINE_PLOTS)
	$(EPILOG)

########################################################
########################################################
########################################################
## distribution of coverage per gene - stats
########################################################
reference_coverage.stats:
	$(PRELOG)
	@for d in $(DATA); do \
		if [[ "$${d}" != "$(PARAM_MASTER_SET_GENES)" ]]; then \
			s3 $(PARAM_DATABASE) "SELECT pover1 AS $${d}_annotation FROM $(PARAM_MASTER_SET_GENES)_vs_$${d} WHERE nover1 > 0" |\
			d2s --log=$@.log > $@.tmp_tab_$${d}; \
			s3v $(PARAM_DATABASE) "SELECT '100%_covered', COUNT(*) FROM $(PARAM_MASTER_SET_GENES)_vs_$${d} WHERE pover1>=100" >> $@.tmp_tab_$${d}; \
			s3v $(PARAM_DATABASE) "SELECT '90%_covered', COUNT(*) FROM $(PARAM_MASTER_SET_GENES)_vs_$${d} WHERE pover1>=90" >> $@.tmp_tab_$${d}; \
			printf "match=1\t%s\n" `s3v $(PARAM_DATABASE) "SELECT gene_id1 FROM $(PARAM_MASTER_SET_GENES)_vs_$${d}_ovl GROUP BY gene_id1 HAVING COUNT(gene_id2) = 1" | wc -l` >> $@.tmp_tab_$${d}; \
			printf "match>1\t%s\n" `s3v $(PARAM_DATABASE) "SELECT gene_id1 FROM $(PARAM_MASTER_SET_GENES)_vs_$${d}_ovl GROUP BY gene_id1 HAVING COUNT(gene_id2) > 1" | wc -l` >> $@.tmp_tab_$${d}; \
		fi; \
	done; \
	$(COMBINE_TABLES)
	$(EPILOG)


########################################################
########################################################
########################################################
## plot of counts of genes matched by transcript sets
########################################################
reference_coverage.png: reference_coverage.stats
	$(PRELOG)
	@awk '$$1 == "category" || $$1 == "count" || $$1=="100%_covered" || $$1=="90%_covered"' < $< |\
	t2r --allow-empty --plot=bar-besides --hardcopy=$@ --legend=1 --labels="set,size" --options="cex.names=1.0" --log=$@.log 
	$(EPILOG)

########################################################
########################################################
########################################################
## plot of residue coverage versus statistical coverage 
## plot is coloured by length
########################################################
reference_coverage_vs_coverage.plot:
	$(PRELOG)
	@for d in $(DATA_COVERAGES); do \
		if [[ "$${d}" != "$(PARAM_MASTER_SET_GENES)" ]]; then \
		 s3 $(PARAM_DATABASE) \
			"SELECT AVG(d.exons_sum) AS ref_length, \
				MIN(c.pover1) AS coverage, \
				AVG(a.mean) AS read_depth \
			FROM $${d}_coverage AS a, \
				$(PARAM_MASTER_SET_GENES)_vs_$${d}_ovl as b, \
				$(PARAM_MASTER_SET_GENES)_vs_$${d} as c, \
				$(PARAM_MASTER_SET_GENES)_annotation as d \
			WHERE   d.gene_id = c.gene_id AND \
				a.gene_id = b.gene_id2 AND \
				c.gene_id = b.gene_id1 \
			GROUP BY b.gene_id1" > $@.tmp; \
		 awk -v OFS="\t" 'NR > 1 { $$1=log($$1); $$3=log($$3) } { print; } ' < $@.tmp |\
		 d2p --color=3 --scatter --point-size=5 --hardcopy=$@_$${d}_A.png --log=$@ --no-legend  \
			--yrange=0,100 \
			--ytitle="coverage" \
			--xtitle="log(length)" \
			--title="$${d} - Coverage of gene models versus length"; \
		fi; \
	done
	@for d in $(DATA_COVERAGES); do \
		if [[ "$${d}" != "$(PARAM_MASTER_SET_GENES)" ]]; then \
		 s3 $(PARAM_DATABASE) \
			"SELECT a.mean AS read_depth, \
				c.exons_sum AS transcript_length, \
				d.exons_sum AS ref_length\
			FROM $${d}_coverage AS a, \
				$(PARAM_MASTER_SET_GENES)_vs_$${d}_ovl as b, \
				$${d}_annotation as c, \
				$(PARAM_MASTER_SET_GENES)_annotation as d \
			WHERE   d.gene_id = b.gene_id1 AND \
				a.gene_id = b.gene_id2 AND \
				c.gene_id = b.gene_id2" > $@.tmp; \
		 awk -v OFS="\t" 'NR > 1 { $$1=log($$1); $$2=log($$2/$$3); $$3=log($$3) } { print; } ' < $@.tmp |\
		 d2p --color=3 --scatter --point-size=5 --hardcopy=$@_$${d}_B.png --log=$@ --no-legend  \
			--ytitle="log(l_predicted/l_known)" \
			--xtitle="log(read_depth)" \
			--title="$${d} - Relative size of known/predicted protein coding loci versus read depth"; \
		fi; \
	done
	@echo -e "Coverage of reference gene models versus the read depth of overlapping transcripts.\nPoints are coloured according to the log(length) of the reference gene model.\nTypically this plot shows that the longer genes are less likely to be covered fully\nand that there is a correlation between read depth and completeness of a gene model" \
	>> $@.caption
	$(EPILOG)

########################################################
########################################################
########################################################
## plots showing the overlap between the reference set
## and individual transcript sets
########################################################
REFERENCE_TABLE_TABLES=$(DATA_NOT_REFERENCE:%=$(PARAM_MASTER_SET_GENES)_vs_%)
REFERENCE_TABLE_SELECT=`echo $(REFERENCE_TABLE_TABLES) | xargs -n 1 | perl -e 'while (<>) { chop; print ", $$_.pover1 AS $$_"; }'`
REFERENCE_TABLE_FROM=`echo $(REFERENCE_TABLE_TABLES) | xargs -n 1 | perl -e 'while (<>) { chop; print " LEFT JOIN $$_ ON reference.gene_id = $$_.gene_id"; }'`
REFERENCE_TABLE_WHERE=

reference_overlap_pc.table:REFERENCE_TABLE_WHERE=AND reference.is_pc = 1
reference_overlap_unknown.table:REFERENCE_TABLE_WHERE=AND reference.is_unknown = 1
reference_overlap_all.table:REFERENCE_TABLE_WHERE=

reference_overlap_%.table:
	$(PRELOG)
	@s3 $(PARAM_DATABASE) "SELECT reference.gene_id, reference.contig, reference.strand $(REFERENCE_TABLE_SELECT) FROM $(PARAM_MASTER_SET_GENES)_annotation AS reference $(REFERENCE_TABLE_FROM) WHERE 1 $(REFERENCE_TABLE_WHERE)" > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## coverage statistics per transcripts across all sets
########################################################
reference_overlap_%.stats: reference_overlap_%.table
	$(PRELOG)
	@cut -f 1,4- < $< | d2s --ignore-zeros --rows --flat --headers=gene_id > $@
	$(EPILOG)

########################################################
########################################################
########################################################
## coverage statistics per transcripts across all sets
########################################################
reference_overlap_%_stats.import: reference_overlap_%.stats
	$(PRELOG)
	@csv2db.py -b sqlite --map=gene_id:str --index=gene_id --table=reference_overlap_$*_stats < $< > $@	
	$(EPILOG)

########################################################
########################################################
########################################################
## plots showing the overlap between the reference set
## and individual transcript sets
########################################################
reference_compare_%.table:
	$(PRELOG)
	@for d in $(DATA_SAMPLES_WITHOUT_MASTER); do \
		if [[ "$*" == "all" ]]; then where="1"; else where="is_$*"; fi; \
		s3 $(PARAM_DATABASE) "SELECT reference.gene_id AS $${d} \
				FROM $(PARAM_MASTER_SET_GENES)_annotation AS reference, \
				$(PARAM_MASTER_SET_GENES)_vs_$${d}_ovl AS over \
				WHERE reference.gene_id = over.gene_id1 AND $${where}" > $@.tmp_$${d}; \
	done
	@python $(DIR_SCRIPTS_TOOLS)set_diff.py --log=$@.log --add-percent --with-title $@.tmp_* > $@
	@csv_cut set1 set2 pinter < $@ | python $(DIR_SCRIPTS_TOOLS)sparse2full.py --log=$@.log | m2p --log=$@.log --zrange=0,1 --title="Overlap between sets in $*" --hardcopy=$@_overlap.png
	@csv_cut set1 set2 pcovmax < $@ | python $(DIR_SCRIPTS_TOOLS)sparse2full.py --log=$@.log | m2p --log=$@.log --zrange=0,1 --title="Maxmimum coverage between sets in $*" --hardcopy=$@_coverage.png
	@csv_cut set1 set2 pcovmax < $@ | python $(DIR_SCRIPTS_TOOLS)sparse2full.py --log=$@.log | m2m --method=correspondence-analysis |\
	m2p --log=$@.log --zrange=0,1 --title="Maxmimum coverage between sets in $*" --hardcopy=$@_coverage_sorted.png
	@rm -f $@.tmp*
	$(EPILOG)


########################################################
########################################################
########################################################
## average average coverage per class
########################################################
coverage_per_class.table:
	$(PRELOG)
	@printf "data" > $@
	@for c in $(PARAM_CATEGORIES); do printf "\t%s" $${c} >> $@; done
	@printf "\n" >> $@ 
	@for d in $(DATA_COVERAGES); do \
		printf "%s" $${d} >> $@; \
		for c in $(PARAM_CATEGORIES); do \
			if [[ "$${c}" == "all" ]]; then where="1"; else where="is_$${c}"; fi; \
			printf "\t%f" `s3v $(PARAM_DATABASE) "SELECT avg(b.mean) FROM $${d}_annotation as a, $${d}_coverage as b WHERE a.gene_id = b.gene_id AND $${where}"` >> $@; \
		done; \
		printf "\n" >> $@; \
	done
	$(EPILOG)

########################################################
########################################################
########################################################
## reads per class and set
########################################################
reads_per_class.table:
	$(PRELOG)
	@printf "data" > $@
	@for c in $(PARAM_CATEGORIES); do printf "\t%s" $${c} >> $@; done
	@printf "\n" >> $@ 
	@for d in $(DATA_COVERAGES); do \
		printf "%s" $${d} >> $@; \
		for c in $(PARAM_CATEGORIES); do \
			if [[ "$${c}" == "all" ]]; then where="1"; else where="is_$${c}"; fi; \
			printf "\t%i" `s3v $(PARAM_DATABASE) "SELECT sum(b.nmatches) FROM $${d}_annotation as a, $${d}_coverage as b WHERE a.gene_id = b.gene_id AND $${where}"` >> $@; \
		done; \
		printf "\n" >> $@; \
	done
	$(EPILOG)

########################################################
########################################################
########################################################
## coverage per class
## The data is binned into bins of the size of 1.
########################################################
coverage_per_class:
	$(PRELOG)
	@for d in $(DATA_COVERAGES); do \
		$(CMD_LOG2) "processing $${d}"; \
		s3 $(PARAM_DATABASE) "SELECT ROUND(mean), is_known, is_unknown, is_ambiguous \
				FROM $${d}_annotation as a, $${d}_coverage AS c \
				WHERE c.gene_id = a.gene_id \
				ORDER BY mean DESC" |\
		python $(DIR_SCRIPTS_TOOLS)data2roc.py --monotonous --multiple > $@.tmp; \
		csv_cut value pis_known  pis_unknown pis_ambiguous < $@.tmp |\
		h2p --stacked --hardcopy=$@_relative_$${d}.png \
			--logscale=x --legend-location="center right" \
			--title="coverage per class in $${d}" --xtitle="coverage >= #" --ytitle="proportion of transcripts" >> $@; \
		csv_cut value is_known is_unknown is_ambiguous < $@.tmp |\
		h2p --stacked --hardcopy=$@_absolute_$${d}.png \
			--logscale=x --legend-location="center right" \
			--title="coverage per class in $${d}" --xtitle="coverage >= #" --ytitle="number of transcripts" >> $@; \
		s3 $(PARAM_DATABASE) "SELECT ROUND(mean), is_intergenic, is_intronic, not(is_intronic or is_intergenic) as is_other \
				FROM $${d}_annotation as a, $${d}_coverage AS c \
				WHERE c.gene_id = a.gene_id AND is_unknown \
				ORDER BY mean DESC" |\
		python $(DIR_SCRIPTS_TOOLS)data2roc.py --monotonous --multiple > $@.tmp; \
		csv_cut value pis_intronic  pis_intergenic pis_other < $@.tmp |\
		h2p --stacked --hardcopy=$@_relative_unknown_$${d}.png \
			--logscale=x --legend-location="center right" \
			--title="coverage per class in $${d}" --xtitle="coverage >= #" --ytitle="proportion of unknown transcripts" >> $@; \
		csv_cut value is_intronic is_intergenic is_other < $@.tmp |\
		h2p --stacked --hardcopy=$@_absolute_unknown_$${d}.png \
			--logscale=x --legend-location="center right" \
			--title="coverage per class in $${d}" --xtitle="coverage >= #" --ytitle="number of unknown transcripts" >> $@; \
		s3 $(PARAM_DATABASE) "SELECT ROUND(mean), is_pc, is_utr, is_pseudo, is_npc, not(is_pc or is_utr or is_pseudo or is_npc)  as is_other \
				FROM $${d}_annotation as a, $${d}_coverage AS c \
				WHERE c.gene_id = a.gene_id AND is_known \
				ORDER BY mean DESC" |\
		python $(DIR_SCRIPTS_TOOLS)data2roc.py --monotonous --multiple > $@.tmp; \
		csv_cut value pis_pc pis_utr pis_pseudo pis_npc < $@.tmp |\
		h2p --stacked --hardcopy=$@_relative_known_$${d}.png \
			--logscale=x --legend-location="center right" \
			--title="coverage per class in $${d}" --xtitle="coverage >= #" --ytitle="proportion of known transcripts" >> $@; \
		csv_cut value is_pc is_utr is_pseudo is_npc < $@.tmp |\
		h2p --stacked --hardcopy=$@_absolute_known_$${d}.png \
			--logscale=x --legend-location="center right" \
			--title="coverage per class in $${d}" --xtitle="coverage >= #" --ytitle="number of known transcripts" >> $@; \
	done
	@rm -f $@.tmp
	$(EPILOG)

########################################################
########################################################
########################################################
## UTR distribution
########################################################
utr.table:
	$(PRELOG)
	@printf "set\tutr5\tutr3\tutr\n" > $@
	@for d in $(DATA_COVERAGES); do \
		printf "%s\t%i\t%i\t%i\n" $${d} \
			`s3v $(PARAM_DATABASE) "SELECT COUNT(*) FROM $${d}_annotation WHERE nover1_utr5 > 0"` \
			`s3v $(PARAM_DATABASE) "SELECT COUNT(*) FROM $${d}_annotation WHERE nover1_utr3 > 0"` \
			`s3v $(PARAM_DATABASE) "SELECT COUNT(*) FROM $${d}_annotation WHERE nover1_utr > 0"` >> $@; \
	done
	t2t --transpose < $@ |\
	python $(DIR_SCRIPTS_TOOLS)r_table2scatter.py \
		--plot=bar-stacked \
		--legend=1 \
		--columns=all-but-first \
		--hardcopy=$@.png \
		--log=$@.log
	$(EPILOG)

########################################################
########################################################
########################################################
## ucsc tracks file
########################################################
## tracks to use (default = all)
UCSC_TRACKS?=$(DATA)
## name to use for the file
UCSC_NAME?=$(PARAM_PROJECT_NAME)_transcripts
## format to use for UCSC output

ucsc-tracks-gtf: UCSC_TRACK_CONVERTER=
ucsc-tracks-bed: UCSC_TRACK_CONVERTER=| python $(DIR_SCRIPTS_GENEPREDICTION)gff2bed.py

ucsc-tracks-%:
	$(PRELOG)
	@outfile=~/public_html/ucsc_tracks/$(UCSC_NAME).$*; \
	rm -f $${outfile}; \
	for d in $(UCSC_TRACKS); do \
		printf 'track name="%s" description="%s" visibility="full" htmlUrl="http://wwwfgu.anat.ox.ac.uk/~andreas/ucsc_tracks/$(UCSC_NAME).html"  \n' $${d} $${d} >> $${outfile}; \
		python $(DIR_SCRIPTS_GENEPREDICTION)gff2gff.py --sanitize=ucsc -v 0 < $${d}.gtf |\
		awk '$$1 != "chrMT"' \
		$(UCSC_TRACK_CONVERTER) \
		>> $${outfile}; \
	done; \
	for d in $(PARAM_FILENAME_TERRITORIES); do \
		printf 'track name="%s" description="%s" visibility="full"\n' $${d} $${d} >> $${outfile}; \
		python $(DIR_SCRIPTS_GENEPREDICTION)gff2gff.py --sanitize=ucsc -v 0 < $${d} |\
		awk '$$1 != "chrMT"' \
		$(UCSC_TRACK_CONVERTER) \
		>> $${outfile}; \
	done; \
	rm -f $${outfile}.gz ;\
	gzip $${outfile}
	@echo "paste the following URL: http://wwwfgu.anat.ox.ac.uk/~andreas/ucsc_tracks/$(UCSC_NAME).$*.gz"
	@echo "edit the file ~/public_html/ucsc_tracks/$(UCSC_NAME).html for track information"
	$(EPILOG)

## view a set of transcripts on the ucsc browser. Upload custom tracks beforehand
## make sure that ids are correct and alphanumeric (000001 instead of 1).
## set the variable PARAM_VIEW_SET
%.view: %
	@python $(DIR_SCRIPTS_GENEPREDICTION)gtf2gtf.py \
		--filter=gene \
		--apply=$< \
	< $(PARAM_VIEW_SET).gtf |\
	python $(DIR_SCRIPTS_GENEPREDICTION)gff2view.py \
		--genome-file=$(PARAM_FILENAME_GENOME) \
		--ucsc-assembly=$(PARAM_VIEW_UCSC_ASSEMBLY) \
		$(PARAM_VIEW_OPTIONS) \
		--is-gtf \
		-

########################################################
########################################################
########################################################
## plot correlation of GC in transcripts and 
## surrounding ancestral repeats colored by kska
## Only take unknown transcripts.
########################################################
gc_kska.plots:
	$(PRELOG)
	@for d in $(DATA); do \
		s3 csvdb "SELECT e.pgc, e.repeats_gc, e.kska - 1.0 FROM $${d}_evol AS e, $${d}_annotation AS a WHERE a.gene_id = e.gene_id AND e.kska > 0 AND e.pgc > 0 AND e.repeats_gc > 0 AND a.is_unknown" |\
		d2p --color=3 --scatter --point-size=3 --no-legend --xtitle="G+C" --ytitle="G+C in ancestral repeats" --log=$@ --hardcopy=$@.$${d}.png; \
	done
	$(EPILOG)

########################################################
########################################################
########################################################
## plot correlation of GC in transcripts and 
## surrounding ancestral repeats colored by kska
## Only take unknown transcripts.
########################################################
readstats.table:
	$(PRELOG)
	@printf "set\tclass\t" > $@; d2s --write-header >> $@
	@for d in $(DATA_READSTATS); do \
		for c in $(PARAM_CATEGORIES); do \
			printf "%s\t%s\t" $${d} $${c} >> $@; \
			if [[ "$${c}" == "all" ]]; then where="1"; else where="is_$${c}"; fi; \
			s3 csvdb "SELECT s.pid FROM $${d}_readstats AS s, $${d}_annotation AS a, $${d}_readmap AS m \
				WHERE m.gene_id = a.gene_id AND m.read_id = s.read_id AND $${where}" |\
			d2s --flat --skip-header --no-title >> $@; \
		done; \
	done
	$(EPILOG)


include $(DIR_SCRIPTS_GENEPREDICTION)/makefiles/Makefile.compare_transcripts_annotator
include $(DIR_SCRIPTS_GENEPREDICTION)/makefiles/Makefile.compare_transcripts_distance
include $(DIR_SCRIPTS_GENEPREDICTION)/makefiles/Makefile.compare_transcripts_go

########################################################
########################################################
########################################################
## build a README file
########################################################
README:
	python $(DIR_SCRIPTS_TOOLS)preppy.py $(DIR_SCRIPTS_GENEPREDICTION)README.compare_transcripts.prep > $@

########################################################
include $(DIR_SCRIPTS_GENEPREDICTION)/makefiles/Makefile.common
