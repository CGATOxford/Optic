################################################################################
#   Gene prediction pipeline 
#
#   $Id: Makefile.paralogy_trees 2781 2009-09-10 11:33:14Z andreas $
#
#   Copyright (C) 2005 Andreas Heger
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License
#   as published by the Free Software Foundation; either version 2
#   of the License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#################################################################################
#################################################################################
#################################################################################
##
## Analyzing multiple alignments for duplications
##
## The input is obtained from a directory of multiple alignments and a file
## of components/sequences to take.
##
##
## The pipeline performs the following steps:
## * calculate pairwise ka and ks
## * build phylogeny incrementally
##   1. bootstrap topolog
##   2. fit ks branch lengths globally on bootstrap topology
##   3. fit ks branch lenghts locally (ks < PARAM_REFINEMENT1_THRESHOLD) without topology changes
##   4. fit ks branch lenghts locally (ks < PARAM_REFINEMENT2_THRESHOLD) with topology changes
## * Analyze trees for duplications and split into subtrees based
##   on out-paralogs or out-groups (if given)
##
## * Build ML trees for each subtrees.
##   * build ML tree for whole subtree
##   * split subtrees into subclusters according to transcript information
##     * build ML tree for each subcluster
##
#################################################################################
##
## The analysis section contains many analysis targets.
##
#################################################################################

################################################
## Section parameters: start
################################################
## Project name
PARAM_PROJECT_NAME?=duplications

################################################
################################################
################################################
## Source information for collecting data for this analysis

## Filename with src information using ks
PARAM_DIR_SRC_MALIS?=../malis/

## Pattern to find multiple alignments
PARAM_PATTERN_MALIS?=$(PARAM_DIR_SRC_MALIS)data.dir/cluster_%s.dir/cluster_%s_aligned_na.fasta

## Pattern to find multiple alignments
PARAM_PATTERN_EXONS?=$(PARAM_DIR_SRC_MALIS)data.dir/cluster_%s.dir/cluster_%s.exons

################################################
################################################
################################################
## directories and database schemas
PARAM_SRC_SCHEMAS?=

## Number of genomes
PARAM_NUM_GENOMES?=`echo $(PARAM_SRC_SCHEMAS) | wc -w`

## Names for export
PARAM_SRC_NAMES?=$(PARAM_SRC_SCHEMAS)

################################################
PARAM_SEPARATOR?=|

################################################
################################################
################################################
## Parameters for analysing duplications

PARAM_DIR_DATA?=../../../data/

## Tree in njtree format with correct names
PARAM_FILENAME_SPECIES_TREE?=$(PARAM_DIR_DATA)species_tree_sp

## Tree with permutations
PARAM_ANALYSIS_DUPLICATIONS_TREE?=$(PARAM_DIR_DATA)species_tree_permutations

## Map of schema names to swissprot names for njtree
PARAM_ANALYSIS_DUPLICATIONS_SPECIES2SP?=$(PARAM_DIR_DATA)schema2sp

## Map of species names to colours
PARAM_ANALYSIS_DUPLICATIONS_COLOURS?=$(PARAM_DIR_DATA)schema2colour

## Map of species names to urls
PARAM_ANALYSIS_DUPLICATIONS_URLS?=$(PARAM_DIR_DATA)schema2url

## Map of species to names
PARAM_ANALYSIS_DUPLICATIONS_TRANSLATION?=$(PARAM_DIR_DATA)schema2name

## Distance between "syntenic" transcripts
PARAM_ANALYSIS_DUPLICATIONS_MAX_SEPARATION?=1000000

## Outgroups to use for rooting trees. If not given, the
## tree is rooted using midpoint rooting.
PARAM_ANALYSIS_DUPLICATIONS_OUTGROUPS?=

## ortholog sets to compute
PARAM_ANALYSIS_DUPLICATIONS_ORTHOLOG_SETS?=exhaustive

################################################
################################################
################################################
## Parameters for removing dodgy sequences from the
## multiple alignment
################################################

## If a pair of genes is closer than this distance,
## the shorter one gets removed
PARAM_MIN_GENOMIC_DISTANCE?=20000

## Minimum overlap for genes that are adjacent on the genome
## to be retained.
PARAM_MIN_PERCENT_OVERLAP?=50

## Maximum permitted overlap for genes of the same
## species that are "not" overlapping. 
PARAM_MAX_PERCENT_OVERLAP?=5

################################################
################################################
################################################
## Options for Gblocks used for mali filtering
################################################

## allow up to half the sequence to have gaps
PARAM_GBLOCKS_OPTIONS?=-b5=h

## Accept Gblocks alignments, if at least 50% of positions are kept,
## otherwise keep the original.
PARAM_GBLOCKS_MIN_KEPT?=50

################################################
## Analysis options

## Filtering of multiple alignments to exclude gappy 
## alignments from the analysis

## Maximum distance in tree. Distances larger than 
## this value are treated as missing.
PARAM_MAX_DISTANCE?=5

## Minimum character occupancy of rows
PARAM_ANALYSIS_THRESHOLD_MIN_NROWS=100

## Minimum character occupancy of rows in percent
PARAM_ANALYSIS_THRESHOLD_MIN_PROWS=40

################################################
################################################
################################################
## Table names
PARAM_PSQL_SCHEMA?=$(PARAM_PROJECT_NAME)

## Input table to get ortholog groups
PARAM_TABLE_NAME_ORTHOGROUPS?=$(PARAM_PSQL_SCHEMA).clusters_members

################################################
## table with orthologous group information
## summary information on orthologous groups
PARAM_TABLE_NAME_GROUPS?=$(PARAM_PSQL_SCHEMA).groups
## members of orthologous groups
PARAM_TABLE_NAME_GROUPS_MEMBERS?=$(PARAM_PSQL_SCHEMA).groups_members
## species order in ortholog groups
PARAM_TABLE_NAME_GROUPS_SPECIES?=$(PARAM_PSQL_SCHEMA).groups_species
## species order in ortholog groups
PARAM_TABLE_NAME_GROUPS_SUMMARY?=$(PARAM_PSQL_SCHEMA).groups_summary
## comments for orthologous groups
PARAM_TABLE_NAME_GROUPS_COMMENTS?=$(PARAM_PSQL_SCHEMA).groups_comments

################################################
## table with synonym information
PARAM_TABLE_NAME_SYNONYMS?=$(PARAM_PSQL_SCHEMA).synonyms

################################################
## table with groups trees
PARAM_TABLE_NAME_GROUPS_NJ_TREES?=$(PARAM_PSQL_SCHEMA).groups_nj_trees

################################################
## table with cluster trees
PARAM_TABLE_NAME_CLUSTER_TREES?=$(PARAM_PSQL_SCHEMA).clusters_trees

################################################
## table with synteny information
PARAM_TABLE_NAME_SYNTENY?=$(PARAM_PSQL_SCHEMA).synteny

################################################
## table with strict 1:1 ortholog sets
## table of strict 1:1 ortholog set info
PARAM_TABLE_NAME_ORTHOLOG_SETS?=$(PARAM_PSQL_SCHEMA).ortholog_sets
## members of strict 1:1 ortholog sets
PARAM_TABLE_NAME_ORTHOLOG_SETS_MEMBERS?=$(PARAM_PSQL_SCHEMA).ortholog_sets_members
## species order in strict 1:1 ortholog sets
PARAM_TABLE_NAME_ORTHOLOG_SETS_SPECIES?=$(PARAM_PSQL_SCHEMA).ortholog_sets_species

################################################
## transcripts that have been removed as possibly joining
PARAM_TABLE_NAME_REMOVED_TRANSCRIPTS?=$(PARAM_PSQL_SCHEMA).removed_transcripts

################################################
## table of orphans
PARAM_TABLE_NAME_ORPHANS?=$(PARAM_PSQL_SCHEMA).orphans

################################################
# Section parameters: end
################################################

REQUISITES=input.map

nop:

##################################################################################
prepare: create-log create-tables input.map
	$(PRELOG)
	$(EPILOG)

create-tables: \
		$(PARAM_TABLE_NAME_GROUPS_SUMMARY).create-table-groups-summary \
		$(PARAM_TABLE_NAME_GROUPS_MEMBERS).create-table-groups-members \
		$(PARAM_TABLE_NAME_GROUPS_SPECIES).create-table-groups-species \
		$(PARAM_TABLE_NAME_GROUPS_COMMENTS).create-table-groups-comments \
		$(PARAM_TABLE_NAME_SYNONYMS).create-table-synonyms \
		$(PARAM_TABLE_NAME_GROUPS_NJ_TREES).create-table-groups-trees \
		$(PARAM_TABLE_NAME_CLUSTER_TREES).create-table-cluster-trees \
		$(PARAM_TABLE_NAME_ORTHOLOG_SETS).create-table-ortholog-sets \
		$(PARAM_TABLE_NAME_ORTHOLOG_SETS_MEMBERS).create-table-ortholog-sets-members \
		$(PARAM_TABLE_NAME_ORTHOLOG_SETS_SPECIES).create-table-ortholog-sets-species \
		$(PARAM_TABLE_NAME_SYNTENY).create-table-synteny \
		$(PARAM_TABLE_NAME_REMOVED_TRANSCRIPTS).create-table-removed-transcripts \
		$(PARAM_TABLE_NAME_ORPHANS).create-table-orphans 

all: data.prepare data.run 

summary: 
	$(PRELOG)
	@$(MAKE) summary.dir
	@$(MAKE) -C summary.dir summary-hook
	$(EPILOG)

summary-hook: groups groups.load orphans.load \
		ortholog_sets ortholog_sets.load \
		groups_trees groups_trees.load \
		cluster_trees cluster_trees.load \
		synteny.load \
		removed removed.load

####################################################################################
####################################################################################
####################################################################################
## build input.map from a clade genomics pipeline table.
####################################################################################
input.map:
	$(PRELOG)
	@rm -f $@
	@for x in $(PARAM_SRC_SCHEMAS); do \
		$(PSQL_CONNECTION) \
		"SELECT DISTINCT '$${x}$(PARAM_SEPARATOR)' || o.gene_id, \
			g.group_id1 \
			FROM $${x}.overview AS o, $(PARAM_TABLE_NAME_ORTHOGROUPS) AS g \
			WHERE CAST(g.gene_id AS TEXT) = CAST(o.gene_id AS TEXT) AND \
				g.schema = '$${x}' AND o.gene_id != '0' AND g.group_id1 != '0'" \
		$(PSQL_CONNECTION_OPTIONS) >> $@; \
	done
	@$(CMD_LOG) "$@: number of clusters:" `cut -f 2 $@ | sort | uniq | wc -l`
	@$(CMD_LOG) "$@: number of entries :" `wc -l < $@`
	@printf "species\tgenes\n" $(TOLOG)
	@for x in $(PARAM_SRC_SCHEMAS); do \
		printf "%s\t%i\t%i\n" $${x} \
			`cut -f 1 $@ | grep $${x} | cut -d "$(PARAM_SEPARATOR)" -f 2 | sort | uniq | wc -l` \
		$(TOLOG); \
	done
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Prepare data directory
#######################################################################################
data.prepare: 
	$(PRELOG)
	$(MAKE) data.dir
	$(CMD_LOG) "creating directories and writing malis."
	@python $(DIR_SCRIPTS_TOOLS)malis2malis.py \
		--filename-components=input.map \
		--pattern-mali=$(PARAM_PATTERN_MALIS) \
	       	--pattern-component="^(\S+)" \
		--pattern-output="data.dir/cluster_%s.dir/cluster_%s.fasta" \
		--pattern-filter="^([^|]+)[|]" \
		--list-filter=`echo "$(PARAM_SRC_SCHEMAS)" | perl -p -e "s/ +/,/g"` \
		--ignore-missing \
		--output-format=fasta > $@
	$(CMD_LOG) "adding Makefiles to directories."
	@for d in data.dir/cluster_*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		ln -s ../../Makefile $${d}/Makefile; \
		v="$(PARAM_PATTERN_EXONS)"; \
		ln -f -s ../../$${v//\%s/$${cluster_id}} $${d}/cluster_$${cluster_id}.exons; \
	done
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Progress report
#######################################################################################
data.show-progress:
	@echo "# prediction status at `date`" >> data.progress
	@nkaks=0;nfitted=0;nr1=0;nr2=0;ntree=0;ndupl=0;nhook=0;nfasta=0; \
	for d in data.dir/cluster*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		if test -s $${d}/cluster_$${cluster_id}.fasta; then        let "nfasta=nfasta+1"; fi; \
		if test -s $${d}/cluster_$${cluster_id}.tree; then         let "ntree=ntree+1"; fi; \
		if test -s $${d}/cluster_$${cluster_id}.duplications; then         let "ndupl=ndupl+1"; fi; \
		if test -e $${d}/data.run-subhook; then                    let "nhook=nhook+1"; fi; \
	done; \
	awk -v nfasta="$${nfasta}" -v nkaks=$${nkaks} -v nfitted=$${nfitted} \
	    -v nr1=$${nr1} -v nr2=$${nr2} -v ntree=$${ntree} -v ndupl=$${ndupl} -v nhook=$${nhook} \
	'END {  printf("# N\tNTREE\tPLEFT\tRSUCC\tNDUPL\tPLEFT\tRSUCC\tNHOOK\tPLEFT\tRSUCC\n"); \
		printf("%i\t%i\t%5.2f\t%5.2f\t%i\t%5.2f\t%5.2f\t%i\t%5.2f\t%5.2f\n", \
			nfasta,\
			ntree,((nfasta-ntree)*100)/nfasta,(nfasta > 0) ? 100*ntree/nfasta : 0, \
			ndupl,((nfasta-ndupl)*100)/nfasta,(ntree > 0) ? 100*ndupl/ntree : 0 , \
			nhook,((nfasta-nhook)*100)/nfasta,(ndupl > 0) ? 100*nhook/ndupl : 0 ); }' \
	</dev/null >> data.progress
	@tail data.progress


#######################################################################################
#######################################################################################
#######################################################################################
## Show missing files
#######################################################################################
data.show-unfinished:
	@for d in data.dir/cluster_*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		file=$${d}/cluster_$${cluster_id}.tree; \
		if test -e $${file} && ! grep -q "# job finished in" $${file}.log; then \
			$(CMD_MSG2) "unfinished $${file};"; \
		fi; \
		file=$${d}/cluster_$${cluster_id}.duplications; \
		if test -e $${file} && ! grep -q "# job finished in" $${file}; then \
			$(CMD_MSG2)  "unfinished $${file};"; \
		fi; \
	done

#######################################################################################
#######################################################################################
#######################################################################################
## Remove debris from aborted runs
#######################################################################################
data.remove-unfinished:
	$(PRELOG)
	@ntrees=0;ndups=0;\
	for d in data.dir/cluster_*.dir; do \
		cluster_id=$${d#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		file=$${d}/cluster_$${cluster_id}.tree; \
		if test -e $${file} && ! grep -q "# job finished in" $${file}.log; then \
			$(CMD_MSG2)  "removing $${file};" >> $@.log; \
			rm -f $${file}; \
			let "ntrees=ntrees+1"; \
		fi; \
		file=$${d}/cluster_$${cluster_id}.duplications; \
		if test -e $${file} && ! grep -q "# job finished in" $${file}; then \
			$(CMD_MSG2)  "removing $${file};" >> $@.log; \
			rm -f $${file}; \
			let "ndups=ndups+1"; \
		fi; \
	done; \
	$(CMD_LOG2) "removed $${ntrees} files: *.trees"; \
	$(CMD_LOG2) "removed $${ndups} files: *.duplications"
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Build targets in subdirectories
#######################################################################################
DATA=$(wildcard cluster_[0-9]*.dir)

data.run: data.prepare
	$(PRELOG)
	@if test -e data.dir; then \
		$(MAKE) -C data.dir -k -j $(PARAM_NUM_JOBS) $@-hook; \
	fi
	@touch $@
	$(EPILOG)

$(DATA):
	@$(MAKE) -C $@ data.run-subhook 

data.run-hook: $(DATA)

data.run-subhook: 
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) $(MAKE) duplications-hook < /dev/null
	@touch $@
	$(EPILOG)

.PHONY: $(DATA)

#######################################################################################
#######################################################################################
#######################################################################################
#######################################################################################
## Targets to execute in subdirectory
##
## If there are only two sequences, skip the tree building step.
##
#######################################################################################
QUERY_SUBDIR=$(wildcard cluster_*.fasta)
TARGET_SUBDIR=$(QUERY_SUBDIR:%.fasta=%.tree) \
		$(QUERY_SUBDIR:%.fasta=%.duplications )

duplications-hook: $(TARGET_SUBDIR) 

#################################################################################
#################################################################################
#################################################################################
## Mask sequences for composition and incomplete codons and remove fully gapped 
## columns
#################################################################################
%.masked_mali: %.fasta
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)fasta2fasta.py --log=$@.log --method=mask-seg < $< > $@
	$(EPILOG)

#################################################################################
#################################################################################
#################################################################################
## Run Gblocks on mali.
## Note: Gblocks always ends on error code 1, thus ignore it.
## If more than 50% is removed, keep the original alignment
#################################################################################
%.mali: %.masked_mali
	$(PRELOG)
	@rm -f $@.log
	@grep -v "#" $< |\
	python $(DIR_SCRIPTS_GENEPREDICTION)mali2cleaned_mali.py \
		--mode=split \
		--min-percent-overlap=$(PARAM_MIN_PERCENT_OVERLAP) \
		--max-percent-overlap=$(PARAM_MAX_PERCENT_OVERLAP) \
		--filename-removed=$*.removed \
		--filename-exons=$*.exons \
		--gene-mode \
		--min-genomic-distance=$(PARAM_MIN_GENOMIC_DISTANCE) \
		--log=$@.log |\
	perl -p -e "s/ //g unless (/^>/);" > $@_tmp
	@-Gblocks $@_tmp -t=c $(PARAM_GBLOCKS_OPTIONS) >> $@.log
	@nkept=`grep "Gblocks alignment" $@.log | tail -n 1 | perl -p -e "s/.*positions \(//; s/ %\).*//;"`; \
	if [[ $${nkept} -lt "$(PARAM_GBLOCKS_MIN_KEPT)" ]]; then \
		printf "using original alignment\n" >> $@.log; \
		$(CMD_LOG2) "using original alignment"; \
		mv $@_tmp $@; \
	else \
		mv $@_tmp-gb $@; \
	fi; \
	rm -f $@_tmp*
	$(EPILOG)

#################################################################################
#################################################################################
#################################################################################
##
## Build a tree for duplication analysis
##
#################################################################################
ifneq ($(PARAM_FILENAME_SPECIES_TREE),"")
TREE_EXTRA_OPTIONS=--tree=$(PARAM_FILENAME_SPECIES_TREE)
endif

%.tree: %.mali
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)WrapperNJTree.py \
		--map=$(PARAM_ANALYSIS_DUPLICATIONS_SPECIES2SP) \
		--log=$@.log \
		--err=$@.err \
		--dump \
		$(TREE_EXTRA_OPTIONS) \
	< $< > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Analyze duplications
#######################################################################################

###########################################################################
###########################################################################
###########################################################################
## Analysis of duplications
%.map_id2pos: %.exons
	$(PRELOG)
	@cat $^ |\
	awk '{ chr=$$2; split($$1,a,"$(PARAM_SEPARATOR)"); \
		id=sprintf("%s$(PARAM_SEPARATOR)%s", a[1],a[3]); \
		printf("%s\t%s\t%s\t%i\t%i\n", id, chr, $$3, $$8, $$9); }'  |\
	sort -k1,1 -k2,2 -k3,3n -k4,4n -k5,5|awk '{ if ($$1 != id) \
	     { if (id) { printf("%s\t%s\t%s\t%i\t%i\n", id, chr, strand, min, max)}; \
		id = $$1; chr=$$2; strand=$$3; min=$$4;} max=$$5 } \
	     END { printf("%s\t%s\t%s\t%i\t%i\n", id, chr, strand, min, max); }' > $@
	$(EPILOG)

clean-duplications:
	$(PRELOG)
	@rm -f cluster*.duplications*
	$(EPILOG)

###########################################################################
## SVG image of duplications
## Optionally use different kinds of tree
ifneq ($(PARAM_ANALYSIS_DUPLICATIONS_OUTGROUPS), "")
DUPLICATIONS_EXTRA_OPTIONS=--outgroup-species=`echo "$(PARAM_ANALYSIS_DUPLICATIONS_OUTGROUPS)" | perl -p -e "s/ +/,/g"`
endif

%.duplications: %.tree %.map_id2pos
	$(PRELOG)
	@grep -v -e "^#" -e "^>" $< |\
	python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_orthology_multiple.py \
		--filename-species-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		--filename-species2colour=$(PARAM_ANALYSIS_DUPLICATIONS_COLOURS) \
		--filename-species2url=$(PARAM_ANALYSIS_DUPLICATIONS_URLS) \
		--filename-locations=$*.map_id2pos \
		--max-separation=$(PARAM_ANALYSIS_DUPLICATIONS_MAX_SEPARATION) \
		$(DUPLICATIONS_EXTRA_OPTIONS) \
		--output-pattern=$@_%s \
		--output-pattern-svg=$@.svg \
		--prefix=$* \
		--subtrees-trees \
		--subtrees-identifiers \
		--print-svg --print-subtotals --print-best \
		--gene-regex="^[^|]+\|([^|]+)" \
	> $@
	$(EPILOG)

.PRECIOUS: %.duplications

###########################################################################
###########################################################################
###########################################################################
## Analyze subtrees
SUBTREES=$(wildcard subtree_cluster_[0-9]*.dir)

%.subtrees: %.subtrees.prepare
	$(PRELOG)
	@if test -e $@.dir; then \
		$(MAKE) -k -C $@.dir subtrees.run-hook; \
	fi
	$(EPILOG)

$(SUBTREES):
	$(PRELOG)
	@$(MAKE) -k -C $@ subtree
	$(EPILOG)

subtrees.run-hook: $(SUBTREES)

.PHONY: $(SUBTREES)

###########################################################################
###########################################################################
###########################################################################
## Split subtrees into individual directories
##	Information I need is malis and trees.
##      Set optimization threshold according to the number of sequences in the
##	file.
##      
###########################################################################
clean-subtrees:
	$(PRELOG)
	@rm -rf cluster*.subtrees*
	$(EPILOG)

###########################################################################
## If there are more than 30 sequences, speed up calculation:
##    * terminate optimization quicker at threshold
##    * choose other optimization method
##    * do not compute variable_w
PARAM_SUBTREES_THRESHOLD_OPTIMIZATION_NSEQUENCES?=30
PARAM_SUBTREES_THRESHOLD_OPTIMIZATION?=.5e-4
%.subtrees.prepare: %.duplications %.fasta 
	$(PRELOG)
	@rm -rf $*.subtrees.dir
	@python $(DIR_SCRIPTS_GENEPREDICTION)split_fasta.py \
	--map=$<_subids \
	--output-pattern="$*.subtrees.dir/subtree_%s.dir/subtree_%s.fasta" \
	< $*.fasta >> $@
	@python $(DIR_SCRIPTS_GENEPREDICTION)split_fasta.py \
	--skip-identifiers \
	--output-pattern="$*.subtrees.dir/subtree_%s.dir/subtree_%s.tree" \
	< $<_subtrees >> $@
	@ln -f -s ../Makefile $*.subtrees.dir
	@for dir in $*.subtrees.dir/*.dir; do \
		ln -f -s ../Makefile $${dir}/Makefile; \
	done
	$(EPILOG)

%.subtrees.finish: %.map_id2pos
	$(PRELOG)
	@find $*.subtrees.dir -name "subtree_$*_*_fixed_w_ml.tree" -exec cat {} \; |\
	python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_orthology_multiple.py \
		--filename-species-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		--filename-species2colour=$(PARAM_ANALYSIS_DUPLICATIONS_COLOURS) \
		--filename-species2url=$(PARAM_ANALYSIS_DUPLICATIONS_URLS) \
		--filename-locations=$*.map_id2pos \
		--max-separation=$(PARAM_ANALYSIS_DUPLICATIONS_MAX_SEPARATION) \
		$(DUPLICATIONS_EXTRA_OPTIONS) \
		--output-pattern=$*.subtrees.dir/%s.result \
		--output-pattern-svg=$*.subtrees.dir/%s.svg \
		--prefix=$* \
		--print-svg \
		--print-totals \
		--svg-print-location \
	> $@
	$(EPILOG)

.PRECIOUS: %.subtrees.prepare %.subtrees.finish

###########################################################################
###########################################################################
###########################################################################
## Estimate ks tree for each multiple alignment using PAML and the
## topology estimated previously.
## Here is the logic for running jobs in parallel
###########################################################################
subtree: subtree.prepare subtree.run subtree.finish

## Split according to transcripts
SUBTREE_PREPARE_QUERIES=$(wildcard subtree*.fasta)
SUBTREE_PREPARE_TARGETS=$(SUBTREE_PREPARE_QUERIES:%.fasta=%.clusters) \
			$(SUBTREE_PREPARE_QUERIES:%.fasta=%.split) \
			$(SUBTREE_PREPARE_QUERIES:%.fasta=%.split_clean)

subtree.prepare: $(SUBTREE_PREPARE_TARGETS)
	$(PREPARE)
	@touch $@
	$(EPILOG)

SUBTREE_RUN_QUERIES=$(wildcard *.fasta)
SUBTREE_RUN_TARGETS?= \
		$(SUBTREE_RUN_QUERIES:%.fasta=%.masked_mali) \
		$(SUBTREE_RUN_QUERIES:%.fasta=%.mali) \
		$(SUBTREE_RUN_QUERIES:%.fasta=%.phylip) \
		$(SUBTREE_RUN_QUERIES:%.fasta=%_fixed_w.paml) \
		$(SUBTREE_RUN_QUERIES:%.fasta=%_fixed_w_ml.tree) 

# Disabled variable rate test
# ifneq ($(wildcard subtree_*_variable_w.ctl),)
# SUBTREE_RUN_TARGETS+= $(SUBTREE_RUN_QUERIES:%.fasta=%_variable_w.paml) \
# 		$(SUBTREE_RUN_QUERIES:%.fasta=%_variable_w_ml.tree) \
# 		$(SUBTREE_RUN_QUERIES:%.fasta=%.lrt) 
# endif

subtree.run: subtree.prepare
	$(PRELOG)
	@$(MAKE) subtree.run-hook
	@touch $@
	$(EPILOG)

subtree.run-hook: $(SUBTREE_RUN_TARGETS)

subtree.finish: subtree.run 
	$(PREPARE)
	@touch $@
	$(EPILOG)

.PHONY: subtree.run-hook

###########################################################################
###########################################################################
###########################################################################
## Process the multiple alignments
## * remove alternative transcripts
###########################################################################
%.overlap: %.fasta
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)mali_rates.py \
		--distance=POVL \
	< $< > $@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
## Build clusters according to transcript components.
###########################################################################
%.clusters: %.overlap
	$(PRELOG)
	@awk '!/^#/ && !/^id1/ { printf("%s\t%s\t%f\n", $$1, $$2, 100.0 - $$3); }' < $< |\
	python $(DIR_SCRIPTS_TOOLS)graph_cluster_by_species.py \
		--max-weight=99.999 \
		--mode=genes \
		--filename-synonyms=$@.synonyms \
		--filename-summary=$@.summary > $@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
## Split input multiple alignment, but only if it contains multiple
## transcript components. 
###########################################################################
%.split: %.fasta %.clusters
	$(PRELOG)
	@rm -f subcluster_$*_*
	@ncomponents=`grep "^# ncomponents=" $*.clusters | perl -p -e "s/# ncomponents=//; s/,.*//"`; \
	if [ "$${ncomponents}" -gt "1" ]; then \
		python $(DIR_SCRIPTS_GENEPREDICTION)split_fasta.py \
		--map=<(grep -v "^id" < $*.clusters) \
		--min-size=2 \
		--output-pattern=subcluster_$*_%s.fasta \
		< $< > $@; \
		for x in subcluster_$*_*.fasta; do \
			python $(DIR_SCRIPTS_TOOLS)mali2mali.py \
				--method=remove-all-gaps \
				--verbose=0 \
			< $${x} > $@_tmp; \
			mv $@_tmp $${x}; \
		done; \
		$(CMD_LOG2) "splitting $*.fasta into $${ncomponents} components."; \
	else \
		$(CMD_LOG2) "not splitting $*.fasta, because only one component."; \
	fi
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
## check fasta files and delete those which are non-mappable
###########################################################################
%.split_clean: %.split
	$(PRELOG)
	@for file in *.fasta; do \
		python $(DIR_SCRIPTS_TOOLS)mali2mali.py \
			--method=remove-unaligned-pairs,remove-all-gaps \
			--verbose=0 < $${file} > $@.tmp; \
		if [ `grep -c ">" $@.tmp` -lt "2" ]; then \
			$(CMD_LOG2) "after cleaning less than 2 sequences remain in $${file} - removed"; \
			rm -f $${file}; \
		fi; \
	done
	@rm -f $@.tmp
	@touch $@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
## Prepare data for input
## 1. Convert mali to phylip format and perform the following operations on it:
##    Remove unaligned sequences
##    Rename identifiers in mali and tree to short identifiers
##    Remove alternative transcripts
##    Unroot tree
%.phylip: %.mali
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)mali2mali.py \
		--method=remove-unaligned-pairs,remove-all-gaps \
		--verbose=0 \
	< $< |\
	python $(DIR_SCRIPTS_TOOLS)fasta2fasta.py \
		    --method=build-map \
		    --parameters=$*.map_old2new |\
	python $(DIR_SCRIPTS_TOOLS)mali2mali.py \
		--input-format=fasta \
		--output-format=phylip \
		--verbose=0 > $@; \
	python $(DIR_SCRIPTS_TOOLS)tree2tree.py \
		--method=rename,unroot \
		--parameters=$*.map_old2new \
		--verbose=0 \
	< subtree_cluster_[0-9]*_tree[0-9]_[0-9].tree > $*_mapped.tree
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
%_fixed_w.ctl: %.fasta
	$(PRELOG)
	@nsequences=`grep -c ">" < $*.fasta`; \
	if [ "$${nsequences}" -gt "$(PARAM_SUBTREES_THRESHOLD_OPTIMIZATION_NSEQUENCES)" ]; then \
		$(CMD_LOG2) "reduced sensitivity for alignment $${cluster_id} with $${nsequences} members."; \
		extra_options="--set-optimization-threshold=$(PARAM_SUBTREES_THRESHOLD_OPTIMIZATION) --set-method=1"; \
	fi; \
	python $(DIR_SCRIPTS_GENEPREDICTION)WrapperCodeML.py \
		--filename-output=../$*_fixed_w.output \
		--filename-sequences=../$*.phylip \
		--filename-tree=../$*_mapped.tree \
		--write-control-file \
		$${extra_options} \
		--analysis=branch-fixed-kaks |\
	grep -v "#" > $@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
%_fixed_w.paml: %_fixed_w.ctl %.phylip
	$(PRELOG)
	@mkdir -p $@.dir
	@cd $@.dir >& /dev/null; codeml ../$< < /dev/null > ../$@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
%_variable_w.paml: %_variable_w.ctl %.phylip
	$(PRELOG)
	@mkdir -p $@.dir
	@cd $@.dir >& /dev/null; codeml ../$< < /dev/null > ../$@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
%_fixed_w_ml.tree: %_fixed_w.paml 
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)codeml2tsv.py \
		--prefix=$*_fixed_w \
		--method=write-ks-tree \
		$*_fixed_w.output |\
	python $(DIR_SCRIPTS_TOOLS)tree2tree.py \
		--method=rename,midpoint-root \
		--parameters=$*.map_old2new \
		--invert \
		--verbose=0 > $@
	$(EPILOG)

###########################################################################
###########################################################################
###########################################################################
subtree_%.lrt: subtree_%_fixed_w.paml subtree_%_variable_w.paml
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)codeml2tsv.py \
		--prefix=subtree_$* \
		--method=lrt \
		subtree_$*_fixed_w.output subtree_$*_variable_w.output > $@
	$(EPILOG)

.PRECIOUS: subtree_%.paml subtree_%.phylip subtree_%_ml.tree subtree_%.lrt %_fixed_w.ctl %.clusters %.overlap

#######################################################################################
#######################################################################################
#######################################################################################
#######################################################################################
## Primary targets for complete statistics
#######################################################################################
TARGET_STATS=$(QUERY_SUBDIR:%.fasta=%.stats)
OUTPUT_FILES=$(PARAM_OMEGA_VALUES:%=$*_%.output)

stats: $(TARGET_STATS)

%.stats: %.counts
	$(EPILOG)

%.counts:
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)codemls2tsv.py \
		--filter-probability=$(PARAM_FILTER_SITES_PROBABILITY) \
		--filter-omega=$(PARAM_FILTER_SITES_OMEGA) \
		--models=`echo $(PARAM_FILTER_MODELS) | perl -p -e "chop; s/\s+/,/g"` \
		--analysis=`echo $(PARAM_FILTER_METHOD) | perl -p -e "chop; s/\s+/,/g"` \
		--method=summary-numbers \
		--significance-threshold=$(PARAM_SIGNIFICANCE_THRESHOLD) \
		--prefix=$* \
		$(OUTPUT_FILES) > $@
	$(EPILOG)

.PRECIOUS: %.counts

#######################################################################################
#######################################################################################
#######################################################################################
## collect exon information
#######################################################################################
all.exons:
	$(PRELOG)
	@for dir in ../data.dir/cluster*.dir; do \
		cluster_id=$${dir#../data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		cat $${dir}/cluster_$${cluster_id}.exons >> $@; \
	done
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## build a list of filtered malis
#######################################################################################
malis.filtered: malis.summary
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)csv_cut.py prefix nrow_mean prow_mean < $< |\
	awk '!/^#/ && \
	     $$2 >= $(PARAM_ANALYSIS_THRESHOLD_MIN_NROWS) && \
	     $$3 >= $(PARAM_ANALYSIS_THRESHOLD_MIN_PROWS) { \
	     printf("cluster_%s\n", $$0); }' > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## tree information
#######################################################################################
analysis:
	$(PRELOG)
	@$(MAKE) analysis.dir
	@$(MAKE) analysis.dir/trees
	@$(MAKE) -C analysis.dir -k -j $(PARAM_NUM_JOBS) analysis-hook
	$(EPILOG)

analysis.dir/trees:
	$(PRELOG)
	@rm -f $@
	@for dir in data.dir/cluster*.dir; do \
		cluster_id=$${dir#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		file=$${dir}/cluster_$${cluster_id}.duplications_subtrees; \
		if test -e $${file}; then \
			cat $${file} >> $@.tmp; \
		else \
			echo "file not found: $${file}" >> $@.err; \
		fi; \
	done
	@awk '/^>/ { printf(">%i\n", ++a ); \
		    printf("%s\t%i\n", substr($$1,2), a) >> "$@.map"; next; } \
		{ print; }' \
	< $@.tmp > $@
	@rm -f $@.tmp
	$(EPILOG)

###############################################################################
###############################################################################
###############################################################################
## filter trees according to maximum branch length 
###############################################################################
filtered: trees
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)tree2tree.py \
		--filter=max-branch-length \
		--parameters=$(PARAM_MAX_DISTANCE) \
	< $< > $@
	$(EPILOG)

###############################################################################
###############################################################################
###############################################################################
## build file collecting all neighbour-joining trees from njtree
###############################################################################
analysis.dir/njtrees:
	$(PRELOG)
	@rm -f $@
	@for dir in data.dir/cluster*.dir; do \
		cluster_id=$${dir#data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		file=$${dir}/cluster_$${cluster_id}.tree.log; \
		if test -e $${file}; then \
			printf ">%s\n%s\n" $${cluster_id} `grep -v "^#" $${file} | perl -p -e "s/\s//g"` >> $@; \
		else \
			echo "file not found: $${file}" >> $@.err; \
		fi; \
	done
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Targets for subtree analysis
#######################################################################################
analysis-hook: filtered trees.stats trees.recall \
		count_orgs orthologs.gz pairwise_inparalogs.gz full_inparalogs.gz 


#######################################################################################
#######################################################################################
#######################################################################################
## Statistics for trees
#######################################################################################
trees.stats: trees
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) python $(DIR_SCRIPTS_TOOLS)tree2stats.py --method=branchlengths \
	< $< > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Compare input to output and find out how many genes/transcripts have been dropped
## due to aborted computations
#######################################################################################
trees.recall: trees
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) python $(DIR_SCRIPTS_TOOLS)tree2taxa.py --skip-trees < $< > $@.taxa
	@$(CMD_REMOTE_SUBMIT) python $(DIR_SCRIPTS_GENEPREDICTION)diff_transcript_sets.py \
		--add-percent \
		--dump-sets=rest_genes2 \
		--output-pattern="trees.recall.%s" \
		$@.taxa ../input.map > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Count number of species in each cluster
#######################################################################################
count_orgs: trees
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) \
	python $(DIR_SCRIPTS_GENEPREDICTION)optic/count_orgs.py \
		--reference-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		--format=trees \
		--filename-patterns=$@.patterns \
		--filename-summary=$@.summary \
	< $< > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Extract sets of 1:1 orthologs
#######################################################################################
orthologs.gz: trees
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) \
	python $(DIR_SCRIPTS_TOOLS)trees2sets.py \
		--reference-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		--filename-summary=$@.summary \
		--enumeration=$(PARAM_ANALYSIS_DUPLICATIONS_ORTHOLOG_SETS) \
		--method=strict \
		< $< | gzip > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Get lists of pairwise in-paralogs
#######################################################################################
pairwise_inparalogs.gz: trees
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) \
	python $(DIR_SCRIPTS_TOOLS)trees2sets.py \
		--reference-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		--filename-summary=$@.summary \
		--enumeration=pairwise \
		--method=degenerate \
		< $< | gzip > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Get lists of full inparalogs - those with the full species set
#######################################################################################
full_inparalogs.gz: trees
	$(PRELOG)
	@$(CMD_REMOTE_SUBMIT) \
	python $(DIR_SCRIPTS_TOOLS)trees2sets.py \
		--reference-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		--filename-summary=$@.summary \
		--enumeration=full \
		--method=outgroup \
		--outgroups=$(PARAM_ANALYSIS_DUPLICATIONS_OUTGROUPS) \
		< $< | gzip > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Get counts of trees for tree statistics
#######################################################################################
subtrees-counts-trees:
	@grep "noutput=" analysis.dir/subtrees*.summary.dir/tree*.summary |\
	perl -p -e "s/analysis.dir\/subtrees_*//; s/\.summary.dir\//\t/; s/.summary/\t/; s/:#//; s/,/\t/g; " |\
	awk 'NR == 1 \
		{ t[1]="section1"; t[2]="section2";  \
		for (x = 3; x <= NF; ++x) { split($$x, a, "="); t[x] = a[1]; } \
		printf("%s", t[1]); for (x = 2; x <= NF; ++x) { printf ("\t%s", t[x]); } printf("\n"); } \
	     	{ v[1] = $$1; v[2] = $$2; \
		for (x = 3; x <= NF; ++x) { split($$x, a, "="); v[x] = a[2] } \
		printf("%s", v[1]); for (x = 2; x <= NF; ++x) { printf ("\t%s", v[x]); } printf("\n"); }' 

#######################################################################################
#######################################################################################
#######################################################################################
## Get counts of trees analized for duplications
#######################################################################################
subtrees-counts-duplications:
	@grep "noutput=" analysis.dir/subtrees*.summary.dir/duplications*.summary |\
	perl -p -e "s/analysis.dir\/subtrees_*//; s/\.summary.dir\//\t/; s/.summary/\t/; s/:#//; s/,/\t/g; " |\
	awk 'NR == 1 \
		{ t[1]="section1"; t[2]="section2";  \
		for (x = 3; x <= NF; ++x) { split($$x, a, "="); t[x] = a[1]; } \
		printf("%s", t[1]); for (x = 2; x <= NF; ++x) { printf ("\t%s", t[x]); } printf("\n"); } \
	     	{ v[1] = $$1; v[2] = $$2; \
		for (x = 3; x <= NF; ++x) { split($$x, a, "="); v[x] = a[2] } \
		printf("%s", v[1]); for (x = 2; x <= NF; ++x) { printf ("\t%s", v[x]); } printf("\n"); }' 


#######################################################################################
#######################################################################################
#######################################################################################
## Collect results from analysis for plots
#######################################################################################
ANALYSIS_SUBGROUPS1?=subtrees_fitch subtrees_ml subtrees_input
ANALYSIS_SUBGROUPS2?=all filtered_all filtered_genes filtered_pseudos

#######################################################################################
#######################################################################################
#######################################################################################
## collect mean and stddev of distance of species to root averaged over all trees
## use heights/relheights as target modifiers
#######################################################################################
analysis.dir/species_%.stats:
	$(PRELOG)
	@for s1 in $(ANALYSIS_SUBGROUPS1); do \
		for s2 in $(ANALYSIS_SUBGROUPS2); do \
			printf "species\t%s\t%s\n" $${s1}_$${s2} stderr > $@_tmp_$${s1}_$${s2}; \
			grep -e "total" -e "prefix" \
				analysis.dir/$${s1}.summary.dir/trees_$${s2}.summary.dir/species_$*.trees |\
			$(YT)csv_cut.py species mean stddev -v 0 |\
			grep -v "species" >> $@_tmp_$${s1}_$${s2}; \
		done; \
	done
	@$(YT)combine_tables.py -v 0 $@_tmp_* |\
	$(CMD_TRANSLATE) > $@
	@rm -f $@_tmp_*;
	$(EPILOG)

analysis.dir/species_%_relheights.hist:
	$(PRELOG)
	@grep -e "total" -e "prefix" \
		analysis.dir/subtrees_ml.summary.dir/trees_$*.summary.dir/species_relheights.trees |\
		$(YT)csv_cut.py prefix species heights -v 0 > $@_tmp_total;
	@for genome in $(PARAM_SRC_SCHEMAS); do \
		printf "bin\t%s\n" $${genome} > $@_tmp_$${genome}; \
		grep -e "$${genome}" -e "prefix" < $@_tmp_total |\
		$(YT)csv_cut.py heights |\
		perl -p -e "s/,/\n/g" |\
		$(YT)trees2histogram.py \
			--min-value=0.0 \
			--bin-size=0.01 \
			--normalize \
			--cumulative \
			--verbose=0 |\
		grep -v "bin" >> $@_tmp_$${genome}; \
	done
	@rm -f $@_tmp_total
	@$(YT)combine_histograms.py \
		--missing="-" \
	$@_tmp_* |\
	$(CMD_TRANSLATE) > $@
	@rm -f $@_tmp_*;
	$(EPILOG)


analysis.dir/species_%_heights.hist:
	$(PRELOG)
	@grep -e "total" -e "prefix" \
		analysis.dir/subtrees_ml.summary.dir/trees_$*.summary.dir/species_heights.trees |\
		$(YT)csv_cut.py prefix species heights -v 0 > $@_tmp_total;
	@for genome in $(PARAM_SRC_SCHEMAS); do \
		printf "bin\t%s\n" $${genome} > $@_tmp_$${genome}; \
		grep -e "$${genome}" -e "prefix" < $@_tmp_total |\
		$(YT)csv_cut.py heights |\
		perl -p -e "s/,/\n/g" |\
		$(YT)trees2histogram.py \
			--min-value=0.0 \
			--bin-size=0.01 \
			--normalize \
			--cumulative \
			--verbose=0 |\
		grep -v "bin" >> $@_tmp_$${genome}; \
	done
	@rm -f $@_tmp_total
	@$(YT)combine_histograms.py \
		--missing="-" \
	$@_tmp_* |\
	$(CMD_TRANSLATE) > $@
	@rm -f $@_tmp_*;
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## compute histograms of heights of trees (longest distance of leaf to root)
## use heights/relheights as target modifiers
#######################################################################################
analysis.dir/tree_heights.hists: ANALYSIS_TREE_HISTS_BIN_SIZE=0.1
analysis.dir/tree_relheights.hists: ANALYSIS_TREE_HISTS_BIN_SIZE=0.02
analysis.dir/tree_%.hists:
	$(PRELOG)
	@for category in min max mean stddev; do \
	    for s1 in $(ANALYSIS_SUBGROUPS1); do \
		    for s2 in $(ANALYSIS_SUBGROUPS2); do \
			    printf "bin\t%s\n" $${s1}_$${s2} > $@_tmp_$${category}_$${s1}_$${s2}; \
			    grep -v "total" analysis.dir/$${s1}.summary.dir/trees_$${s2}.summary.dir/tree_$*.trees |\
			    $(YT)csv_cut.py $${category} -v 0 |\
			    $(YT)trees2histogram.py \
				--min-value=0.0 \
				--bin-size=$(ANALYSIS_TREE_HISTS_BIN_SIZE) \
				--no-empty-bins |\
			    grep -v "bin" >> $@_tmp_$${category}_$${s1}_$${s2}; \
		    done; \
	    done; \
	    $(YT)combine_histograms.py -v 0 $@_tmp_* |\
	    $(CMD_TRANSLATE) > $@_$${category}; \
	    rm -f $@_tmp_*; \
	done
	$(EPILOG)


analysis.dir/tree_%.stats:
	$(PRELOG)
	@printf "section\tcategory\t" > $@
	@$(YT)trees2stats.py --write-header -v 0  >> $@
	@for category in min max mean stddev; do \
		for s1 in $(ANALYSIS_SUBGROUPS1); do \
		    for s2 in $(ANALYSIS_SUBGROUPS2); do \
			    printf "%s_%s\t" $${s1} $${s2} >> $@; \
			    grep -v "total" analysis.dir/$${s1}.summary.dir/trees_$${s2}.summary.dir/tree_$*.trees |\
			    $(YT)csv_cut.py $${category} -v 0 |\
			    $(YT)trees2stats.py --skip-header -v 0 --flat --format="%6.4f" --flat >> $@; \
		    done; \
	    done; \
	done
	$(EPILOG)

###################################################################
subtrees.plot:
	$(PRELOG)
	@find trees.dir -name "subtree_*_fixed_w_ml.tree" -exec cat {} \; |\
	python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_orthology_multiple.py \
		--filename-species-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		$(DUPLICATIONS_EXTRA_OPTIONS) \
		--output-pattern=$@_%s \
		--print-totals \
		--print-species-svg \
		--output-pattern-svg="test_%s.svg" \
		--svg-branch-lengths="uniform" \
		--filename-node-types=subtrees.summary_nodes \
	> $@
	$(EPILOG)

malis.summary:
	$(PRELOG)
	@cut -f 2 input.map | sort | uniq | grep "^[0-9]" |\
	python $(DIR_SCRIPTS_TOOLS)mali2summary.py \
		--pattern-mali=trees.dir/cluster_%s.dir/cluster_%s.masked_mali > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Summary targets
#######################################################################################

#######################################################################################
#######################################################################################
#######################################################################################
##
## Assignments of genes and transcripts to orthologous groups
## There are three levels of groups. From general to more specific:
## 1. cluster grouped by pairwise orthology -> cluster_id
## 2. cluster based on splitting trees      -> subcluster_id
## 3. transcript sets                       -> transcluster_id
##
## cluster_ids and subcluster_ids are summarized into a new list of consecutive ids called "group_id"
## The first step (tree2taxa) assigns these number to the tree.
## 
## Also computes summary information.
#######################################################################################
groups:
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)tree2taxa.py < ../analysis.dir/trees |\
	awk 'BEGIN { printf("group_id\tschema\tprediction\tgene\tclass\tcluster_id\tsubcluster_id\ttranscluster_id\n"); \
		     while (getline < "../analysis.dir/trees.map") { map[$$2] = $$1; }; \
			} \
		/^taxon/ {next;} \
		!/^#/ { old_group_id=map[$$2]; split(old_group_id, a, "_"); cluster_id = a[2]; subcluster_id = a[4]; \
		  split($$1, a, "$(PARAM_SEPARATOR)");  schema=a[1]; prediction_id=a[2]; gene_id=a[2]; class="UK"; \
		  printf("%i\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", $$2,schema,prediction_id,gene_id,class,cluster_id,subcluster_id,"1"); }' \
	> $@.members 
	@python $(DIR_SCRIPTS_TOOLS)csv_cut.py --verbose=0 cluster_id subcluster_id group_id < $@.members |\
	awk '{printf("%s-%s\t%s\n", $$1, $$2, $$3);}' |\
	$(DIR_SCRIPTS_TOOLS)hsort | uniq > $@.map 
	@cat ../analysis.dir/count_orgs |\
		awk 'BEGIN { OFS="\t"; \
		     	while (getline < "$@.map") { map[$$2] = $$1; }; \
			} \
			/^mali/ { $$1="group_id\tcluster_id\tsubcluster_id"; \
			nspecies=(NF-5)/2; \
			for (x = 5; x < 5 + nspecies; ++x) { $$x = "ngenes_" $$x; }; \
			for (x = 6+nspecies; x <= NF; ++x) { $$x = "ntranscripts_" $$x; }; \
			print; \
			next; } \
			!/^#/ { group_id=$$1; split(map[group_id], a, "-"); cluster_id = a[1]; subcluster_id = a[2]; \
				$$1=group_id "\t" cluster_id "\t" subcluster_id; print; next; }' \
	> $@
	@cp ../analysis.dir/count_orgs.summary $@.counts
	@grep -v "#" ../analysis.dir/count_orgs.patterns > $@.summary
	@awk 'BEGIN {printf("species_id\tschema\n"); } \
		/#/ {printf("%i\t%s\n", $$2+1, $$4)}' < ../analysis.dir/count_orgs.patterns > $@.species
	$(EPILOG)

## obsolete: there are some discrepancies between entries in the .clusters file and
## those ending up in the trees. The code above is quicker and consistent with the
## summary stats, but does not include the transcript set info.
full_groups:
	@printf "schema\tprediction\tgene\tclass\tgroup_id\tsubgroup_id\ttransgroup_id\n" > $@.members
	@for dir in trees.dir/cluster*.dir; do\
		cluster_id=$${dir#trees.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		if test -e $${dir}/cluster_$${cluster_id}.subtrees.dir; then \
		    for subdir in $${dir}/cluster_$${cluster_id}.subtrees.dir/subtree*.dir; do \
			    subcluster_id=`echo $${subdir} | sed "s/.*_tree0_//; s/.dir//"`; \
			    awk -v cluster=$${cluster_id} \
				-v subcluster=$${subcluster_id}\
				    '!/^#/ && !/^id/ {split($$1,a,"$(PARAM_SEPARATOR)"); \
				    printf("%s\t%s\t%s\t%s\t%i\t%i\t%i\n",\
					    a[1],a[2],a[2],"UK", \
					    cluster,subcluster,$$2)}' \
			    < $${subdir}/subtree_cluster_$${cluster_id}_tree0_$${subcluster_id}.clusters >> $@.members; \
		    done; \
		else \
			printf "error: $${dir}/cluster_$${cluster_id}.subtrees.dir does not exist\n" >> $@.err; \
		fi; \
	done 	
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Load groups into table
#######################################################################################
groups.load: groups
	$(PRELOG)
	@python $(DIR_SCRIPTS_TOOLS)csv2db.py \
		--backend=pg \
		--lowercase \
		--table=$(PARAM_TABLE_NAME_GROUPS) \
		--map="pattern:string" \
		< $< > $@
	@echo "loaded into $(PARAM_TABLE_NAME_GROUPS): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_GROUPS);' -t `" >> $(LOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_GROUPS_MEMBERS);" > /dev/null
	@grep -v -e "^#" -e "^group_id" $<.members |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_GROUPS_MEMBERS) FROM STDIN WITH NULL AS 'na'" >> $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_GROUPS_MEMBERS): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_GROUPS_MEMBERS);' -t `" >> $(LOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_GROUPS_SPECIES);" > /dev/null
	@grep -v -e "^#" -e "^species_id" $<.species |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_GROUPS_SPECIES) FROM STDIN WITH NULL AS 'na'" >> $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_GROUPS_SPECIES): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_GROUPS_SPECIES);' -t `"  >> $(LOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_GROUPS_SUMMARY);" > /dev/null
	@grep -v -e "^#" -e "^pattern" $<.summary |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_GROUPS_SUMMARY) FROM STDIN WITH NULL AS 'na'" >> $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_GROUPS_SUMMARY): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_GROUPS_SUMMARY);' -t `"  >> $(LOG)
	$(EPILOG)

#####################################################################################################
#####################################################################################################
#####################################################################################################
## Tables with orthologous groups information
#####################################################################################################
## Note: the table groups is created once groups is computed.
%.create-table-groups-summary:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	pattern TEXT, \
	ngroups INT, \
	isok BOOL );" \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index3 ON $* (pattern);" $(TO_NULL) 

%.create-table-groups-members:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	group_id INT, \
	schema TEXT, \
	prediction_id TEXT, \
	gene_id TEXT, \
	class TEXT, \
	cluster_id INT, \
	subcluster_id INT, \
	transcluster_id INT); " \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (schema,prediction_id);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index2 ON $* (schema,gene_id);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index3 ON $* (group_id);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index4 ON $* (cluster_id,subcluster_id);" $(TO_NULL) 

%.create-table-groups-species:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	species_id INT, \
	schema TEXT ); " \
	$(TO_NULL)

%.create-table-groups-comments:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE OR REPLACE FUNCTION set_updated() \
		RETURNS TRIGGER AS 'BEGIN NEW.updated = NOW(); RETURN NEW; END;' LANGUAGE 'plpgsql';" $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	group_id INT, \
	comment TEXT, \
	created TIMESTAMP DEFAULT now(), \
	updated TIMESTAMP DEFAULT now() );" \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (group_id);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE TRIGGER $(CMD_TABLE_PREFIX)_trigger BEFORE UPDATE ON $* FOR EACH ROW EXECUTE PROCEDURE set_updated();" $(TO_NULL)

#######################################################################################
#######################################################################################
#######################################################################################
## Synonym information
#######################################################################################
synonyms:
	$(PRELOG)
	@printf "schema\trep_prediction_id\trep_gene_id\trep_class\tmem_prediction_id\tmem_gene_id\tmem_class\n" > $@
	@for dir in trees.dir/cluster*.dir; do\
		cluster_id=$${dir#trees.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		if test -e $${dir}/cluster_$${cluster_id}.subtrees.dir; then \
		    for subdir in $${dir}/cluster_$${cluster_id}.subtrees.dir/subtree*.dir; do \
			    subcluster_id=`echo $${subdir} | sed "s/.*_tree0_//; s/.dir//"`; \
			    f=$${subdir}/subtree_cluster_$${cluster_id}_tree0_$${subcluster_id}.clusters.synonyms; \
		            if test -e $${f}; then \
				awk '!/^rep/ {split($$1,rep,"$(PARAM_SEPARATOR)"); split($$1,mem,"$(PARAM_SEPARATOR)"); \
				printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\n", rep[1],rep[2],rep[3],rep[4],mem[2],mem[3],mem[4]);}' \
			    	< $${f} >> $@; \
			    fi; \
		    done; \
		else \
			printf "error: $${dir}/cluster_$${cluster_id}.subtrees.dir does not exist\n" >> $@.err; \
		fi; \
	done 	

#######################################################################################
#######################################################################################
#######################################################################################
## Load synonyms into table
#######################################################################################
synonyms.load: synonyms
	$(PRELOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_SYNONYMS);" > /dev/null
	@grep -v -e "^#" -e "^schema" $< |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_SYNONYMS) FROM STDIN WITH NULL AS 'na'" > $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_SYNONYMS): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_SYNONYMS);' -t `"  >> $(LOG)
	@touch $@
	$(EPILOG)


%.create-table-synonyms:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	schema TEXT, \
	rep_prediction_id TEXT, \
	rep_gene_id TEXT, \
	rep_class TEXT, \
	mem_prediction_id TEXT, \
	mem_gene_id TEXT, \
	mem_class TEXT);" \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (schema,rep_prediction_id);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index2 ON $* (schema,mem_prediction_id);" $(TO_NULL) 

#######################################################################################
#######################################################################################
#######################################################################################
## Create table for groups trees
#######################################################################################
%.create-table-groups-trees:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	group_id INT, \
	nh TEXT, \
	svg TEXT );" \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (group_id);" $(TO_NULL) 

#######################################################################################
#######################################################################################
#######################################################################################
## Create table for cluster trees
#######################################################################################
%.create-table-cluster-trees:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	cluster_id INT, \
	nh TEXT, \
	svg TEXT );" \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (cluster_id);" $(TO_NULL) 

#######################################################################################
#######################################################################################
#######################################################################################
## Build groups trees
#######################################################################################
groups_trees: ../analysis.dir/trees all.map_id2pos
	$(PRELOG)
	@python $(DIR_SCRIPTS_GENEPREDICTION)optic/analyze_orthology_multiple.py \
		--filename-species-tree=$(PARAM_ANALYSIS_DUPLICATIONS_TREE) \
		--filename-species2colour=$(PARAM_ANALYSIS_DUPLICATIONS_COLOURS) \
		--filename-species2url=$(PARAM_ANALYSIS_DUPLICATIONS_URLS) \
		--filename-species2name=$(PARAM_ANALYSIS_DUPLICATIONS_TRANSLATION) \
		--filename-locations=all.map_id2pos \
		--max-separation=$(PARAM_ANALYSIS_DUPLICATIONS_MAX_SEPARATION) \
		--svg-no-legend \
		--gene-regex="^[^|]+\|([^|]+)" \
		--print-svg \
		--output-format="table" \
		--log=$@.log \
		< $< > $@
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Load groups trees into table.
#######################################################################################
groups_trees.load: groups_trees
	$(PRELOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_GROUPS_NJ_TREES);" > /dev/null
	@grep -v -e "#" -e "^name" < $< |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_GROUPS_NJ_TREES) FROM STDIN WITH NULL AS 'na'" > $@ 
	@$(PSQL_CONNECTION) "ANALYSE $(PARAM_TABLE_NAME_GROUPS_NJ_TREES)" >> $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_GROUPS_NJ_TREES): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_GROUPS_NJ_TREES);' -t `"  >> $(LOG)
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Build cluster trees
#######################################################################################
cluster_trees: ../analysis.dir/trees all.map_id2pos
	$(PRELOG)
	@printf "cluster_id\tnd\tsvg\n" > $@
	@for dir in ../data.dir/cluster*.dir; do\
		cluster_id=$${dir#../data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		file1=$${dir}/cluster_$${cluster_id}.tree; \
		file2=$${dir}/cluster_$${cluster_id}.duplications.svg; \
		if test -e $${file2}; then \
			printf "%s\t%s\t" $${cluster_id} \
				`grep -v "#" < $${file1} | perl -p -e "s/\s//g"` >> $@; \
			perl -p -e "s/[\n\t]/ /g" < $${file2} >> $@; \
			printf "\n" >> $@;\
		fi; \
	done
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Load paralog trees into table.
#######################################################################################
cluster_trees.load: cluster_trees
	$(PRELOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_CLUSTER_TREES);" > /dev/null
	@grep -v -e "^cluster_id" < $< |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_CLUSTER_TREES) FROM STDIN WITH NULL AS 'na'" > $@ 
	@$(PSQL_CONNECTION) "ANALYSE $(PARAM_TABLE_NAME_CLUSTER_TREES)" >> $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_CLUSTER_TREES): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_CLUSTER_TREES);' -t `"  >> $(LOG)
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Create table for cluster trees
#######################################################################################
%.create-table-cluster-trees:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	cluster_id INT, \
	nh TEXT, \
	svg TEXT );" \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (cluster_id);" $(TO_NULL) 


#######################################################################################
#######################################################################################
#######################################################################################
## Table definition of strict 1:1 orthologous groups
#######################################################################################
%.create-table-ortholog-sets:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	set_id INT, \
	group_id INT, \
	nspecies INT, \
	pattern TEXT \
	); " \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (set_id);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index2 ON $* (pattern);" $(TO_NULL) 

%.create-table-ortholog-sets-members:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	set_id INT, \
	schema TEXT, \
	prediction_id TEXT, \
	gene_id TEXT, \
	class TEXT ); " \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (set_id);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index2 ON $* (schema,gene_id);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index3 ON $* (schema,prediction_id);" $(TO_NULL) 

%.create-table-ortholog-sets-species:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	species_id INT, \
	schema TEXT ); " \
	$(TO_NULL)

#######################################################################################
#######################################################################################
#######################################################################################
## Collect data for strict 1:1 orthologous groups
#######################################################################################
ortholog_sets: ../analysis.dir/orthologs.gz
	$(PRELOG)
	@gunzip < $< |\
	python $(DIR_SCRIPTS_TOOLS)csv_cut.py cluster name nspecies pattern members |\
	awk '/^#/ { next; } \
	     /^cluster/ { printf("%s\t%s\t%s\t%s\n", "set_id", "group_id", $$3, $$4); \
		printf("set_id\tschema\tprediction_id\tgene_id\tclass\n") > "$@.members"; next; } \
		{ group_id=$$2; set_id=$$1; \
		  printf("%i\t%i\t%i\t%s\n", $$1, group_id, $$3, $$4); \
		  split($$5, a, ";"); \
		  for (x in a) { split(a[x], b, "$(PARAM_SEPARATOR)"); printf("%s\t%s\t%s\t%s\t%s\n", set_id, b[1], b[2], b[2], "UK" ) >> "$@.members" ; }\
		}' \
	> $@
	@gunzip < $< |\
	awk 'BEGIN { printf("species_id\tschema\n"); } \
		/^nspecies/ { i=0; for (x=6;x<6+NF-7;++x) {printf("%i\t%s\n",++i,$$x)};exit}'  \
	> $@.species
	@gzip $@.members
	$(EPILOG)

#######################################################################################
#######################################################################################
#######################################################################################
## Load data for strict 1:1 orthologous groups
#######################################################################################
ortholog_sets.load: ortholog_sets
	$(PRELOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_ORTHOLOG_SETS);" > /dev/null
	@grep -v -e "^#" -e "^set_id" $< |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_ORTHOLOG_SETS) FROM STDIN WITH NULL AS 'na'" > $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_ORTHOLOG_SETS): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_ORTHOLOG_SETS);' -t `"  >> $(LOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_ORTHOLOG_SETS_MEMBERS);" > /dev/null
	@gunzip < $<.members.gz |\
	grep -v -e "^#" -e "^set_id" |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_ORTHOLOG_SETS_MEMBERS) FROM STDIN WITH NULL AS 'na'" > $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_ORTHOLOG_SETS_MEMBERS): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_ORTHOLOG_SETS_MEMBERS);' -t `"  >> $(LOG)
	@touch $@
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_ORTHOLOG_SETS_SPECIES);" > /dev/null
	@grep -v -e "^#" -e "^species_id" $<.species |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_ORTHOLOG_SETS_SPECIES) FROM STDIN WITH NULL AS 'na'" > $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_ORTHOLOG_SETS_SPECIES): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_ORTHOLOG_SETS_SPECIES);' -t `"  >> $(LOG)
	@touch $@
	$(EPILOG)


#######################################################################################
#######################################################################################
#######################################################################################
## Table definition for synteny data
#######################################################################################
%.create-table-synteny:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	synteny_id INT, \
	group_id INT, \
	schema TEXT, \
	gene_id TEXT, \
	sbjct_token TEXT, \
	sbjct_strand CHAR(1), \
	export_sbjct_genome_from INT, \
	export_sbjct_genome_TO INT \
	); " \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (synteny_id);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index2 ON $* (group_id);" $(TO_NULL) 
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index3 ON $* (schema,gene_id);" $(TO_NULL) 


#######################################################################################
#######################################################################################
#######################################################################################
## Load synteny data into table. Simply number all genes in a species consecutively that
## are part of an orthologous group.
##
## This also creates a stored procedure in PSQL that permits querying for syntenic
## members around a specific ortholog group
#######################################################################################
synteny.load: groups.load
	$(PRELOG)
	@rm -f $@.tmp;
	@for schema in $(PARAM_SRC_SCHEMAS); do \
		$(PSQL_CONNECTION) "SELECT group_id, m.schema, m.gene_id, \
			sbjct_token, sbjct_strand, \
			MIN(o.export_sbjct_genome_from) AS min_from, \
			MAX( o.export_sbjct_genome_to) AS max_to \
			FROM $(PARAM_TABLE_NAME_GROUPS_MEMBERS) AS m, \
			$${schema}.overview AS o \
			WHERE CAST(o.gene_id AS TEXT) = CAST(m.gene_id AS TEXT)\
			AND m.schema = '$${schema}' \
			GROUP BY m.group_id, m.schema, m.gene_id, sbjct_token, sbjct_strand \
			ORDER BY sbjct_token, min_from, max_to \
			" \
		$(PSQL_CONNECTION_OPTIONS) >> $@.tmp; \
	done
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_SYNTENY);" > /dev/null
	@awk '{printf("%i\t%s\n", ++i, $$0);}' < $@.tmp |\
	$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_SYNTENY) FROM STDIN WITH NULL AS 'na'" > $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_SYNTENY): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_SYNTENY);' -t `"  >> $(LOG)
	@rm -f $@.tmp; 
	@$(PSQL_CONNECTION) "\
	CREATE OR REPLACE FUNCTION $(PARAM_PSQL_SCHEMA).get_near_synteny( INT, INT ) \
	RETURNS SETOF INTEGER \
	LANGUAGE plpgsql \
	AS \$$_\$$ \
	DECLARE myrec RECORD; \
	DECLARE myrec2 RECORD; \
	BEGIN \
	FOR myrec IN \
	    SELECT synteny_id FROM $(PARAM_TABLE_NAME_SYNTENY) \
	    WHERE group_id = \$$1 \
	LOOP \
	    FOR myrec2 IN \
	       SELECT synteny_id FROM $(PARAM_TABLE_NAME_SYNTENY) \
	       WHERE synteny_id \
		BETWEEN myrec.synteny_id-\$$2 \
		AND myrec.synteny_id+\$$2 \
	    LOOP \
	      RETURN NEXT myrec2.synteny_id; \
	    END LOOP; \
	END LOOP; \
	RETURN; \
	END; \
	\$$_\$$;\
	"
	@touch $@
	$(EPILOG)



#########################################################################
#########################################################################
#########################################################################
## Table information for removed transcripts
#########################################################################
%.create-table-removed-transcripts: 
	$(PRELOG)
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	cluster_id INT, \
	level TEXT, \
	schema TEXT, \
	prediction_id TEXT, \
	gene_id TEXT, \
	class CHAR(2), \
	rep_schema TEXT, \
	rep_prediction_id TEXT, \
	rep_gene_id TEXT, \
	rep_class CHAR(2), \
	reason TEXT)" $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_schema ON $* (schema);" $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_schema_prediction_id ON $* (schema,prediction_id);" $(TO_NULL)
	$(EPILOG)

removed: 
	$(PRELOG)
	@for dir in ../data.dir/cluster*.dir; do\
		cluster_id=$${dir#../data.dir/cluster_}; \
		cluster_id=$${cluster_id%.dir}; \
		file=$${dir}/cluster_$${cluster_id}.removed; \
		if test -e $${file}; then \
			awk '!/removed/' < $${file} | sort | uniq |\
			awk -v cluster_id=$${cluster_id} \
				'BEGIN {FS="\t"} { split($$1,a,"$(PARAM_SEPARATOR)"); split($$2,b,"$(PARAM_SEPARATOR)"); \
				printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", \
				cluster_id, \
				"split",\
				a[1],a[2],a[2],"UK", \
				b[1],b[2],b[2],"UK", \
				$$3);}' >> $@; \
		fi; \
	done
	$(EPILOG)

removed.load: removed
	$(PRELOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_REMOVED_TRANSCRIPTS);" $(TO_NULL)
	@$(PSQL_CONNECTION) "COPY $(PARAM_TABLE_NAME_REMOVED_TRANSCRIPTS) FROM STDIN WITH NULL AS 'na'" < $< > $@ 
	@$(PSQL_CONNECTION) "ANALYSE $(PARAM_TABLE_NAME_REMOVED_TRANSCRIPTS)" >> $@ 
	@echo "loaded into $(PARAM_TABLE_NAME_REMOVED_TRANSCRIPTS): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_REMOVED_TRANSCRIPTS);' -t `"  >> $(LOG)
	$(EPILOG)	

#######################################################################################
#######################################################################################
#######################################################################################
## Table definition for orphans
#######################################################################################
%.create-table-orphans:
	$(CMD_LOG) "creating table $*"
	-@$(PSQL_CONNECTION) "DROP TABLE $* CASCADE " $(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE TABLE $* ( \
	schema TEXT, \
	gene_id TEXT \
	); " \
	$(TO_NULL)
	@$(PSQL_CONNECTION) "CREATE INDEX $(CMD_TABLE_PREFIX)_index1 ON $* (schema,gene_id);" $(TO_NULL) 

#######################################################################################
#######################################################################################
#######################################################################################
## Load orphans information.
#######################################################################################
orphans.load: groups.load
	$(PRELOG)
	@$(PSQL_CONNECTION) "DELETE FROM $(PARAM_TABLE_NAME_ORPHANS);" $(TO_NULL)
	@for schema in $(PARAM_SRC_SCHEMAS); do \
		$(PSQL_CONNECTION) "INSERT INTO $(PARAM_TABLE_NAME_ORPHANS) \
			SELECT DISTINCT '$${schema}', g.gene_id \
			FROM $${schema}.genes AS g \
			LEFT JOIN $(PARAM_TABLE_NAME_GROUPS_MEMBERS) AS m \
			ON CAST(m.gene_id AS TEXT)= CAST(g.gene_id AS TEXT) AND m.schema = '$${schema}' \
			WHERE m.group_id is null; "; \
	done
	@touch $@
	@echo "loaded into $(PARAM_TABLE_NAME_ORPHANS): `$(PSQL_CONNECTION) 'SELECT COUNT(*) FROM $(PARAM_TABLE_NAME_ORPHANS);' -t `"  >> $(LOG)
	$(EPILOG)

clean-subdir:
	rm -rf *.output *.ctl *.dir *.log *.map *.phylip *.tree

clean:
	$(PRELOG)
	@rm -rf data.{run,dir,prepare,finish} all.exons all.map_id2pos
	$(EPILOG)

#######################################################################################
include $(DIR_SCRIPTS_GENEPREDICTION)/makefiles/Makefile.common

